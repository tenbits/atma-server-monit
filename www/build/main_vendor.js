/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/material-components/material-components-web/blob/master/LICENSE
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["mdc"] = factory();
	else
		root["mdc"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./packages/material-components-web/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./packages/material-components-web/index.ts":
/*!***************************************************!*\
  !*** ./packages/material-components-web/index.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __importDefault(__webpack_require__(/*! @material/auto-init/index */ "./packages/mdc-auto-init/index.ts"));
exports.autoInit = index_1.default;
var base = __importStar(__webpack_require__(/*! @material/base/index */ "./packages/mdc-base/index.ts"));
exports.base = base;
var checkbox = __importStar(__webpack_require__(/*! @material/checkbox/index */ "./packages/mdc-checkbox/index.ts"));
exports.checkbox = checkbox;
var chips = __importStar(__webpack_require__(/*! @material/chips/index */ "./packages/mdc-chips/index.ts"));
exports.chips = chips;
var circularProgress = __importStar(__webpack_require__(/*! @material/circular-progress/index */ "./packages/mdc-circular-progress/index.ts"));
exports.circularProgress = circularProgress;
var dataTable = __importStar(__webpack_require__(/*! @material/data-table/index */ "./packages/mdc-data-table/index.ts"));
exports.dataTable = dataTable;
var dialog = __importStar(__webpack_require__(/*! @material/dialog/index */ "./packages/mdc-dialog/index.ts"));
exports.dialog = dialog;
var dom = __importStar(__webpack_require__(/*! @material/dom/index */ "./packages/mdc-dom/index.ts"));
exports.dom = dom;
var drawer = __importStar(__webpack_require__(/*! @material/drawer/index */ "./packages/mdc-drawer/index.ts"));
exports.drawer = drawer;
var floatingLabel = __importStar(__webpack_require__(/*! @material/floating-label/index */ "./packages/mdc-floating-label/index.ts"));
exports.floatingLabel = floatingLabel;
var formField = __importStar(__webpack_require__(/*! @material/form-field/index */ "./packages/mdc-form-field/index.ts"));
exports.formField = formField;
var iconButton = __importStar(__webpack_require__(/*! @material/icon-button/index */ "./packages/mdc-icon-button/index.ts"));
exports.iconButton = iconButton;
var lineRipple = __importStar(__webpack_require__(/*! @material/line-ripple/index */ "./packages/mdc-line-ripple/index.ts"));
exports.lineRipple = lineRipple;
var linearProgress = __importStar(__webpack_require__(/*! @material/linear-progress/index */ "./packages/mdc-linear-progress/index.ts"));
exports.linearProgress = linearProgress;
var list = __importStar(__webpack_require__(/*! @material/list/index */ "./packages/mdc-list/index.ts"));
exports.list = list;
var menuSurface = __importStar(__webpack_require__(/*! @material/menu-surface/index */ "./packages/mdc-menu-surface/index.ts"));
exports.menuSurface = menuSurface;
var menu = __importStar(__webpack_require__(/*! @material/menu/index */ "./packages/mdc-menu/index.ts"));
exports.menu = menu;
var notchedOutline = __importStar(__webpack_require__(/*! @material/notched-outline/index */ "./packages/mdc-notched-outline/index.ts"));
exports.notchedOutline = notchedOutline;
var radio = __importStar(__webpack_require__(/*! @material/radio/index */ "./packages/mdc-radio/index.ts"));
exports.radio = radio;
var ripple = __importStar(__webpack_require__(/*! @material/ripple/index */ "./packages/mdc-ripple/index.ts"));
exports.ripple = ripple;
var select = __importStar(__webpack_require__(/*! @material/select/index */ "./packages/mdc-select/index.ts"));
exports.select = select;
var slider = __importStar(__webpack_require__(/*! @material/slider/index */ "./packages/mdc-slider/index.ts"));
exports.slider = slider;
var snackbar = __importStar(__webpack_require__(/*! @material/snackbar/index */ "./packages/mdc-snackbar/index.ts"));
exports.snackbar = snackbar;
var switchControl = __importStar(__webpack_require__(/*! @material/switch/index */ "./packages/mdc-switch/index.ts"));
exports.switchControl = switchControl;
var tabBar = __importStar(__webpack_require__(/*! @material/tab-bar/index */ "./packages/mdc-tab-bar/index.ts"));
exports.tabBar = tabBar;
var tabIndicator = __importStar(__webpack_require__(/*! @material/tab-indicator/index */ "./packages/mdc-tab-indicator/index.ts"));
exports.tabIndicator = tabIndicator;
var tabScroller = __importStar(__webpack_require__(/*! @material/tab-scroller/index */ "./packages/mdc-tab-scroller/index.ts"));
exports.tabScroller = tabScroller;
var tab = __importStar(__webpack_require__(/*! @material/tab/index */ "./packages/mdc-tab/index.ts"));
exports.tab = tab;
var textField = __importStar(__webpack_require__(/*! @material/textfield/index */ "./packages/mdc-textfield/index.ts"));
exports.textField = textField;
var topAppBar = __importStar(__webpack_require__(/*! @material/top-app-bar/index */ "./packages/mdc-top-app-bar/index.ts"));
exports.topAppBar = topAppBar;
// Register all components
index_1.default.register('MDCCheckbox', checkbox.MDCCheckbox);
index_1.default.register('MDCChip', chips.MDCChip);
index_1.default.register('MDCChipSet', chips.MDCChipSet);
index_1.default.register('MDCCircularProgress', circularProgress.MDCCircularProgress);
index_1.default.register('MDCDataTable', dataTable.MDCDataTable);
index_1.default.register('MDCDialog', dialog.MDCDialog);
index_1.default.register('MDCDrawer', drawer.MDCDrawer);
index_1.default.register('MDCFloatingLabel', floatingLabel.MDCFloatingLabel);
index_1.default.register('MDCFormField', formField.MDCFormField);
index_1.default.register('MDCIconButtonToggle', iconButton.MDCIconButtonToggle);
index_1.default.register('MDCLineRipple', lineRipple.MDCLineRipple);
index_1.default.register('MDCLinearProgress', linearProgress.MDCLinearProgress);
index_1.default.register('MDCList', list.MDCList);
index_1.default.register('MDCMenu', menu.MDCMenu);
index_1.default.register('MDCMenuSurface', menuSurface.MDCMenuSurface);
index_1.default.register('MDCNotchedOutline', notchedOutline.MDCNotchedOutline);
index_1.default.register('MDCRadio', radio.MDCRadio);
index_1.default.register('MDCRipple', ripple.MDCRipple);
index_1.default.register('MDCSelect', select.MDCSelect);
index_1.default.register('MDCSlider', slider.MDCSlider);
index_1.default.register('MDCSnackbar', snackbar.MDCSnackbar);
index_1.default.register('MDCSwitch', switchControl.MDCSwitch);
index_1.default.register('MDCTabBar', tabBar.MDCTabBar);
index_1.default.register('MDCTextField', textField.MDCTextField);
index_1.default.register('MDCTopAppBar', topAppBar.MDCTopAppBar);

/***/ }),

/***/ "./packages/mdc-animation/util.ts":
/*!****************************************!*\
  !*** ./packages/mdc-animation/util.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssPropertyNameMap = {
    animation: {
        prefixed: '-webkit-animation',
        standard: 'animation'
    },
    transform: {
        prefixed: '-webkit-transform',
        standard: 'transform'
    },
    transition: {
        prefixed: '-webkit-transition',
        standard: 'transition'
    }
};
var jsEventTypeMap = {
    animationend: {
        cssProperty: 'animation',
        prefixed: 'webkitAnimationEnd',
        standard: 'animationend'
    },
    animationiteration: {
        cssProperty: 'animation',
        prefixed: 'webkitAnimationIteration',
        standard: 'animationiteration'
    },
    animationstart: {
        cssProperty: 'animation',
        prefixed: 'webkitAnimationStart',
        standard: 'animationstart'
    },
    transitionend: {
        cssProperty: 'transition',
        prefixed: 'webkitTransitionEnd',
        standard: 'transitionend'
    }
};
function isWindow(windowObj) {
    return Boolean(windowObj.document) && typeof windowObj.document.createElement === 'function';
}
function getCorrectPropertyName(windowObj, cssProperty) {
    if (isWindow(windowObj) && cssProperty in cssPropertyNameMap) {
        var el = windowObj.document.createElement('div');
        var _a = cssPropertyNameMap[cssProperty],
            standard = _a.standard,
            prefixed = _a.prefixed;
        var isStandard = standard in el.style;
        return isStandard ? standard : prefixed;
    }
    return cssProperty;
}
exports.getCorrectPropertyName = getCorrectPropertyName;
function getCorrectEventName(windowObj, eventType) {
    if (isWindow(windowObj) && eventType in jsEventTypeMap) {
        var el = windowObj.document.createElement('div');
        var _a = jsEventTypeMap[eventType],
            standard = _a.standard,
            prefixed = _a.prefixed,
            cssProperty = _a.cssProperty;
        var isStandard = cssProperty in el.style;
        return isStandard ? standard : prefixed;
    }
    return eventType;
}
exports.getCorrectEventName = getCorrectEventName;

/***/ }),

/***/ "./packages/mdc-auto-init/constants.ts":
/*!*********************************************!*\
  !*** ./packages/mdc-auto-init/constants.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.strings = {
  AUTO_INIT_ATTR: 'data-mdc-auto-init',
  AUTO_INIT_STATE_ATTR: 'data-mdc-auto-init-state',
  INITIALIZED_STATE: 'initialized'
};

/***/ }),

/***/ "./packages/mdc-auto-init/index.ts":
/*!*****************************************!*\
  !*** ./packages/mdc-auto-init/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __values = this && this.__values || function (o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-auto-init/constants.ts");
var AUTO_INIT_ATTR = constants_1.strings.AUTO_INIT_ATTR,
    AUTO_INIT_STATE_ATTR = constants_1.strings.AUTO_INIT_STATE_ATTR,
    INITIALIZED_STATE = constants_1.strings.INITIALIZED_STATE;
var registry = {};
var CONSOLE_WARN = console.warn.bind(console); // tslint:disable-line:no-console
function emit(evtType, evtData, shouldBubble) {
    if (shouldBubble === void 0) {
        shouldBubble = false;
    }
    var evt;
    if (typeof CustomEvent === 'function') {
        evt = new CustomEvent(evtType, {
            bubbles: shouldBubble,
            detail: evtData
        });
    } else {
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }
    document.dispatchEvent(evt);
}
/* istanbul ignore next: optional argument is not a branch statement */
/**
 * Auto-initializes all MDC components on a page.
 */
function mdcAutoInit(root) {
    var e_1, _a;
    if (root === void 0) {
        root = document;
    }
    var components = [];
    var nodes = [].slice.call(root.querySelectorAll("[" + AUTO_INIT_ATTR + "]"));
    nodes = nodes.filter(function (node) {
        return node.getAttribute(AUTO_INIT_STATE_ATTR) !== INITIALIZED_STATE;
    });
    try {
        for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
            var node = nodes_1_1.value;
            var ctorName = node.getAttribute(AUTO_INIT_ATTR);
            if (!ctorName) {
                throw new Error('(mdc-auto-init) Constructor name must be given.');
            }
            var Constructor = registry[ctorName]; // tslint:disable-line:variable-name
            if (typeof Constructor !== 'function') {
                throw new Error("(mdc-auto-init) Could not find constructor in registry for " + ctorName);
            }
            // TODO: Should we make an eslint rule for an attachTo() static method?
            // See https://github.com/Microsoft/TypeScript/issues/14600 for discussion of static interface support in TS
            var component = Constructor.attachTo(node);
            Object.defineProperty(node, ctorName, {
                configurable: true,
                enumerable: false,
                value: component,
                writable: false
            });
            components.push(component);
            node.setAttribute(AUTO_INIT_STATE_ATTR, INITIALIZED_STATE);
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    emit('MDCAutoInit:End', {});
    return components;
}
exports.mdcAutoInit = mdcAutoInit;
// Constructor is PascalCased because it is a direct reference to a class, rather than an instance of a class.
// tslint:disable-next-line:variable-name
mdcAutoInit.register = function (componentName, Constructor, warn) {
    if (warn === void 0) {
        warn = CONSOLE_WARN;
    }
    if (typeof Constructor !== 'function') {
        throw new Error("(mdc-auto-init) Invalid Constructor value: " + Constructor + ". Expected function.");
    }
    var registryValue = registry[componentName];
    if (registryValue) {
        warn("(mdc-auto-init) Overriding registration for " + componentName + " with " + Constructor + ". Was: " + registryValue);
    }
    registry[componentName] = Constructor;
};
mdcAutoInit.deregister = function (componentName) {
    delete registry[componentName];
};
mdcAutoInit.deregisterAll = function () {
    var keys = Object.keys(registry);
    keys.forEach(this.deregister, this);
};
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = mdcAutoInit;

/***/ }),

/***/ "./packages/mdc-base/component.ts":
/*!****************************************!*\
  !*** ./packages/mdc-base/component.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = this && this.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
    }return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-base/foundation.ts");
var MDCComponent = /** @class */function () {
    function MDCComponent(root, foundation) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        this.root_ = root;
        this.initialize.apply(this, __spread(args));
        // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.
        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
    }
    MDCComponent.attachTo = function (root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new foundation_1.MDCFoundation({}));
    };
    /* istanbul ignore next: method param only exists for typing purposes; it does not need to be unit tested */
    MDCComponent.prototype.initialize = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
        // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.
    };
    MDCComponent.prototype.getDefaultFoundation = function () {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
    };
    MDCComponent.prototype.initialSyncWithDOM = function () {
        // Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
    };
    MDCComponent.prototype.destroy = function () {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
    };
    MDCComponent.prototype.listen = function (evtType, handler, options) {
        this.root_.addEventListener(evtType, handler, options);
    };
    MDCComponent.prototype.unlisten = function (evtType, handler, options) {
        this.root_.removeEventListener(evtType, handler, options);
    };
    /**
     * Fires a cross-browser-compatible custom event from the component root of the given type, with the given data.
     */
    MDCComponent.prototype.emit = function (evtType, evtData, shouldBubble) {
        if (shouldBubble === void 0) {
            shouldBubble = false;
        }
        var evt;
        if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
                bubbles: shouldBubble,
                detail: evtData
            });
        } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }
        this.root_.dispatchEvent(evt);
    };
    return MDCComponent;
}();
exports.MDCComponent = MDCComponent;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCComponent;

/***/ }),

/***/ "./packages/mdc-base/foundation.ts":
/*!*****************************************!*\
  !*** ./packages/mdc-base/foundation.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var MDCFoundation = /** @class */function () {
    function MDCFoundation(adapter) {
        if (adapter === void 0) {
            adapter = {};
        }
        this.adapter_ = adapter;
    }
    Object.defineProperty(MDCFoundation, "cssClasses", {
        get: function get() {
            // Classes extending MDCFoundation should implement this method to return an object which exports every
            // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
            return {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "strings", {
        get: function get() {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
            return {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "numbers", {
        get: function get() {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
            return {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "defaultAdapter", {
        get: function get() {
            // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
            // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
            // validation.
            return {};
        },
        enumerable: true,
        configurable: true
    });
    MDCFoundation.prototype.init = function () {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
    };
    MDCFoundation.prototype.destroy = function () {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    };
    return MDCFoundation;
}();
exports.MDCFoundation = MDCFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCFoundation;

/***/ }),

/***/ "./packages/mdc-base/index.ts":
/*!************************************!*\
  !*** ./packages/mdc-base/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-base/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-base/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-checkbox/component.ts":
/*!********************************************!*\
  !*** ./packages/mdc-checkbox/component.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(/*! @material/animation/util */ "./packages/mdc-animation/util.ts");
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var events_1 = __webpack_require__(/*! @material/dom/events */ "./packages/mdc-dom/events.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var component_2 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! @material/ripple/foundation */ "./packages/mdc-ripple/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-checkbox/constants.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-checkbox/foundation.ts");
var CB_PROTO_PROPS = ['checked', 'indeterminate'];
var MDCCheckbox = /** @class */function (_super) {
    __extends(MDCCheckbox, _super);
    function MDCCheckbox() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ripple_ = _this.createRipple_();
        return _this;
    }
    MDCCheckbox.attachTo = function (root) {
        return new MDCCheckbox(root);
    };
    Object.defineProperty(MDCCheckbox.prototype, "ripple", {
        get: function get() {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckbox.prototype, "checked", {
        get: function get() {
            return this.nativeControl_.checked;
        },
        set: function set(checked) {
            this.nativeControl_.checked = checked;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckbox.prototype, "indeterminate", {
        get: function get() {
            return this.nativeControl_.indeterminate;
        },
        set: function set(indeterminate) {
            this.nativeControl_.indeterminate = indeterminate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckbox.prototype, "disabled", {
        get: function get() {
            return this.nativeControl_.disabled;
        },
        set: function set(disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckbox.prototype, "value", {
        get: function get() {
            return this.nativeControl_.value;
        },
        set: function set(value) {
            this.nativeControl_.value = value;
        },
        enumerable: true,
        configurable: true
    });
    MDCCheckbox.prototype.initialize = function () {
        var DATA_INDETERMINATE_ATTR = constants_1.strings.DATA_INDETERMINATE_ATTR;
        this.nativeControl_.indeterminate = this.nativeControl_.getAttribute(DATA_INDETERMINATE_ATTR) === 'true';
        this.nativeControl_.removeAttribute(DATA_INDETERMINATE_ATTR);
    };
    MDCCheckbox.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleChange_ = function () {
            return _this.foundation_.handleChange();
        };
        this.handleAnimationEnd_ = function () {
            return _this.foundation_.handleAnimationEnd();
        };
        this.nativeControl_.addEventListener('change', this.handleChange_);
        this.listen(util_1.getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
        this.installPropertyChangeHooks_();
    };
    MDCCheckbox.prototype.destroy = function () {
        this.ripple_.destroy();
        this.nativeControl_.removeEventListener('change', this.handleChange_);
        this.unlisten(util_1.getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
        this.uninstallPropertyChangeHooks_();
        _super.prototype.destroy.call(this);
    };
    MDCCheckbox.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            forceLayout: function forceLayout() {
                return _this.root_.offsetWidth;
            },
            hasNativeControl: function hasNativeControl() {
                return !!_this.nativeControl_;
            },
            isAttachedToDOM: function isAttachedToDOM() {
                return Boolean(_this.root_.parentNode);
            },
            isChecked: function isChecked() {
                return _this.checked;
            },
            isIndeterminate: function isIndeterminate() {
                return _this.indeterminate;
            },
            removeClass: function removeClass(className) {
                _this.root_.classList.remove(className);
            },
            removeNativeControlAttr: function removeNativeControlAttr(attr) {
                _this.nativeControl_.removeAttribute(attr);
            },
            setNativeControlAttr: function setNativeControlAttr(attr, value) {
                _this.nativeControl_.setAttribute(attr, value);
            },
            setNativeControlDisabled: function setNativeControlDisabled(disabled) {
                _this.nativeControl_.disabled = disabled;
            }
        };
        return new foundation_2.MDCCheckboxFoundation(adapter);
    };
    MDCCheckbox.prototype.createRipple_ = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = __assign(__assign({}, component_2.MDCRipple.createAdapter(this)), { deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                return _this.nativeControl_.removeEventListener(evtType, handler, events_1.applyPassive());
            }, isSurfaceActive: function isSurfaceActive() {
                return ponyfill_1.matches(_this.nativeControl_, ':active');
            }, isUnbounded: function isUnbounded() {
                return true;
            }, registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                return _this.nativeControl_.addEventListener(evtType, handler, events_1.applyPassive());
            } });
        return new component_2.MDCRipple(this.root_, new foundation_1.MDCRippleFoundation(adapter));
    };
    MDCCheckbox.prototype.installPropertyChangeHooks_ = function () {
        var _this = this;
        var nativeCb = this.nativeControl_;
        var cbProto = Object.getPrototypeOf(nativeCb);
        CB_PROTO_PROPS.forEach(function (controlState) {
            var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
            // We have to check for this descriptor, since some browsers (Safari) don't support its return.
            // See: https://bugs.webkit.org/show_bug.cgi?id=49739
            if (!validDescriptor(desc)) {
                return;
            }
            // Type cast is needed for compatibility with Closure Compiler.
            var nativeGetter = desc.get;
            var nativeCbDesc = {
                configurable: desc.configurable,
                enumerable: desc.enumerable,
                get: nativeGetter,
                set: function set(state) {
                    desc.set.call(nativeCb, state);
                    _this.foundation_.handleChange();
                }
            };
            Object.defineProperty(nativeCb, controlState, nativeCbDesc);
        });
    };
    MDCCheckbox.prototype.uninstallPropertyChangeHooks_ = function () {
        var nativeCb = this.nativeControl_;
        var cbProto = Object.getPrototypeOf(nativeCb);
        CB_PROTO_PROPS.forEach(function (controlState) {
            var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
            if (!validDescriptor(desc)) {
                return;
            }
            Object.defineProperty(nativeCb, controlState, desc);
        });
    };
    Object.defineProperty(MDCCheckbox.prototype, "nativeControl_", {
        get: function get() {
            var NATIVE_CONTROL_SELECTOR = constants_1.strings.NATIVE_CONTROL_SELECTOR;
            var el = this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
            if (!el) {
                throw new Error("Checkbox component requires a " + NATIVE_CONTROL_SELECTOR + " element");
            }
            return el;
        },
        enumerable: true,
        configurable: true
    });
    return MDCCheckbox;
}(component_1.MDCComponent);
exports.MDCCheckbox = MDCCheckbox;
function validDescriptor(inputPropDesc) {
    return !!inputPropDesc && typeof inputPropDesc.set === 'function';
}

/***/ }),

/***/ "./packages/mdc-checkbox/constants.ts":
/*!********************************************!*\
  !*** ./packages/mdc-checkbox/constants.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.cssClasses = {
    ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
    ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
    ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
    ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked',
    ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
    ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
    BACKGROUND: 'mdc-checkbox__background',
    CHECKED: 'mdc-checkbox--checked',
    CHECKMARK: 'mdc-checkbox__checkmark',
    CHECKMARK_PATH: 'mdc-checkbox__checkmark-path',
    DISABLED: 'mdc-checkbox--disabled',
    INDETERMINATE: 'mdc-checkbox--indeterminate',
    MIXEDMARK: 'mdc-checkbox__mixedmark',
    NATIVE_CONTROL: 'mdc-checkbox__native-control',
    ROOT: 'mdc-checkbox',
    SELECTED: 'mdc-checkbox--selected',
    UPGRADED: 'mdc-checkbox--upgraded'
};
exports.strings = {
    ARIA_CHECKED_ATTR: 'aria-checked',
    ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed',
    DATA_INDETERMINATE_ATTR: 'data-indeterminate',
    NATIVE_CONTROL_SELECTOR: '.mdc-checkbox__native-control',
    TRANSITION_STATE_CHECKED: 'checked',
    TRANSITION_STATE_INDETERMINATE: 'indeterminate',
    TRANSITION_STATE_INIT: 'init',
    TRANSITION_STATE_UNCHECKED: 'unchecked'
};
exports.numbers = {
    ANIM_END_LATCH_MS: 250
};

/***/ }),

/***/ "./packages/mdc-checkbox/foundation.ts":
/*!*********************************************!*\
  !*** ./packages/mdc-checkbox/foundation.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-checkbox/constants.ts");
var MDCCheckboxFoundation = /** @class */function (_super) {
    __extends(MDCCheckboxFoundation, _super);
    function MDCCheckboxFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCCheckboxFoundation.defaultAdapter), adapter)) || this;
        _this.currentCheckState_ = constants_1.strings.TRANSITION_STATE_INIT;
        _this.currentAnimationClass_ = '';
        _this.animEndLatchTimer_ = 0;
        _this.enableAnimationEndHandler_ = false;
        return _this;
    }
    Object.defineProperty(MDCCheckboxFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckboxFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckboxFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckboxFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                forceLayout: function forceLayout() {
                    return undefined;
                },
                hasNativeControl: function hasNativeControl() {
                    return false;
                },
                isAttachedToDOM: function isAttachedToDOM() {
                    return false;
                },
                isChecked: function isChecked() {
                    return false;
                },
                isIndeterminate: function isIndeterminate() {
                    return false;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                removeNativeControlAttr: function removeNativeControlAttr() {
                    return undefined;
                },
                setNativeControlAttr: function setNativeControlAttr() {
                    return undefined;
                },
                setNativeControlDisabled: function setNativeControlDisabled() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCCheckboxFoundation.prototype.init = function () {
        this.currentCheckState_ = this.determineCheckState_();
        this.updateAriaChecked_();
        this.adapter_.addClass(constants_1.cssClasses.UPGRADED);
    };
    MDCCheckboxFoundation.prototype.destroy = function () {
        clearTimeout(this.animEndLatchTimer_);
    };
    MDCCheckboxFoundation.prototype.setDisabled = function (disabled) {
        this.adapter_.setNativeControlDisabled(disabled);
        if (disabled) {
            this.adapter_.addClass(constants_1.cssClasses.DISABLED);
        } else {
            this.adapter_.removeClass(constants_1.cssClasses.DISABLED);
        }
    };
    /**
     * Handles the animationend event for the checkbox
     */
    MDCCheckboxFoundation.prototype.handleAnimationEnd = function () {
        var _this = this;
        if (!this.enableAnimationEndHandler_) {
            return;
        }
        clearTimeout(this.animEndLatchTimer_);
        this.animEndLatchTimer_ = setTimeout(function () {
            _this.adapter_.removeClass(_this.currentAnimationClass_);
            _this.enableAnimationEndHandler_ = false;
        }, constants_1.numbers.ANIM_END_LATCH_MS);
    };
    /**
     * Handles the change event for the checkbox
     */
    MDCCheckboxFoundation.prototype.handleChange = function () {
        this.transitionCheckState_();
    };
    MDCCheckboxFoundation.prototype.transitionCheckState_ = function () {
        if (!this.adapter_.hasNativeControl()) {
            return;
        }
        var oldState = this.currentCheckState_;
        var newState = this.determineCheckState_();
        if (oldState === newState) {
            return;
        }
        this.updateAriaChecked_();
        var TRANSITION_STATE_UNCHECKED = constants_1.strings.TRANSITION_STATE_UNCHECKED;
        var SELECTED = constants_1.cssClasses.SELECTED;
        if (newState === TRANSITION_STATE_UNCHECKED) {
            this.adapter_.removeClass(SELECTED);
        } else {
            this.adapter_.addClass(SELECTED);
        }
        // Check to ensure that there isn't a previously existing animation class, in case for example
        // the user interacted with the checkbox before the animation was finished.
        if (this.currentAnimationClass_.length > 0) {
            clearTimeout(this.animEndLatchTimer_);
            this.adapter_.forceLayout();
            this.adapter_.removeClass(this.currentAnimationClass_);
        }
        this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
        this.currentCheckState_ = newState;
        // Check for parentNode so that animations are only run when the element is attached
        // to the DOM.
        if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
            this.adapter_.addClass(this.currentAnimationClass_);
            this.enableAnimationEndHandler_ = true;
        }
    };
    MDCCheckboxFoundation.prototype.determineCheckState_ = function () {
        var TRANSITION_STATE_INDETERMINATE = constants_1.strings.TRANSITION_STATE_INDETERMINATE,
            TRANSITION_STATE_CHECKED = constants_1.strings.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = constants_1.strings.TRANSITION_STATE_UNCHECKED;
        if (this.adapter_.isIndeterminate()) {
            return TRANSITION_STATE_INDETERMINATE;
        }
        return this.adapter_.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
    };
    MDCCheckboxFoundation.prototype.getTransitionAnimationClass_ = function (oldState, newState) {
        var TRANSITION_STATE_INIT = constants_1.strings.TRANSITION_STATE_INIT,
            TRANSITION_STATE_CHECKED = constants_1.strings.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = constants_1.strings.TRANSITION_STATE_UNCHECKED;
        var _a = MDCCheckboxFoundation.cssClasses,
            ANIM_UNCHECKED_CHECKED = _a.ANIM_UNCHECKED_CHECKED,
            ANIM_UNCHECKED_INDETERMINATE = _a.ANIM_UNCHECKED_INDETERMINATE,
            ANIM_CHECKED_UNCHECKED = _a.ANIM_CHECKED_UNCHECKED,
            ANIM_CHECKED_INDETERMINATE = _a.ANIM_CHECKED_INDETERMINATE,
            ANIM_INDETERMINATE_CHECKED = _a.ANIM_INDETERMINATE_CHECKED,
            ANIM_INDETERMINATE_UNCHECKED = _a.ANIM_INDETERMINATE_UNCHECKED;
        switch (oldState) {
            case TRANSITION_STATE_INIT:
                if (newState === TRANSITION_STATE_UNCHECKED) {
                    return '';
                }
                return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
            case TRANSITION_STATE_UNCHECKED:
                return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
            case TRANSITION_STATE_CHECKED:
                return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
            default:
                // TRANSITION_STATE_INDETERMINATE
                return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
        }
    };
    MDCCheckboxFoundation.prototype.updateAriaChecked_ = function () {
        // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
        if (this.adapter_.isIndeterminate()) {
            this.adapter_.setNativeControlAttr(constants_1.strings.ARIA_CHECKED_ATTR, constants_1.strings.ARIA_CHECKED_INDETERMINATE_VALUE);
        } else {
            // The on/off state does not need to keep track of aria-checked, since
            // the screenreader uses the checked property on the checkbox element.
            this.adapter_.removeNativeControlAttr(constants_1.strings.ARIA_CHECKED_ATTR);
        }
    };
    return MDCCheckboxFoundation;
}(foundation_1.MDCFoundation);
exports.MDCCheckboxFoundation = MDCCheckboxFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCCheckboxFoundation;

/***/ }),

/***/ "./packages/mdc-checkbox/index.ts":
/*!****************************************!*\
  !*** ./packages/mdc-checkbox/index.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-checkbox/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-checkbox/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-checkbox/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-chips/chip-set/component.ts":
/*!**************************************************!*\
  !*** ./packages/mdc-chips/chip-set/component.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var announce_1 = __webpack_require__(/*! @material/dom/announce */ "./packages/mdc-dom/announce.ts");
var component_2 = __webpack_require__(/*! ../chip/component */ "./packages/mdc-chips/chip/component.ts");
var foundation_1 = __webpack_require__(/*! ../chip/foundation */ "./packages/mdc-chips/chip/foundation.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-chips/chip-set/foundation.ts");
var _a = foundation_1.MDCChipFoundation.strings,
    INTERACTION_EVENT = _a.INTERACTION_EVENT,
    SELECTION_EVENT = _a.SELECTION_EVENT,
    REMOVAL_EVENT = _a.REMOVAL_EVENT,
    NAVIGATION_EVENT = _a.NAVIGATION_EVENT;
var CHIP_SELECTOR = foundation_2.MDCChipSetFoundation.strings.CHIP_SELECTOR;
var idCounter = 0;
var MDCChipSet = /** @class */function (_super) {
    __extends(MDCChipSet, _super);
    function MDCChipSet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCChipSet.attachTo = function (root) {
        return new MDCChipSet(root);
    };
    Object.defineProperty(MDCChipSet.prototype, "chips", {
        get: function get() {
            return this.chips_.slice();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCChipSet.prototype, "selectedChipIds", {
        /**
         * @return An array of the IDs of all selected chips.
         */
        get: function get() {
            return this.foundation_.getSelectedChipIds();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param chipFactory A function which creates a new MDCChip.
     */
    MDCChipSet.prototype.initialize = function (chipFactory) {
        if (chipFactory === void 0) {
            chipFactory = function chipFactory(el) {
                return new component_2.MDCChip(el);
            };
        }
        this.chipFactory_ = chipFactory;
        this.chips_ = this.instantiateChips_(this.chipFactory_);
    };
    MDCChipSet.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.chips_.forEach(function (chip) {
            if (chip.id && chip.selected) {
                _this.foundation_.select(chip.id);
            }
        });
        this.handleChipInteraction_ = function (evt) {
            return _this.foundation_.handleChipInteraction(evt.detail);
        };
        this.handleChipSelection_ = function (evt) {
            return _this.foundation_.handleChipSelection(evt.detail);
        };
        this.handleChipRemoval_ = function (evt) {
            return _this.foundation_.handleChipRemoval(evt.detail);
        };
        this.handleChipNavigation_ = function (evt) {
            return _this.foundation_.handleChipNavigation(evt.detail);
        };
        this.listen(INTERACTION_EVENT, this.handleChipInteraction_);
        this.listen(SELECTION_EVENT, this.handleChipSelection_);
        this.listen(REMOVAL_EVENT, this.handleChipRemoval_);
        this.listen(NAVIGATION_EVENT, this.handleChipNavigation_);
    };
    MDCChipSet.prototype.destroy = function () {
        this.chips_.forEach(function (chip) {
            chip.destroy();
        });
        this.unlisten(INTERACTION_EVENT, this.handleChipInteraction_);
        this.unlisten(SELECTION_EVENT, this.handleChipSelection_);
        this.unlisten(REMOVAL_EVENT, this.handleChipRemoval_);
        this.unlisten(NAVIGATION_EVENT, this.handleChipNavigation_);
        _super.prototype.destroy.call(this);
    };
    /**
     * Adds a new chip object to the chip set from the given chip element.
     */
    MDCChipSet.prototype.addChip = function (chipEl) {
        chipEl.id = chipEl.id || "mdc-chip-" + ++idCounter;
        this.chips_.push(this.chipFactory_(chipEl));
    };
    MDCChipSet.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            announceMessage: function announceMessage(message) {
                announce_1.announce(message);
            },
            focusChipPrimaryActionAtIndex: function focusChipPrimaryActionAtIndex(index) {
                _this.chips_[index].focusPrimaryAction();
            },
            focusChipTrailingActionAtIndex: function focusChipTrailingActionAtIndex(index) {
                _this.chips_[index].focusTrailingAction();
            },
            getChipListCount: function getChipListCount() {
                return _this.chips_.length;
            },
            getIndexOfChipById: function getIndexOfChipById(chipId) {
                return _this.findChipIndex_(chipId);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            isRTL: function isRTL() {
                return window.getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
            },
            removeChipAtIndex: function removeChipAtIndex(index) {
                if (index >= 0 && index < _this.chips_.length) {
                    _this.chips_[index].destroy();
                    _this.chips_[index].remove();
                    _this.chips_.splice(index, 1);
                }
            },
            removeFocusFromChipAtIndex: function removeFocusFromChipAtIndex(index) {
                _this.chips_[index].removeFocus();
            },
            selectChipAtIndex: function selectChipAtIndex(index, selected, shouldNotifyClients) {
                if (index >= 0 && index < _this.chips_.length) {
                    _this.chips_[index].setSelectedFromChipSet(selected, shouldNotifyClients);
                }
            }
        };
        return new foundation_2.MDCChipSetFoundation(adapter);
    };
    /**
     * Instantiates chip components on all of the chip set's child chip elements.
     */
    MDCChipSet.prototype.instantiateChips_ = function (chipFactory) {
        var chipElements = [].slice.call(this.root_.querySelectorAll(CHIP_SELECTOR));
        return chipElements.map(function (el) {
            el.id = el.id || "mdc-chip-" + ++idCounter;
            return chipFactory(el);
        });
    };
    /**
     * Returns the index of the chip with the given id, or -1 if the chip does not exist.
     */
    MDCChipSet.prototype.findChipIndex_ = function (chipId) {
        for (var i = 0; i < this.chips_.length; i++) {
            if (this.chips_[i].id === chipId) {
                return i;
            }
        }
        return -1;
    };
    return MDCChipSet;
}(component_1.MDCComponent);
exports.MDCChipSet = MDCChipSet;

/***/ }),

/***/ "./packages/mdc-chips/chip-set/constants.ts":
/*!**************************************************!*\
  !*** ./packages/mdc-chips/chip-set/constants.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.strings = {
    CHIP_SELECTOR: '.mdc-chip'
};
exports.cssClasses = {
    CHOICE: 'mdc-chip-set--choice',
    FILTER: 'mdc-chip-set--filter'
};

/***/ }),

/***/ "./packages/mdc-chips/chip-set/foundation.ts":
/*!***************************************************!*\
  !*** ./packages/mdc-chips/chip-set/foundation.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ../chip/constants */ "./packages/mdc-chips/chip/constants.ts");
var constants_2 = __webpack_require__(/*! ./constants */ "./packages/mdc-chips/chip-set/constants.ts");
var MDCChipSetFoundation = /** @class */function (_super) {
    __extends(MDCChipSetFoundation, _super);
    function MDCChipSetFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCChipSetFoundation.defaultAdapter), adapter)) || this;
        /**
         * The ids of the selected chips in the set. Only used for choice chip set or filter chip set.
         */
        _this.selectedChipIds_ = [];
        return _this;
    }
    Object.defineProperty(MDCChipSetFoundation, "strings", {
        get: function get() {
            return constants_2.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCChipSetFoundation, "cssClasses", {
        get: function get() {
            return constants_2.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCChipSetFoundation, "defaultAdapter", {
        get: function get() {
            return {
                announceMessage: function announceMessage() {
                    return undefined;
                },
                focusChipPrimaryActionAtIndex: function focusChipPrimaryActionAtIndex() {
                    return undefined;
                },
                focusChipTrailingActionAtIndex: function focusChipTrailingActionAtIndex() {
                    return undefined;
                },
                getChipListCount: function getChipListCount() {
                    return -1;
                },
                getIndexOfChipById: function getIndexOfChipById() {
                    return -1;
                },
                hasClass: function hasClass() {
                    return false;
                },
                isRTL: function isRTL() {
                    return false;
                },
                removeChipAtIndex: function removeChipAtIndex() {
                    return undefined;
                },
                removeFocusFromChipAtIndex: function removeFocusFromChipAtIndex() {
                    return undefined;
                },
                selectChipAtIndex: function selectChipAtIndex() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an array of the IDs of all selected chips.
     */
    MDCChipSetFoundation.prototype.getSelectedChipIds = function () {
        return this.selectedChipIds_.slice();
    };
    /**
     * Selects the chip with the given id. Deselects all other chips if the chip set is of the choice variant.
     * Does not notify clients of the updated selection state.
     */
    MDCChipSetFoundation.prototype.select = function (chipId) {
        this.select_(chipId, false);
    };
    /**
     * Handles a chip interaction event
     */
    MDCChipSetFoundation.prototype.handleChipInteraction = function (_a) {
        var chipId = _a.chipId;
        var index = this.adapter_.getIndexOfChipById(chipId);
        this.removeFocusFromChipsExcept_(index);
        if (this.adapter_.hasClass(constants_2.cssClasses.CHOICE) || this.adapter_.hasClass(constants_2.cssClasses.FILTER)) {
            this.toggleSelect_(chipId);
        }
    };
    /**
     * Handles a chip selection event, used to handle discrepancy when selection state is set directly on the Chip.
     */
    MDCChipSetFoundation.prototype.handleChipSelection = function (_a) {
        var chipId = _a.chipId,
            selected = _a.selected,
            shouldIgnore = _a.shouldIgnore;
        // Early exit if we should ignore the event
        if (shouldIgnore) {
            return;
        }
        var chipIsSelected = this.selectedChipIds_.indexOf(chipId) >= 0;
        if (selected && !chipIsSelected) {
            this.select(chipId);
        } else if (!selected && chipIsSelected) {
            this.deselect_(chipId);
        }
    };
    /**
     * Handles the event when a chip is removed.
     */
    MDCChipSetFoundation.prototype.handleChipRemoval = function (_a) {
        var chipId = _a.chipId,
            removedAnnouncement = _a.removedAnnouncement;
        if (removedAnnouncement) {
            this.adapter_.announceMessage(removedAnnouncement);
        }
        var index = this.adapter_.getIndexOfChipById(chipId);
        this.deselectAndNotifyClients_(chipId);
        this.adapter_.removeChipAtIndex(index);
        var maxIndex = this.adapter_.getChipListCount() - 1;
        var nextIndex = Math.min(index, maxIndex);
        this.removeFocusFromChipsExcept_(nextIndex);
        // After removing a chip, we should focus the trailing action for the next chip.
        this.adapter_.focusChipTrailingActionAtIndex(nextIndex);
    };
    /**
     * Handles a chip navigation event.
     */
    MDCChipSetFoundation.prototype.handleChipNavigation = function (_a) {
        var chipId = _a.chipId,
            key = _a.key,
            source = _a.source;
        var maxIndex = this.adapter_.getChipListCount() - 1;
        var index = this.adapter_.getIndexOfChipById(chipId);
        // Early exit if the index is out of range or the key is unusable
        if (index === -1 || !constants_1.navigationKeys.has(key)) {
            return;
        }
        var isRTL = this.adapter_.isRTL();
        var isLeftKey = key === constants_1.strings.ARROW_LEFT_KEY || key === constants_1.strings.IE_ARROW_LEFT_KEY;
        var isRightKey = key === constants_1.strings.ARROW_RIGHT_KEY || key === constants_1.strings.IE_ARROW_RIGHT_KEY;
        var isDownKey = key === constants_1.strings.ARROW_DOWN_KEY || key === constants_1.strings.IE_ARROW_DOWN_KEY;
        var shouldIncrement = !isRTL && isRightKey || isRTL && isLeftKey || isDownKey;
        var isHome = key === constants_1.strings.HOME_KEY;
        var isEnd = key === constants_1.strings.END_KEY;
        if (shouldIncrement) {
            index++;
        } else if (isHome) {
            index = 0;
        } else if (isEnd) {
            index = maxIndex;
        } else {
            index--;
        }
        // Early exit if the index is out of bounds
        if (index < 0 || index > maxIndex) {
            return;
        }
        this.removeFocusFromChipsExcept_(index);
        this.focusChipAction_(index, key, source);
    };
    MDCChipSetFoundation.prototype.focusChipAction_ = function (index, key, source) {
        var shouldJumpChips = constants_1.jumpChipKeys.has(key);
        if (shouldJumpChips && source === constants_1.EventSource.PRIMARY) {
            return this.adapter_.focusChipPrimaryActionAtIndex(index);
        }
        if (shouldJumpChips && source === constants_1.EventSource.TRAILING) {
            return this.adapter_.focusChipTrailingActionAtIndex(index);
        }
        var dir = this.getDirection_(key);
        if (dir === constants_1.Direction.LEFT) {
            return this.adapter_.focusChipTrailingActionAtIndex(index);
        }
        if (dir === constants_1.Direction.RIGHT) {
            return this.adapter_.focusChipPrimaryActionAtIndex(index);
        }
    };
    MDCChipSetFoundation.prototype.getDirection_ = function (key) {
        var isRTL = this.adapter_.isRTL();
        var isLeftKey = key === constants_1.strings.ARROW_LEFT_KEY || key === constants_1.strings.IE_ARROW_LEFT_KEY;
        var isRightKey = key === constants_1.strings.ARROW_RIGHT_KEY || key === constants_1.strings.IE_ARROW_RIGHT_KEY;
        if (!isRTL && isLeftKey || isRTL && isRightKey) {
            return constants_1.Direction.LEFT;
        }
        return constants_1.Direction.RIGHT;
    };
    /**
     * Deselects the chip with the given id and optionally notifies clients.
     */
    MDCChipSetFoundation.prototype.deselect_ = function (chipId, shouldNotifyClients) {
        if (shouldNotifyClients === void 0) {
            shouldNotifyClients = false;
        }
        var index = this.selectedChipIds_.indexOf(chipId);
        if (index >= 0) {
            this.selectedChipIds_.splice(index, 1);
            var chipIndex = this.adapter_.getIndexOfChipById(chipId);
            this.adapter_.selectChipAtIndex(chipIndex, /** isSelected */false, shouldNotifyClients);
        }
    };
    /**
     * Deselects the chip with the given id and notifies clients.
     */
    MDCChipSetFoundation.prototype.deselectAndNotifyClients_ = function (chipId) {
        this.deselect_(chipId, true);
    };
    /**
     * Toggles selection of the chip with the given id.
     */
    MDCChipSetFoundation.prototype.toggleSelect_ = function (chipId) {
        if (this.selectedChipIds_.indexOf(chipId) >= 0) {
            this.deselectAndNotifyClients_(chipId);
        } else {
            this.selectAndNotifyClients_(chipId);
        }
    };
    MDCChipSetFoundation.prototype.removeFocusFromChipsExcept_ = function (index) {
        var chipCount = this.adapter_.getChipListCount();
        for (var i = 0; i < chipCount; i++) {
            if (i !== index) {
                this.adapter_.removeFocusFromChipAtIndex(i);
            }
        }
    };
    MDCChipSetFoundation.prototype.selectAndNotifyClients_ = function (chipId) {
        this.select_(chipId, true);
    };
    MDCChipSetFoundation.prototype.select_ = function (chipId, shouldNotifyClients) {
        if (this.selectedChipIds_.indexOf(chipId) >= 0) {
            return;
        }
        if (this.adapter_.hasClass(constants_2.cssClasses.CHOICE) && this.selectedChipIds_.length > 0) {
            var previouslySelectedChip = this.selectedChipIds_[0];
            var previouslySelectedIndex = this.adapter_.getIndexOfChipById(previouslySelectedChip);
            this.selectedChipIds_ = [];
            this.adapter_.selectChipAtIndex(previouslySelectedIndex, /** isSelected */false, shouldNotifyClients);
        }
        this.selectedChipIds_.push(chipId);
        var index = this.adapter_.getIndexOfChipById(chipId);
        this.adapter_.selectChipAtIndex(index, /** isSelected */true, shouldNotifyClients);
    };
    return MDCChipSetFoundation;
}(foundation_1.MDCFoundation);
exports.MDCChipSetFoundation = MDCChipSetFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCChipSetFoundation;

/***/ }),

/***/ "./packages/mdc-chips/chip-set/index.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-chips/chip-set/index.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-chips/chip-set/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-chips/chip-set/foundation.ts"));
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-chips/chip-set/constants.ts");
exports.chipSetCssClasses = constants_1.cssClasses;
exports.chipSetStrings = constants_1.strings;

/***/ }),

/***/ "./packages/mdc-chips/chip/component.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-chips/chip/component.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var component_2 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! @material/ripple/foundation */ "./packages/mdc-ripple/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-chips/chip/constants.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-chips/chip/foundation.ts");
var INTERACTION_EVENTS = ['click', 'keydown'];
var MDCChip = /** @class */function (_super) {
    __extends(MDCChip, _super);
    function MDCChip() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCChip.prototype, "selected", {
        /**
         * @return Whether the chip is selected.
         */
        get: function get() {
            return this.foundation_.isSelected();
        },
        /**
         * Sets selected state on the chip.
         */
        set: function set(selected) {
            this.foundation_.setSelected(selected);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCChip.prototype, "shouldRemoveOnTrailingIconClick", {
        /**
         * @return Whether a trailing icon click should trigger exit/removal of the chip.
         */
        get: function get() {
            return this.foundation_.getShouldRemoveOnTrailingIconClick();
        },
        /**
         * Sets whether a trailing icon click should trigger exit/removal of the chip.
         */
        set: function set(shouldRemove) {
            this.foundation_.setShouldRemoveOnTrailingIconClick(shouldRemove);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCChip.prototype, "ripple", {
        get: function get() {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCChip.prototype, "id", {
        get: function get() {
            return this.root_.id;
        },
        enumerable: true,
        configurable: true
    });
    MDCChip.attachTo = function (root) {
        return new MDCChip(root);
    };
    MDCChip.prototype.initialize = function (rippleFactory) {
        var _this = this;
        if (rippleFactory === void 0) {
            rippleFactory = function rippleFactory(el, foundation) {
                return new component_2.MDCRipple(el, foundation);
            };
        }
        this.leadingIcon_ = this.root_.querySelector(constants_1.strings.LEADING_ICON_SELECTOR);
        this.trailingIcon_ = this.root_.querySelector(constants_1.strings.TRAILING_ICON_SELECTOR);
        this.checkmark_ = this.root_.querySelector(constants_1.strings.CHECKMARK_SELECTOR);
        this.primaryAction_ = this.root_.querySelector(constants_1.strings.PRIMARY_ACTION_SELECTOR);
        this.trailingAction_ = this.root_.querySelector(constants_1.strings.TRAILING_ACTION_SELECTOR);
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var rippleAdapter = __assign(__assign({}, component_2.MDCRipple.createAdapter(this)), { computeBoundingRect: function computeBoundingRect() {
                return _this.foundation_.getDimensions();
            } });
        this.ripple_ = rippleFactory(this.root_, new foundation_1.MDCRippleFoundation(rippleAdapter));
    };
    MDCChip.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleInteraction_ = function (evt) {
            return _this.foundation_.handleInteraction(evt);
        };
        this.handleTransitionEnd_ = function (evt) {
            return _this.foundation_.handleTransitionEnd(evt);
        };
        this.handleTrailingIconInteraction_ = function (evt) {
            return _this.foundation_.handleTrailingIconInteraction(evt);
        };
        this.handleKeydown_ = function (evt) {
            return _this.foundation_.handleKeydown(evt);
        };
        this.handleFocusIn_ = function (evt) {
            _this.foundation_.handleFocusIn(evt);
        };
        this.handleFocusOut_ = function (evt) {
            _this.foundation_.handleFocusOut(evt);
        };
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.listen(evtType, _this.handleInteraction_);
        });
        this.listen('transitionend', this.handleTransitionEnd_);
        this.listen('keydown', this.handleKeydown_);
        this.listen('focusin', this.handleFocusIn_);
        this.listen('focusout', this.handleFocusOut_);
        if (this.trailingIcon_) {
            INTERACTION_EVENTS.forEach(function (evtType) {
                _this.trailingIcon_.addEventListener(evtType, _this.handleTrailingIconInteraction_);
            });
        }
    };
    MDCChip.prototype.destroy = function () {
        var _this = this;
        this.ripple_.destroy();
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.unlisten(evtType, _this.handleInteraction_);
        });
        this.unlisten('transitionend', this.handleTransitionEnd_);
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten('focusin', this.handleFocusIn_);
        this.unlisten('focusout', this.handleFocusOut_);
        if (this.trailingIcon_) {
            INTERACTION_EVENTS.forEach(function (evtType) {
                _this.trailingIcon_.removeEventListener(evtType, _this.handleTrailingIconInteraction_);
            });
        }
        _super.prototype.destroy.call(this);
    };
    /**
     * Begins the exit animation which leads to removal of the chip.
     */
    MDCChip.prototype.beginExit = function () {
        this.foundation_.beginExit();
    };
    MDCChip.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            addClassToLeadingIcon: function addClassToLeadingIcon(className) {
                if (_this.leadingIcon_) {
                    _this.leadingIcon_.classList.add(className);
                }
            },
            eventTargetHasClass: function eventTargetHasClass(target, className) {
                return target ? target.classList.contains(className) : false;
            },
            focusPrimaryAction: function focusPrimaryAction() {
                if (_this.primaryAction_) {
                    _this.primaryAction_.focus();
                }
            },
            focusTrailingAction: function focusTrailingAction() {
                if (_this.trailingAction_) {
                    _this.trailingAction_.focus();
                }
            },
            getAttribute: function getAttribute(attr) {
                return _this.root_.getAttribute(attr);
            },
            getCheckmarkBoundingClientRect: function getCheckmarkBoundingClientRect() {
                return _this.checkmark_ ? _this.checkmark_.getBoundingClientRect() : null;
            },
            getComputedStyleValue: function getComputedStyleValue(propertyName) {
                return window.getComputedStyle(_this.root_).getPropertyValue(propertyName);
            },
            getRootBoundingClientRect: function getRootBoundingClientRect() {
                return _this.root_.getBoundingClientRect();
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            hasLeadingIcon: function hasLeadingIcon() {
                return !!_this.leadingIcon_;
            },
            hasTrailingAction: function hasTrailingAction() {
                return !!_this.trailingAction_;
            },
            isRTL: function isRTL() {
                return window.getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
            },
            notifyInteraction: function notifyInteraction() {
                return _this.emit(constants_1.strings.INTERACTION_EVENT, { chipId: _this.id }, true /* shouldBubble */);
            },
            notifyNavigation: function notifyNavigation(key, source) {
                return _this.emit(constants_1.strings.NAVIGATION_EVENT, { chipId: _this.id, key: key, source: source }, true /* shouldBubble */);
            },
            notifyRemoval: function notifyRemoval(removedAnnouncement) {
                _this.emit(constants_1.strings.REMOVAL_EVENT, { chipId: _this.id, removedAnnouncement: removedAnnouncement }, true /* shouldBubble */);
            },
            notifySelection: function notifySelection(selected, shouldIgnore) {
                return _this.emit(constants_1.strings.SELECTION_EVENT, { chipId: _this.id, selected: selected, shouldIgnore: shouldIgnore }, true /* shouldBubble */);
            },
            notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
                return _this.emit(constants_1.strings.TRAILING_ICON_INTERACTION_EVENT, { chipId: _this.id }, true /* shouldBubble */);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
                if (_this.leadingIcon_) {
                    _this.leadingIcon_.classList.remove(className);
                }
            },
            setPrimaryActionAttr: function setPrimaryActionAttr(attr, value) {
                if (_this.primaryAction_) {
                    _this.primaryAction_.setAttribute(attr, value);
                }
            },
            setStyleProperty: function setStyleProperty(propertyName, value) {
                return _this.root_.style.setProperty(propertyName, value);
            },
            setTrailingActionAttr: function setTrailingActionAttr(attr, value) {
                if (_this.trailingAction_) {
                    _this.trailingAction_.setAttribute(attr, value);
                }
            }
        };
        return new foundation_2.MDCChipFoundation(adapter);
    };
    MDCChip.prototype.setSelectedFromChipSet = function (selected, shouldNotifyClients) {
        this.foundation_.setSelectedFromChipSet(selected, shouldNotifyClients);
    };
    MDCChip.prototype.focusPrimaryAction = function () {
        this.foundation_.focusPrimaryAction();
    };
    MDCChip.prototype.focusTrailingAction = function () {
        this.foundation_.focusTrailingAction();
    };
    MDCChip.prototype.removeFocus = function () {
        this.foundation_.removeFocus();
    };
    MDCChip.prototype.remove = function () {
        var parent = this.root_.parentNode;
        if (parent !== null) {
            parent.removeChild(this.root_);
        }
    };
    return MDCChip;
}(component_1.MDCComponent);
exports.MDCChip = MDCChip;

/***/ }),

/***/ "./packages/mdc-chips/chip/constants.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-chips/chip/constants.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var Direction;
(function (Direction) {
    Direction[Direction["RIGHT"] = 0] = "RIGHT";
    Direction[Direction["LEFT"] = 1] = "LEFT";
})(Direction = exports.Direction || (exports.Direction = {}));
var EventSource;
(function (EventSource) {
    EventSource[EventSource["PRIMARY"] = 0] = "PRIMARY";
    EventSource[EventSource["TRAILING"] = 1] = "TRAILING";
    EventSource[EventSource["NONE"] = 2] = "NONE";
})(EventSource = exports.EventSource || (exports.EventSource = {}));
exports.strings = {
    ADDED_ANNOUNCEMENT_ATTRIBUTE: 'data-mdc-chip-added-announcement',
    ARIA_CHECKED: 'aria-checked',
    ARROW_DOWN_KEY: 'ArrowDown',
    ARROW_LEFT_KEY: 'ArrowLeft',
    ARROW_RIGHT_KEY: 'ArrowRight',
    ARROW_UP_KEY: 'ArrowUp',
    BACKSPACE_KEY: 'Backspace',
    CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
    DELETE_KEY: 'Delete',
    END_KEY: 'End',
    ENTER_KEY: 'Enter',
    ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
    HOME_KEY: 'Home',
    IE_ARROW_DOWN_KEY: 'Down',
    IE_ARROW_LEFT_KEY: 'Left',
    IE_ARROW_RIGHT_KEY: 'Right',
    IE_ARROW_UP_KEY: 'Up',
    IE_DELETE_KEY: 'Del',
    INTERACTION_EVENT: 'MDCChip:interaction',
    LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
    NAVIGATION_EVENT: 'MDCChip:navigation',
    PRIMARY_ACTION_SELECTOR: '.mdc-chip__primary-action',
    REMOVED_ANNOUNCEMENT_ATTRIBUTE: 'data-mdc-chip-removed-announcement',
    REMOVAL_EVENT: 'MDCChip:removal',
    SELECTION_EVENT: 'MDCChip:selection',
    SPACEBAR_KEY: ' ',
    TAB_INDEX: 'tabindex',
    TRAILING_ACTION_SELECTOR: '.mdc-chip__trailing-action',
    TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
    TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing'
};
exports.cssClasses = {
    CHECKMARK: 'mdc-chip__checkmark',
    CHIP_EXIT: 'mdc-chip--exit',
    DELETABLE: 'mdc-chip--deletable',
    HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
    LEADING_ICON: 'mdc-chip__icon--leading',
    PRIMARY_ACTION: 'mdc-chip__primary-action',
    PRIMARY_ACTION_FOCUSED: 'mdc-chip--primary-action-focused',
    SELECTED: 'mdc-chip--selected',
    TEXT: 'mdc-chip__text',
    TRAILING_ACTION: 'mdc-chip__trailing-action',
    TRAILING_ICON: 'mdc-chip__icon--trailing'
};
exports.navigationKeys = new Set();
// IE11 has no support for new Set with iterable so we need to initialize this by hand
exports.navigationKeys.add(exports.strings.ARROW_LEFT_KEY);
exports.navigationKeys.add(exports.strings.ARROW_RIGHT_KEY);
exports.navigationKeys.add(exports.strings.ARROW_DOWN_KEY);
exports.navigationKeys.add(exports.strings.ARROW_UP_KEY);
exports.navigationKeys.add(exports.strings.END_KEY);
exports.navigationKeys.add(exports.strings.HOME_KEY);
exports.navigationKeys.add(exports.strings.IE_ARROW_LEFT_KEY);
exports.navigationKeys.add(exports.strings.IE_ARROW_RIGHT_KEY);
exports.navigationKeys.add(exports.strings.IE_ARROW_DOWN_KEY);
exports.navigationKeys.add(exports.strings.IE_ARROW_UP_KEY);
exports.jumpChipKeys = new Set();
// IE11 has no support for new Set with iterable so we need to initialize this by hand
exports.jumpChipKeys.add(exports.strings.ARROW_UP_KEY);
exports.jumpChipKeys.add(exports.strings.ARROW_DOWN_KEY);
exports.jumpChipKeys.add(exports.strings.HOME_KEY);
exports.jumpChipKeys.add(exports.strings.END_KEY);
exports.jumpChipKeys.add(exports.strings.IE_ARROW_UP_KEY);
exports.jumpChipKeys.add(exports.strings.IE_ARROW_DOWN_KEY);

/***/ }),

/***/ "./packages/mdc-chips/chip/foundation.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-chips/chip/foundation.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-chips/chip/constants.ts");
var emptyClientRect = {
    bottom: 0,
    height: 0,
    left: 0,
    right: 0,
    top: 0,
    width: 0
};
var MDCChipFoundation = /** @class */function (_super) {
    __extends(MDCChipFoundation, _super);
    function MDCChipFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCChipFoundation.defaultAdapter), adapter)) || this;
        /** Whether a trailing icon click should immediately trigger exit/removal of the chip. */
        _this.shouldRemoveOnTrailingIconClick_ = true;
        return _this;
    }
    Object.defineProperty(MDCChipFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCChipFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCChipFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                addClassToLeadingIcon: function addClassToLeadingIcon() {
                    return undefined;
                },
                eventTargetHasClass: function eventTargetHasClass() {
                    return false;
                },
                focusPrimaryAction: function focusPrimaryAction() {
                    return undefined;
                },
                focusTrailingAction: function focusTrailingAction() {
                    return undefined;
                },
                getAttribute: function getAttribute() {
                    return null;
                },
                getCheckmarkBoundingClientRect: function getCheckmarkBoundingClientRect() {
                    return emptyClientRect;
                },
                getComputedStyleValue: function getComputedStyleValue() {
                    return '';
                },
                getRootBoundingClientRect: function getRootBoundingClientRect() {
                    return emptyClientRect;
                },
                hasClass: function hasClass() {
                    return false;
                },
                hasLeadingIcon: function hasLeadingIcon() {
                    return false;
                },
                hasTrailingAction: function hasTrailingAction() {
                    return false;
                },
                isRTL: function isRTL() {
                    return false;
                },
                notifyInteraction: function notifyInteraction() {
                    return undefined;
                },
                notifyNavigation: function notifyNavigation() {
                    return undefined;
                },
                notifyRemoval: function notifyRemoval() {
                    return undefined;
                },
                notifySelection: function notifySelection() {
                    return undefined;
                },
                notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                removeClassFromLeadingIcon: function removeClassFromLeadingIcon() {
                    return undefined;
                },
                setPrimaryActionAttr: function setPrimaryActionAttr() {
                    return undefined;
                },
                setStyleProperty: function setStyleProperty() {
                    return undefined;
                },
                setTrailingActionAttr: function setTrailingActionAttr() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCChipFoundation.prototype.isSelected = function () {
        return this.adapter_.hasClass(constants_1.cssClasses.SELECTED);
    };
    MDCChipFoundation.prototype.setSelected = function (selected) {
        this.setSelected_(selected);
        this.notifySelection_(selected);
    };
    MDCChipFoundation.prototype.setSelectedFromChipSet = function (selected, shouldNotifyClients) {
        this.setSelected_(selected);
        if (shouldNotifyClients) {
            this.notifyIgnoredSelection_(selected);
        }
    };
    MDCChipFoundation.prototype.getShouldRemoveOnTrailingIconClick = function () {
        return this.shouldRemoveOnTrailingIconClick_;
    };
    MDCChipFoundation.prototype.setShouldRemoveOnTrailingIconClick = function (shouldRemove) {
        this.shouldRemoveOnTrailingIconClick_ = shouldRemove;
    };
    MDCChipFoundation.prototype.getDimensions = function () {
        var _this = this;
        var getRootRect = function getRootRect() {
            return _this.adapter_.getRootBoundingClientRect();
        };
        var getCheckmarkRect = function getCheckmarkRect() {
            return _this.adapter_.getCheckmarkBoundingClientRect();
        };
        // When a chip has a checkmark and not a leading icon, the bounding rect changes in size depending on the current
        // size of the checkmark.
        if (!this.adapter_.hasLeadingIcon()) {
            var checkmarkRect = getCheckmarkRect();
            if (checkmarkRect) {
                var rootRect = getRootRect();
                // Checkmark is a square, meaning the client rect's width and height are identical once the animation completes.
                // However, the checkbox is initially hidden by setting the width to 0.
                // To account for an initial width of 0, we use the checkbox's height instead (which equals the end-state width)
                // when adding it to the root client rect's width.
                return {
                    bottom: rootRect.bottom,
                    height: rootRect.height,
                    left: rootRect.left,
                    right: rootRect.right,
                    top: rootRect.top,
                    width: rootRect.width + checkmarkRect.height
                };
            }
        }
        return getRootRect();
    };
    /**
     * Begins the exit animation which leads to removal of the chip.
     */
    MDCChipFoundation.prototype.beginExit = function () {
        this.adapter_.addClass(constants_1.cssClasses.CHIP_EXIT);
    };
    /**
     * Handles an interaction event on the root element.
     */
    MDCChipFoundation.prototype.handleInteraction = function (evt) {
        if (this.shouldHandleInteraction_(evt)) {
            this.adapter_.notifyInteraction();
            this.focusPrimaryAction_();
        }
    };
    /**
     * Handles a transition end event on the root element.
     */
    MDCChipFoundation.prototype.handleTransitionEnd = function (evt) {
        var _this = this;
        // Handle transition end event on the chip when it is about to be removed.
        var shouldHandle = this.adapter_.eventTargetHasClass(evt.target, constants_1.cssClasses.CHIP_EXIT);
        var widthIsAnimating = evt.propertyName === 'width';
        var opacityIsAnimating = evt.propertyName === 'opacity';
        if (shouldHandle && opacityIsAnimating) {
            // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
            var chipWidth_1 = this.adapter_.getComputedStyleValue('width');
            // On the next frame (once we get the computed width), explicitly set the chip's width
            // to its current pixel width, so we aren't transitioning out of 'auto'.
            requestAnimationFrame(function () {
                _this.adapter_.setStyleProperty('width', chipWidth_1);
                // To mitigate jitter, start transitioning padding and margin before width.
                _this.adapter_.setStyleProperty('padding', '0');
                _this.adapter_.setStyleProperty('margin', '0');
                // On the next frame (once width is explicitly set), transition width to 0.
                requestAnimationFrame(function () {
                    _this.adapter_.setStyleProperty('width', '0');
                });
            });
            return;
        }
        if (shouldHandle && widthIsAnimating) {
            this.removeFocus_();
            var removedAnnouncement = this.adapter_.getAttribute(constants_1.strings.REMOVED_ANNOUNCEMENT_ATTRIBUTE);
            this.adapter_.notifyRemoval(removedAnnouncement);
        }
        // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.
        if (!opacityIsAnimating) {
            return;
        }
        var shouldHideLeadingIcon = this.adapter_.eventTargetHasClass(evt.target, constants_1.cssClasses.LEADING_ICON) && this.adapter_.hasClass(constants_1.cssClasses.SELECTED);
        var shouldShowLeadingIcon = this.adapter_.eventTargetHasClass(evt.target, constants_1.cssClasses.CHECKMARK) && !this.adapter_.hasClass(constants_1.cssClasses.SELECTED);
        if (shouldHideLeadingIcon) {
            return this.adapter_.addClassToLeadingIcon(constants_1.cssClasses.HIDDEN_LEADING_ICON);
        }
        if (shouldShowLeadingIcon) {
            return this.adapter_.removeClassFromLeadingIcon(constants_1.cssClasses.HIDDEN_LEADING_ICON);
        }
    };
    MDCChipFoundation.prototype.handleFocusIn = function (evt) {
        // Early exit if the event doesn't come from the primary action
        if (!this.eventFromPrimaryAction_(evt)) {
            return;
        }
        this.adapter_.addClass(constants_1.cssClasses.PRIMARY_ACTION_FOCUSED);
    };
    MDCChipFoundation.prototype.handleFocusOut = function (evt) {
        // Early exit if the event doesn't come from the primary action
        if (!this.eventFromPrimaryAction_(evt)) {
            return;
        }
        this.adapter_.removeClass(constants_1.cssClasses.PRIMARY_ACTION_FOCUSED);
    };
    /**
     * Handles an interaction event on the trailing icon element. This is used to
     * prevent the ripple from activating on interaction with the trailing icon.
     */
    MDCChipFoundation.prototype.handleTrailingIconInteraction = function (evt) {
        if (this.shouldHandleInteraction_(evt)) {
            this.adapter_.notifyTrailingIconInteraction();
            this.removeChip_(evt);
        }
    };
    /**
     * Handles a keydown event from the root element.
     */
    MDCChipFoundation.prototype.handleKeydown = function (evt) {
        if (this.shouldRemoveChip_(evt)) {
            return this.removeChip_(evt);
        }
        var key = evt.key;
        // Early exit if the key is not usable
        if (!constants_1.navigationKeys.has(key)) {
            return;
        }
        // Prevent default behavior for movement keys which could include scrolling
        evt.preventDefault();
        this.focusNextAction_(evt);
    };
    MDCChipFoundation.prototype.removeFocus = function () {
        this.adapter_.setPrimaryActionAttr(constants_1.strings.TAB_INDEX, '-1');
        this.adapter_.setTrailingActionAttr(constants_1.strings.TAB_INDEX, '-1');
    };
    MDCChipFoundation.prototype.focusPrimaryAction = function () {
        this.focusPrimaryAction_();
    };
    MDCChipFoundation.prototype.focusTrailingAction = function () {
        if (!this.adapter_.hasTrailingAction()) {
            return this.focusPrimaryAction_();
        }
        this.focusTrailingAction_();
    };
    MDCChipFoundation.prototype.focusNextAction_ = function (evt) {
        var key = evt.key;
        var hasTrailingAction = this.adapter_.hasTrailingAction();
        var dir = this.getDirection_(key);
        var source = this.getEvtSource_(evt);
        // Early exit if the key should jump keys or the chip only has one action (i.e. no trailing action)
        if (constants_1.jumpChipKeys.has(key) || !hasTrailingAction) {
            this.adapter_.notifyNavigation(key, source);
            return;
        }
        if (source === constants_1.EventSource.PRIMARY && dir === constants_1.Direction.RIGHT) {
            return this.focusTrailingAction_();
        }
        if (source === constants_1.EventSource.TRAILING && dir === constants_1.Direction.LEFT) {
            return this.focusPrimaryAction_();
        }
        this.adapter_.notifyNavigation(key, constants_1.EventSource.NONE);
    };
    MDCChipFoundation.prototype.getEvtSource_ = function (evt) {
        if (this.adapter_.eventTargetHasClass(evt.target, constants_1.cssClasses.PRIMARY_ACTION)) {
            return constants_1.EventSource.PRIMARY;
        }
        if (this.adapter_.eventTargetHasClass(evt.target, constants_1.cssClasses.TRAILING_ACTION)) {
            return constants_1.EventSource.TRAILING;
        }
        return constants_1.EventSource.NONE;
    };
    MDCChipFoundation.prototype.getDirection_ = function (key) {
        var isRTL = this.adapter_.isRTL();
        var isLeftKey = key === constants_1.strings.ARROW_LEFT_KEY || key === constants_1.strings.IE_ARROW_LEFT_KEY;
        var isRightKey = key === constants_1.strings.ARROW_RIGHT_KEY || key === constants_1.strings.IE_ARROW_RIGHT_KEY;
        if (!isRTL && isLeftKey || isRTL && isRightKey) {
            return constants_1.Direction.LEFT;
        }
        return constants_1.Direction.RIGHT;
    };
    MDCChipFoundation.prototype.focusPrimaryAction_ = function () {
        this.adapter_.setPrimaryActionAttr(constants_1.strings.TAB_INDEX, '0');
        this.adapter_.focusPrimaryAction();
        this.adapter_.setTrailingActionAttr(constants_1.strings.TAB_INDEX, '-1');
    };
    MDCChipFoundation.prototype.focusTrailingAction_ = function () {
        this.adapter_.setTrailingActionAttr(constants_1.strings.TAB_INDEX, '0');
        this.adapter_.focusTrailingAction();
        this.adapter_.setPrimaryActionAttr(constants_1.strings.TAB_INDEX, '-1');
    };
    MDCChipFoundation.prototype.removeFocus_ = function () {
        this.adapter_.setTrailingActionAttr(constants_1.strings.TAB_INDEX, '-1');
        this.adapter_.setPrimaryActionAttr(constants_1.strings.TAB_INDEX, '-1');
    };
    MDCChipFoundation.prototype.removeChip_ = function (evt) {
        evt.stopPropagation();
        // Prevent default behavior for backspace on Firefox which causes a page
        // navigation.
        evt.preventDefault();
        if (this.shouldRemoveOnTrailingIconClick_) {
            this.beginExit();
        }
    };
    MDCChipFoundation.prototype.shouldHandleInteraction_ = function (evt) {
        if (evt.type === 'click') {
            return true;
        }
        var keyEvt = evt;
        return keyEvt.key === constants_1.strings.ENTER_KEY || keyEvt.key === constants_1.strings.SPACEBAR_KEY;
    };
    MDCChipFoundation.prototype.shouldRemoveChip_ = function (evt) {
        var isDeletable = this.adapter_.hasClass(constants_1.cssClasses.DELETABLE);
        return isDeletable && (evt.key === constants_1.strings.BACKSPACE_KEY || evt.key === constants_1.strings.DELETE_KEY || evt.key === constants_1.strings.IE_DELETE_KEY);
    };
    MDCChipFoundation.prototype.setSelected_ = function (selected) {
        if (selected) {
            this.adapter_.addClass(constants_1.cssClasses.SELECTED);
            this.adapter_.setPrimaryActionAttr(constants_1.strings.ARIA_CHECKED, 'true');
        } else {
            this.adapter_.removeClass(constants_1.cssClasses.SELECTED);
            this.adapter_.setPrimaryActionAttr(constants_1.strings.ARIA_CHECKED, 'false');
        }
    };
    MDCChipFoundation.prototype.notifySelection_ = function (selected) {
        this.adapter_.notifySelection(selected, false);
    };
    MDCChipFoundation.prototype.notifyIgnoredSelection_ = function (selected) {
        this.adapter_.notifySelection(selected, true);
    };
    MDCChipFoundation.prototype.eventFromPrimaryAction_ = function (evt) {
        return this.adapter_.eventTargetHasClass(evt.target, constants_1.cssClasses.PRIMARY_ACTION);
    };
    return MDCChipFoundation;
}(foundation_1.MDCFoundation);
exports.MDCChipFoundation = MDCChipFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCChipFoundation;

/***/ }),

/***/ "./packages/mdc-chips/chip/index.ts":
/*!******************************************!*\
  !*** ./packages/mdc-chips/chip/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-chips/chip/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-chips/chip/foundation.ts"));
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-chips/chip/constants.ts");
exports.chipCssClasses = constants_1.cssClasses;
exports.chipStrings = constants_1.strings;

/***/ }),

/***/ "./packages/mdc-chips/index.ts":
/*!*************************************!*\
  !*** ./packages/mdc-chips/index.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./trailingaction/index */ "./packages/mdc-chips/trailingaction/index.ts"));
__export(__webpack_require__(/*! ./chip/index */ "./packages/mdc-chips/chip/index.ts"));
__export(__webpack_require__(/*! ./chip-set/index */ "./packages/mdc-chips/chip-set/index.ts"));

/***/ }),

/***/ "./packages/mdc-chips/trailingaction/component.ts":
/*!********************************************************!*\
  !*** ./packages/mdc-chips/trailingaction/component.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var component_2 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! @material/ripple/foundation */ "./packages/mdc-ripple/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-chips/trailingaction/constants.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-chips/trailingaction/foundation.ts");
var MDCChipTrailingAction = /** @class */function (_super) {
    __extends(MDCChipTrailingAction, _super);
    function MDCChipTrailingAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCChipTrailingAction.prototype, "ripple", {
        get: function get() {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    MDCChipTrailingAction.attachTo = function (root) {
        return new MDCChipTrailingAction(root);
    };
    MDCChipTrailingAction.prototype.initialize = function (rippleFactory) {
        if (rippleFactory === void 0) {
            rippleFactory = function rippleFactory(el, foundation) {
                return new component_2.MDCRipple(el, foundation);
            };
        }
        // DO NOT INLINE this variable. For backward compatibility, foundations take
        // a Partial<MDCFooAdapter>. To ensure we don't accidentally omit any
        // methods, we need a separate, strongly typed adapter variable.
        var rippleAdapter = component_2.MDCRipple.createAdapter(this);
        this.ripple_ = rippleFactory(this.root_, new foundation_1.MDCRippleFoundation(rippleAdapter));
    };
    MDCChipTrailingAction.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleClick_ = function (evt) {
            _this.foundation_.handleClick(evt);
        };
        this.handleKeydown_ = function (evt) {
            _this.foundation_.handleKeydown(evt);
        };
        this.listen('click', this.handleClick_);
        this.listen('keydown', this.handleKeydown_);
    };
    MDCChipTrailingAction.prototype.destroy = function () {
        this.ripple_.destroy();
        this.unlisten('click', this.handleClick_);
        this.unlisten('keydown', this.handleKeydown_);
        _super.prototype.destroy.call(this);
    };
    MDCChipTrailingAction.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take
        // a Partial<MDCFooAdapter>. To ensure we don't accidentally omit any
        // methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            focus: function focus() {
                _this.root_.focus();
            },
            getAttribute: function getAttribute(attr) {
                return _this.root_.getAttribute(attr);
            },
            notifyInteraction: function notifyInteraction(trigger) {
                return _this.emit(constants_1.strings.INTERACTION_EVENT, { trigger: trigger }, true /* shouldBubble */);
            },
            notifyNavigation: function notifyNavigation(key) {
                _this.emit(constants_1.strings.NAVIGATION_EVENT, { key: key }, true /* shouldBubble */);
            },
            setAttribute: function setAttribute(attr, value) {
                _this.root_.setAttribute(attr, value);
            }
        };
        return new foundation_2.MDCChipTrailingActionFoundation(adapter);
    };
    MDCChipTrailingAction.prototype.isNavigable = function () {
        return this.foundation_.isNavigable();
    };
    MDCChipTrailingAction.prototype.focus = function () {
        this.foundation_.focus();
    };
    MDCChipTrailingAction.prototype.removeFocus = function () {
        this.foundation_.removeFocus();
    };
    return MDCChipTrailingAction;
}(component_1.MDCComponent);
exports.MDCChipTrailingAction = MDCChipTrailingAction;

/***/ }),

/***/ "./packages/mdc-chips/trailingaction/constants.ts":
/*!********************************************************!*\
  !*** ./packages/mdc-chips/trailingaction/constants.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var InteractionTrigger;
(function (InteractionTrigger) {
    InteractionTrigger[InteractionTrigger["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    InteractionTrigger[InteractionTrigger["CLICK"] = 1] = "CLICK";
    InteractionTrigger[InteractionTrigger["BACKSPACE_KEY"] = 2] = "BACKSPACE_KEY";
    InteractionTrigger[InteractionTrigger["DELETE_KEY"] = 3] = "DELETE_KEY";
    InteractionTrigger[InteractionTrigger["SPACEBAR_KEY"] = 4] = "SPACEBAR_KEY";
    InteractionTrigger[InteractionTrigger["ENTER_KEY"] = 5] = "ENTER_KEY";
})(InteractionTrigger = exports.InteractionTrigger || (exports.InteractionTrigger = {}));
exports.strings = {
    ARIA_HIDDEN: 'aria-hidden',
    INTERACTION_EVENT: 'MDCChipTrailingAction:interaction',
    NAVIGATION_EVENT: 'MDCChipTrailingAction:navigation',
    TAB_INDEX: 'tabindex'
};

/***/ }),

/***/ "./packages/mdc-chips/trailingaction/foundation.ts":
/*!*********************************************************!*\
  !*** ./packages/mdc-chips/trailingaction/foundation.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var keyboard_1 = __webpack_require__(/*! @material/dom/keyboard */ "./packages/mdc-dom/keyboard.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-chips/trailingaction/constants.ts");
var MDCChipTrailingActionFoundation = /** @class */function (_super) {
    __extends(MDCChipTrailingActionFoundation, _super);
    function MDCChipTrailingActionFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCChipTrailingActionFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCChipTrailingActionFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCChipTrailingActionFoundation, "defaultAdapter", {
        get: function get() {
            return {
                focus: function focus() {
                    return undefined;
                },
                getAttribute: function getAttribute() {
                    return null;
                },
                setAttribute: function setAttribute() {
                    return undefined;
                },
                notifyInteraction: function notifyInteraction() {
                    return undefined;
                },
                notifyNavigation: function notifyNavigation() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCChipTrailingActionFoundation.prototype.handleClick = function (evt) {
        evt.stopPropagation();
        this.adapter_.notifyInteraction(constants_1.InteractionTrigger.CLICK);
    };
    MDCChipTrailingActionFoundation.prototype.handleKeydown = function (evt) {
        evt.stopPropagation();
        var key = keyboard_1.normalizeKey(evt);
        if (this.shouldNotifyInteractionFromKey_(key)) {
            var trigger = this.getTriggerFromKey_(key);
            this.adapter_.notifyInteraction(trigger);
            return;
        }
        if (keyboard_1.isNavigationEvent(evt)) {
            this.adapter_.notifyNavigation(key);
            return;
        }
    };
    MDCChipTrailingActionFoundation.prototype.removeFocus = function () {
        this.adapter_.setAttribute(constants_1.strings.TAB_INDEX, '-1');
    };
    MDCChipTrailingActionFoundation.prototype.focus = function () {
        this.adapter_.setAttribute(constants_1.strings.TAB_INDEX, '0');
        this.adapter_.focus();
    };
    MDCChipTrailingActionFoundation.prototype.isNavigable = function () {
        return this.adapter_.getAttribute(constants_1.strings.ARIA_HIDDEN) !== 'true';
    };
    MDCChipTrailingActionFoundation.prototype.shouldNotifyInteractionFromKey_ = function (key) {
        var isFromActionKey = key === keyboard_1.KEY.ENTER || key === keyboard_1.KEY.SPACEBAR;
        var isFromDeleteKey = key === keyboard_1.KEY.BACKSPACE || key === keyboard_1.KEY.DELETE;
        return isFromActionKey || isFromDeleteKey;
    };
    MDCChipTrailingActionFoundation.prototype.getTriggerFromKey_ = function (key) {
        if (key === keyboard_1.KEY.SPACEBAR) {
            return constants_1.InteractionTrigger.SPACEBAR_KEY;
        }
        if (key === keyboard_1.KEY.ENTER) {
            return constants_1.InteractionTrigger.ENTER_KEY;
        }
        if (key === keyboard_1.KEY.DELETE) {
            return constants_1.InteractionTrigger.DELETE_KEY;
        }
        if (key === keyboard_1.KEY.BACKSPACE) {
            return constants_1.InteractionTrigger.BACKSPACE_KEY;
        }
        // Default case, should never be returned
        return constants_1.InteractionTrigger.UNSPECIFIED;
    };
    return MDCChipTrailingActionFoundation;
}(foundation_1.MDCFoundation);
exports.MDCChipTrailingActionFoundation = MDCChipTrailingActionFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCChipTrailingActionFoundation;

/***/ }),

/***/ "./packages/mdc-chips/trailingaction/index.ts":
/*!****************************************************!*\
  !*** ./packages/mdc-chips/trailingaction/index.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-chips/trailingaction/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-chips/trailingaction/foundation.ts"));
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-chips/trailingaction/constants.ts");
exports.trailingActionStrings = constants_1.strings;

/***/ }),

/***/ "./packages/mdc-circular-progress/component.ts":
/*!*****************************************************!*\
  !*** ./packages/mdc-circular-progress/component.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-circular-progress/foundation.ts");
var MDCCircularProgress = /** @class */function (_super) {
    __extends(MDCCircularProgress, _super);
    function MDCCircularProgress() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCCircularProgress.prototype.initialize = function () {
        this.determinateCircle_ = this.root_.querySelector(foundation_1.MDCCircularProgressFoundation.strings.DETERMINATE_CIRCLE_SELECTOR);
    };
    MDCCircularProgress.attachTo = function (root) {
        return new MDCCircularProgress(root);
    };
    Object.defineProperty(MDCCircularProgress.prototype, "determinate", {
        /**
         * Sets whether the progress indicator is in determinate mode.
         * @param isDeterminate Whether the indicator should be determinate.
         */
        set: function set(value) {
            this.foundation_.setDeterminate(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCircularProgress.prototype, "progress", {
        /**
         * Sets the current progress value. In indeterminate mode, this has no
         * visual effect but will be reflected if the indicator is switched to
         * determinate mode.
         * @param value The current progress value, which must be between 0 and 1.
         */
        set: function set(value) {
            this.foundation_.setProgress(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCircularProgress.prototype, "isClosed", {
        /**
         * Whether the progress indicator is hidden.
         */
        get: function get() {
            return this.foundation_.isClosed();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows the progress indicator.
     */
    MDCCircularProgress.prototype.open = function () {
        this.foundation_.open();
    };
    /**
     * Hides the progress indicator.
     */
    MDCCircularProgress.prototype.close = function () {
        this.foundation_.close();
    };
    MDCCircularProgress.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take
        // a Partial<MDCFooAdapter>. To ensure we don't accidentally omit any
        // methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            getDeterminateCircleAttribute: function getDeterminateCircleAttribute(attributeName) {
                return _this.determinateCircle_.getAttribute(attributeName);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            removeAttribute: function removeAttribute(attributeName) {
                return _this.root_.removeAttribute(attributeName);
            },
            setAttribute: function setAttribute(attributeName, value) {
                return _this.root_.setAttribute(attributeName, value);
            },
            setDeterminateCircleAttribute: function setDeterminateCircleAttribute(attributeName, value) {
                return _this.determinateCircle_.setAttribute(attributeName, value);
            }
        };
        return new foundation_1.MDCCircularProgressFoundation(adapter);
    };
    return MDCCircularProgress;
}(component_1.MDCComponent);
exports.MDCCircularProgress = MDCCircularProgress;

/***/ }),

/***/ "./packages/mdc-circular-progress/constants.ts":
/*!*****************************************************!*\
  !*** ./packages/mdc-circular-progress/constants.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * CSS class names used in component.
 */
exports.cssClasses = {
  INDETERMINATE_CLASS: 'mdc-circular-progress--indeterminate',
  CLOSED_CLASS: 'mdc-circular-progress--closed'
};
/**
 * Attributes and selectors used in component.
 */
exports.strings = {
  DETERMINATE_CIRCLE_SELECTOR: '.mdc-circular-progress__determinate-circle',
  ARIA_VALUENOW: 'aria-valuenow',
  RADIUS: 'r',
  STROKE_DASHOFFSET: 'stroke-dashoffset'
};

/***/ }),

/***/ "./packages/mdc-circular-progress/foundation.ts":
/*!******************************************************!*\
  !*** ./packages/mdc-circular-progress/foundation.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-circular-progress/constants.ts");
var MDCCircularProgressFoundation = /** @class */function (_super) {
    __extends(MDCCircularProgressFoundation, _super);
    function MDCCircularProgressFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCCircularProgressFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCCircularProgressFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCircularProgressFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCircularProgressFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                getDeterminateCircleAttribute: function getDeterminateCircleAttribute() {
                    return null;
                },
                hasClass: function hasClass() {
                    return false;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                removeAttribute: function removeAttribute() {
                    return undefined;
                },
                setAttribute: function setAttribute() {
                    return undefined;
                },
                setDeterminateCircleAttribute: function setDeterminateCircleAttribute() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCCircularProgressFoundation.prototype.init = function () {
        this.isClosed_ = this.adapter_.hasClass(constants_1.cssClasses.CLOSED_CLASS);
        this.isDeterminate_ = !this.adapter_.hasClass(constants_1.cssClasses.INDETERMINATE_CLASS);
        this.progress_ = 0;
        if (this.isDeterminate_) {
            this.adapter_.setAttribute(constants_1.strings.ARIA_VALUENOW, this.progress_.toString());
        }
        this.radius_ = Number(this.adapter_.getDeterminateCircleAttribute(constants_1.strings.RADIUS));
    };
    MDCCircularProgressFoundation.prototype.isDeterminate = function () {
        return this.isDeterminate_;
    };
    MDCCircularProgressFoundation.prototype.getProgress = function () {
        return this.progress_;
    };
    /**
     * @return Returns whether the progress indicator is hidden.
     */
    MDCCircularProgressFoundation.prototype.isClosed = function () {
        return this.isClosed_;
    };
    /**
     * Sets whether the progress indicator is in determinate mode.
     * @param isDeterminate Whether the indicator should be determinate.
     */
    MDCCircularProgressFoundation.prototype.setDeterminate = function (isDeterminate) {
        this.isDeterminate_ = isDeterminate;
        if (this.isDeterminate_) {
            this.adapter_.removeClass(constants_1.cssClasses.INDETERMINATE_CLASS);
            this.setProgress(this.progress_);
        } else {
            this.adapter_.addClass(constants_1.cssClasses.INDETERMINATE_CLASS);
            this.adapter_.removeAttribute(constants_1.strings.ARIA_VALUENOW);
        }
    };
    /**
     * Sets the current progress value. In indeterminate mode, this has no
     * visual effect but will be reflected if the indicator is switched to
     * determinate mode.
     * @param value The current progress value, which must be between 0 and 1.
     */
    MDCCircularProgressFoundation.prototype.setProgress = function (value) {
        this.progress_ = value;
        if (this.isDeterminate_) {
            var unfilledArcLength = (1 - this.progress_) * (2 * Math.PI * this.radius_);
            this.adapter_.setDeterminateCircleAttribute(constants_1.strings.STROKE_DASHOFFSET, "" + unfilledArcLength);
            this.adapter_.setAttribute(constants_1.strings.ARIA_VALUENOW, this.progress_.toString());
        }
    };
    /**
     * Shows the progress indicator.
     */
    MDCCircularProgressFoundation.prototype.open = function () {
        this.isClosed_ = false;
        this.adapter_.removeClass(constants_1.cssClasses.CLOSED_CLASS);
    };
    /**
     * Hides the progress indicator
     */
    MDCCircularProgressFoundation.prototype.close = function () {
        this.isClosed_ = true;
        this.adapter_.addClass(constants_1.cssClasses.CLOSED_CLASS);
    };
    return MDCCircularProgressFoundation;
}(foundation_1.MDCFoundation);
exports.MDCCircularProgressFoundation = MDCCircularProgressFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCCircularProgressFoundation;

/***/ }),

/***/ "./packages/mdc-circular-progress/index.ts":
/*!*************************************************!*\
  !*** ./packages/mdc-circular-progress/index.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-circular-progress/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-circular-progress/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-circular-progress/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-data-table/component.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-data-table/component.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var component_2 = __webpack_require__(/*! @material/checkbox/component */ "./packages/mdc-checkbox/component.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-data-table/constants.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-data-table/foundation.ts");
var MDCDataTable = /** @class */function (_super) {
    __extends(MDCDataTable, _super);
    function MDCDataTable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCDataTable.attachTo = function (root) {
        return new MDCDataTable(root);
    };
    MDCDataTable.prototype.initialize = function (checkboxFactory) {
        if (checkboxFactory === void 0) {
            checkboxFactory = function checkboxFactory(el) {
                return new component_2.MDCCheckbox(el);
            };
        }
        this.checkboxFactory_ = checkboxFactory;
    };
    MDCDataTable.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.headerRow_ = this.root_.querySelector("." + constants_1.cssClasses.HEADER_ROW);
        this.handleHeaderRowCheckboxChange_ = function () {
            return _this.foundation_.handleHeaderRowCheckboxChange();
        };
        this.headerRow_.addEventListener('change', this.handleHeaderRowCheckboxChange_);
        this.content_ = this.root_.querySelector("." + constants_1.cssClasses.CONTENT);
        this.handleRowCheckboxChange_ = function (event) {
            return _this.foundation_.handleRowCheckboxChange(event);
        };
        this.content_.addEventListener('change', this.handleRowCheckboxChange_);
        this.layout();
    };
    /**
     * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
     */
    MDCDataTable.prototype.layout = function () {
        this.foundation_.layout();
    };
    /**
     * @return Returns array of row elements.
     */
    MDCDataTable.prototype.getRows = function () {
        return this.foundation_.getRows();
    };
    /**
     * @return Returns array of selected row ids.
     */
    MDCDataTable.prototype.getSelectedRowIds = function () {
        return this.foundation_.getSelectedRowIds();
    };
    /**
     * Sets selected row ids. Overwrites previously selected rows.
     * @param rowIds Array of row ids that needs to be selected.
     */
    MDCDataTable.prototype.setSelectedRowIds = function (rowIds) {
        this.foundation_.setSelectedRowIds(rowIds);
    };
    MDCDataTable.prototype.destroy = function () {
        this.headerRow_.removeEventListener('change', this.handleHeaderRowCheckboxChange_);
        this.content_.removeEventListener('change', this.handleRowCheckboxChange_);
        this.headerRowCheckbox_.destroy();
        this.rowCheckboxList_.forEach(function (checkbox) {
            return checkbox.destroy();
        });
    };
    MDCDataTable.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClassAtRowIndex: function addClassAtRowIndex(rowIndex, className) {
                _this.getRows()[rowIndex].classList.add(className);
            },
            getRowCount: function getRowCount() {
                return _this.getRows().length;
            },
            getRowElements: function getRowElements() {
                return [].slice.call(_this.root_.querySelectorAll(constants_1.strings.ROW_SELECTOR));
            },
            getRowIdAtIndex: function getRowIdAtIndex(rowIndex) {
                return _this.getRows()[rowIndex].getAttribute(constants_1.strings.DATA_ROW_ID_ATTR);
            },
            getRowIndexByChildElement: function getRowIndexByChildElement(el) {
                return _this.getRows().indexOf(ponyfill_1.closest(el, constants_1.strings.ROW_SELECTOR));
            },
            getSelectedRowCount: function getSelectedRowCount() {
                return _this.root_.querySelectorAll(constants_1.strings.ROW_SELECTED_SELECTOR).length;
            },
            isCheckboxAtRowIndexChecked: function isCheckboxAtRowIndexChecked(rowIndex) {
                return _this.rowCheckboxList_[rowIndex].checked;
            },
            isHeaderRowCheckboxChecked: function isHeaderRowCheckboxChecked() {
                return _this.headerRowCheckbox_.checked;
            },
            isRowsSelectable: function isRowsSelectable() {
                return !!_this.root_.querySelector(constants_1.strings.ROW_CHECKBOX_SELECTOR);
            },
            notifyRowSelectionChanged: function notifyRowSelectionChanged(data) {
                _this.emit(constants_1.events.ROW_SELECTION_CHANGED, {
                    row: _this.getRowByIndex_(data.rowIndex),
                    rowId: _this.getRowIdByIndex_(data.rowIndex),
                    rowIndex: data.rowIndex,
                    selected: data.selected
                },
                /** shouldBubble */true);
            },
            notifySelectedAll: function notifySelectedAll() {
                _this.emit(constants_1.events.SELECTED_ALL, {}, /** shouldBubble */true);
            },
            notifyUnselectedAll: function notifyUnselectedAll() {
                _this.emit(constants_1.events.UNSELECTED_ALL, {}, /** shouldBubble */true);
            },
            registerHeaderRowCheckbox: function registerHeaderRowCheckbox() {
                if (_this.headerRowCheckbox_) {
                    _this.headerRowCheckbox_.destroy();
                }
                var checkboxEl = _this.root_.querySelector(constants_1.strings.HEADER_ROW_CHECKBOX_SELECTOR);
                _this.headerRowCheckbox_ = _this.checkboxFactory_(checkboxEl);
            },
            registerRowCheckboxes: function registerRowCheckboxes() {
                if (_this.rowCheckboxList_) {
                    _this.rowCheckboxList_.forEach(function (checkbox) {
                        return checkbox.destroy();
                    });
                }
                _this.rowCheckboxList_ = [];
                _this.getRows().forEach(function (rowEl) {
                    var checkbox = _this.checkboxFactory_(rowEl.querySelector(constants_1.strings.ROW_CHECKBOX_SELECTOR));
                    _this.rowCheckboxList_.push(checkbox);
                });
            },
            removeClassAtRowIndex: function removeClassAtRowIndex(rowIndex, className) {
                _this.getRows()[rowIndex].classList.remove(className);
            },
            setAttributeAtRowIndex: function setAttributeAtRowIndex(rowIndex, attr, value) {
                _this.getRows()[rowIndex].setAttribute(attr, value);
            },
            setHeaderRowCheckboxChecked: function setHeaderRowCheckboxChecked(checked) {
                _this.headerRowCheckbox_.checked = checked;
            },
            setHeaderRowCheckboxIndeterminate: function setHeaderRowCheckboxIndeterminate(indeterminate) {
                _this.headerRowCheckbox_.indeterminate = indeterminate;
            },
            setRowCheckboxCheckedAtIndex: function setRowCheckboxCheckedAtIndex(rowIndex, checked) {
                _this.rowCheckboxList_[rowIndex].checked = checked;
            }
        };
        return new foundation_1.MDCDataTableFoundation(adapter);
    };
    MDCDataTable.prototype.getRowByIndex_ = function (index) {
        return this.getRows()[index];
    };
    MDCDataTable.prototype.getRowIdByIndex_ = function (index) {
        return this.getRowByIndex_(index).getAttribute(constants_1.strings.DATA_ROW_ID_ATTR);
    };
    return MDCDataTable;
}(component_1.MDCComponent);
exports.MDCDataTable = MDCDataTable;

/***/ }),

/***/ "./packages/mdc-data-table/constants.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-data-table/constants.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * CSS class names used in component.
 */
exports.cssClasses = {
  CELL: 'mdc-data-table__cell',
  CELL_NUMERIC: 'mdc-data-table__cell--numeric',
  CONTENT: 'mdc-data-table__content',
  HEADER_CELL_SORTED: 'mdc-data-table__header-cell--sorted',
  HEADER_CELL_SORTED_DESCENDING: 'mdc-data-table__header-cell--sorted-descending',
  HEADER_CELL_WITH_SORT: 'mdc-data-table__header-cell--with-sort',
  HEADER_ROW: 'mdc-data-table__header-row',
  HEADER_ROW_CHECKBOX: 'mdc-data-table__header-row-checkbox',
  IN_PROGRESS: 'mdc-data-table--in-progress',
  ROOT: 'mdc-data-table',
  ROW: 'mdc-data-table__row',
  ROW_CHECKBOX: 'mdc-data-table__row-checkbox',
  ROW_SELECTED: 'mdc-data-table__row--selected',
  SORT_ICON_BUTTON: 'mdc-data-table__sort-icon-button'
};
/**
 * List of data attributes used in component.
 */
exports.dataAttributes = {
  ROW_ID: 'data-row-id',
  COLUMND_ID: 'data-columnd-id'
};
/**
 * Attributes and selectors used in component.
 */
exports.strings = {
  ARIA_SELECTED: 'aria-selected',
  ARIA_SORT: 'aria-sort',
  DATA_ROW_ID_ATTR: exports.dataAttributes.ROW_ID,
  HEADER_ROW_CHECKBOX_SELECTOR: "." + exports.cssClasses.HEADER_ROW_CHECKBOX,
  ROW_CHECKBOX_SELECTOR: "." + exports.cssClasses.ROW_CHECKBOX,
  ROW_SELECTED_SELECTOR: "." + exports.cssClasses.ROW_SELECTED,
  ROW_SELECTOR: "." + exports.cssClasses.ROW
};
/**
 * Sort values defined by ARIA.
 * See https://www.w3.org/WAI/PF/aria/states_and_properties#aria-sort
 */
var SortValue;
(function (SortValue) {
  // Items are sorted in ascending order by this column.
  SortValue["ASCENDING"] = "ascending";
  // Items are sorted in descending order by this column.
  SortValue["DESCENDING"] = "descending";
  // There is no defined sort applied to the column.
  SortValue["NONE"] = "none";
  // A sort algorithm other than ascending or descending has been applied.
  SortValue["OTHER"] = "other";
})(SortValue = exports.SortValue || (exports.SortValue = {}));
/**
 * Event names used in component.
 */
exports.events = {
  ROW_SELECTION_CHANGED: 'MDCDataTable:rowSelectionChanged',
  SELECTED_ALL: 'MDCDataTable:selectedAll',
  UNSELECTED_ALL: 'MDCDataTable:unselectedAll',
  SORTED: 'MDCDataTable:sorted'
};

/***/ }),

/***/ "./packages/mdc-data-table/foundation.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-data-table/foundation.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function (thisArg, body) {
    var _ = { label: 0, sent: function sent() {
            if (t[0] & 1) throw t[1];return t[1];
        }, trys: [], ops: [] },
        f,
        y,
        t,
        g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
    }), g;
    function verb(n) {
        return function (v) {
            return step([n, v]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) {
            try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0:case 1:
                        t = op;break;
                    case 4:
                        _.label++;return { value: op[1], done: false };
                    case 5:
                        _.label++;y = op[1];op = [0];continue;
                    case 7:
                        op = _.ops.pop();_.trys.pop();continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                            _.label = op[1];break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];t = op;break;
                        }
                        if (t && _.label < t[2]) {
                            _.label = t[2];_.ops.push(op);break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();continue;
                }
                op = body.call(thisArg, _);
            } catch (e) {
                op = [6, e];y = 0;
            } finally {
                f = t = 0;
            }
        }if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-data-table/constants.ts");
var MDCDataTableFoundation = /** @class */function (_super) {
    __extends(MDCDataTableFoundation, _super);
    function MDCDataTableFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCDataTableFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCDataTableFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                addClassAtRowIndex: function addClassAtRowIndex() {
                    return undefined;
                },
                getAttributeByHeaderCellIndex: function getAttributeByHeaderCellIndex() {
                    return '';
                },
                getHeaderCellCount: function getHeaderCellCount() {
                    return 0;
                },
                getHeaderCellElements: function getHeaderCellElements() {
                    return [];
                },
                getRowCount: function getRowCount() {
                    return 0;
                },
                getRowElements: function getRowElements() {
                    return [];
                },
                getRowIdAtIndex: function getRowIdAtIndex() {
                    return '';
                },
                getRowIndexByChildElement: function getRowIndexByChildElement() {
                    return 0;
                },
                getSelectedRowCount: function getSelectedRowCount() {
                    return 0;
                },
                getTableBodyHeight: function getTableBodyHeight() {
                    return '';
                },
                getTableHeaderHeight: function getTableHeaderHeight() {
                    return '';
                },
                isCheckboxAtRowIndexChecked: function isCheckboxAtRowIndexChecked() {
                    return false;
                },
                isHeaderRowCheckboxChecked: function isHeaderRowCheckboxChecked() {
                    return false;
                },
                isRowsSelectable: function isRowsSelectable() {
                    return false;
                },
                notifyRowSelectionChanged: function notifyRowSelectionChanged() {
                    return undefined;
                },
                notifySelectedAll: function notifySelectedAll() {
                    return undefined;
                },
                notifySortAction: function notifySortAction() {
                    return undefined;
                },
                notifyUnselectedAll: function notifyUnselectedAll() {
                    return undefined;
                },
                registerHeaderRowCheckbox: function registerHeaderRowCheckbox() {
                    return undefined;
                },
                registerRowCheckboxes: function registerRowCheckboxes() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                removeClassAtRowIndex: function removeClassAtRowIndex() {
                    return undefined;
                },
                removeClassNameByHeaderCellIndex: function removeClassNameByHeaderCellIndex() {
                    return undefined;
                },
                setAttributeAtRowIndex: function setAttributeAtRowIndex() {
                    return undefined;
                },
                setAttributeByHeaderCellIndex: function setAttributeByHeaderCellIndex() {
                    return undefined;
                },
                setClassNameByHeaderCellIndex: function setClassNameByHeaderCellIndex() {
                    return undefined;
                },
                setHeaderRowCheckboxChecked: function setHeaderRowCheckboxChecked() {
                    return undefined;
                },
                setHeaderRowCheckboxIndeterminate: function setHeaderRowCheckboxIndeterminate() {
                    return undefined;
                },
                setProgressIndicatorStyles: function setProgressIndicatorStyles() {
                    return undefined;
                },
                setRowCheckboxCheckedAtIndex: function setRowCheckboxCheckedAtIndex() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
     * Use this if registering checkbox is synchronous.
     */
    MDCDataTableFoundation.prototype.layout = function () {
        if (this.adapter_.isRowsSelectable()) {
            this.adapter_.registerHeaderRowCheckbox();
            this.adapter_.registerRowCheckboxes();
            this.setHeaderRowCheckboxState_();
        }
    };
    /**
     * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
     * Use this if registering checkbox is asynchronous.
     */
    MDCDataTableFoundation.prototype.layoutAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.adapter_.isRowsSelectable()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.adapter_.registerHeaderRowCheckbox()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.adapter_.registerRowCheckboxes()];
                    case 2:
                        _a.sent();
                        this.setHeaderRowCheckboxState_();
                        _a.label = 3;
                    case 3:
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @return Returns array of row elements.
     */
    MDCDataTableFoundation.prototype.getRows = function () {
        return this.adapter_.getRowElements();
    };
    /**
     * @return Array of header cell elements.
     */
    MDCDataTableFoundation.prototype.getHeaderCells = function () {
        return this.adapter_.getHeaderCellElements();
    };
    /**
     * Sets selected row ids. Overwrites previously selected rows.
     * @param rowIds Array of row ids that needs to be selected.
     */
    MDCDataTableFoundation.prototype.setSelectedRowIds = function (rowIds) {
        for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
            var rowId = this.adapter_.getRowIdAtIndex(rowIndex);
            var isSelected = false;
            if (rowId && rowIds.indexOf(rowId) >= 0) {
                isSelected = true;
            }
            this.adapter_.setRowCheckboxCheckedAtIndex(rowIndex, isSelected);
            this.selectRowAtIndex_(rowIndex, isSelected);
        }
        this.setHeaderRowCheckboxState_();
    };
    /**
     * @return Returns array of all row ids.
     */
    MDCDataTableFoundation.prototype.getRowIds = function () {
        var rowIds = [];
        for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
            rowIds.push(this.adapter_.getRowIdAtIndex(rowIndex));
        }
        return rowIds;
    };
    /**
     * @return Returns array of selected row ids.
     */
    MDCDataTableFoundation.prototype.getSelectedRowIds = function () {
        var selectedRowIds = [];
        for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
            if (this.adapter_.isCheckboxAtRowIndexChecked(rowIndex)) {
                selectedRowIds.push(this.adapter_.getRowIdAtIndex(rowIndex));
            }
        }
        return selectedRowIds;
    };
    /**
     * Handles header row checkbox change event.
     */
    MDCDataTableFoundation.prototype.handleHeaderRowCheckboxChange = function () {
        var isHeaderChecked = this.adapter_.isHeaderRowCheckboxChecked();
        for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
            this.adapter_.setRowCheckboxCheckedAtIndex(rowIndex, isHeaderChecked);
            this.selectRowAtIndex_(rowIndex, isHeaderChecked);
        }
        if (isHeaderChecked) {
            this.adapter_.notifySelectedAll();
        } else {
            this.adapter_.notifyUnselectedAll();
        }
    };
    /**
     * Handles change event originated from row checkboxes.
     */
    MDCDataTableFoundation.prototype.handleRowCheckboxChange = function (event) {
        var rowIndex = this.adapter_.getRowIndexByChildElement(event.target);
        if (rowIndex === -1) {
            return;
        }
        var selected = this.adapter_.isCheckboxAtRowIndexChecked(rowIndex);
        this.selectRowAtIndex_(rowIndex, selected);
        this.setHeaderRowCheckboxState_();
        var rowId = this.adapter_.getRowIdAtIndex(rowIndex);
        this.adapter_.notifyRowSelectionChanged({ rowId: rowId, rowIndex: rowIndex, selected: selected });
    };
    /**
     * Handles sort action on sortable header cell.
     */
    MDCDataTableFoundation.prototype.handleSortAction = function (eventData) {
        var columnId = eventData.columnId,
            columnIndex = eventData.columnIndex,
            headerCell = eventData.headerCell;
        // Reset sort attributes / classes on other header cells.
        for (var index = 0; index < this.adapter_.getHeaderCellCount(); index++) {
            if (index === columnIndex) {
                continue;
            }
            this.adapter_.removeClassNameByHeaderCellIndex(index, constants_1.cssClasses.HEADER_CELL_SORTED);
            this.adapter_.removeClassNameByHeaderCellIndex(index, constants_1.cssClasses.HEADER_CELL_SORTED_DESCENDING);
            this.adapter_.setAttributeByHeaderCellIndex(index, constants_1.strings.ARIA_SORT, constants_1.SortValue.NONE);
        }
        // Set appropriate sort attributes / classes on target header cell.
        this.adapter_.setClassNameByHeaderCellIndex(columnIndex, constants_1.cssClasses.HEADER_CELL_SORTED);
        var currentSortValue = this.adapter_.getAttributeByHeaderCellIndex(columnIndex, constants_1.strings.ARIA_SORT);
        var sortValue = constants_1.SortValue.NONE;
        // Set to descending if sorted on ascending order.
        if (currentSortValue === constants_1.SortValue.ASCENDING) {
            this.adapter_.setClassNameByHeaderCellIndex(columnIndex, constants_1.cssClasses.HEADER_CELL_SORTED_DESCENDING);
            this.adapter_.setAttributeByHeaderCellIndex(columnIndex, constants_1.strings.ARIA_SORT, constants_1.SortValue.DESCENDING);
            sortValue = constants_1.SortValue.DESCENDING;
            // Set to ascending if sorted on descending order.
        } else if (currentSortValue === constants_1.SortValue.DESCENDING) {
            this.adapter_.removeClassNameByHeaderCellIndex(columnIndex, constants_1.cssClasses.HEADER_CELL_SORTED_DESCENDING);
            this.adapter_.setAttributeByHeaderCellIndex(columnIndex, constants_1.strings.ARIA_SORT, constants_1.SortValue.ASCENDING);
            sortValue = constants_1.SortValue.ASCENDING;
        } else {
            // Set to ascending by default when not sorted.
            this.adapter_.setAttributeByHeaderCellIndex(columnIndex, constants_1.strings.ARIA_SORT, constants_1.SortValue.ASCENDING);
            sortValue = constants_1.SortValue.ASCENDING;
        }
        this.adapter_.notifySortAction({
            columnId: columnId,
            columnIndex: columnIndex,
            headerCell: headerCell,
            sortValue: sortValue
        });
    };
    /**
     * Shows progress indicator blocking only the table body content when in
     * loading state.
     */
    MDCDataTableFoundation.prototype.showProgress = function () {
        var height = this.adapter_.getTableBodyHeight();
        var top = this.adapter_.getTableHeaderHeight();
        this.adapter_.setProgressIndicatorStyles({
            height: height,
            top: top
        });
        this.adapter_.addClass(constants_1.cssClasses.IN_PROGRESS);
    };
    /**
     * Hides progress indicator when data table is finished loading.
     */
    MDCDataTableFoundation.prototype.hideProgress = function () {
        this.adapter_.removeClass(constants_1.cssClasses.IN_PROGRESS);
    };
    /**
     * Updates header row checkbox state based on number of rows selected.
     */
    MDCDataTableFoundation.prototype.setHeaderRowCheckboxState_ = function () {
        if (this.adapter_.getSelectedRowCount() === this.adapter_.getRowCount()) {
            this.adapter_.setHeaderRowCheckboxChecked(true);
            this.adapter_.setHeaderRowCheckboxIndeterminate(false);
        } else if (this.adapter_.getSelectedRowCount() === 0) {
            this.adapter_.setHeaderRowCheckboxIndeterminate(false);
            this.adapter_.setHeaderRowCheckboxChecked(false);
        } else {
            this.adapter_.setHeaderRowCheckboxIndeterminate(true);
            this.adapter_.setHeaderRowCheckboxChecked(false);
        }
    };
    /**
     * Sets the attributes of row element based on selection state.
     */
    MDCDataTableFoundation.prototype.selectRowAtIndex_ = function (rowIndex, selected) {
        if (selected) {
            this.adapter_.addClassAtRowIndex(rowIndex, constants_1.cssClasses.ROW_SELECTED);
            this.adapter_.setAttributeAtRowIndex(rowIndex, constants_1.strings.ARIA_SELECTED, 'true');
        } else {
            this.adapter_.removeClassAtRowIndex(rowIndex, constants_1.cssClasses.ROW_SELECTED);
            this.adapter_.setAttributeAtRowIndex(rowIndex, constants_1.strings.ARIA_SELECTED, 'false');
        }
    };
    return MDCDataTableFoundation;
}(foundation_1.MDCFoundation);
exports.MDCDataTableFoundation = MDCDataTableFoundation;

/***/ }),

/***/ "./packages/mdc-data-table/index.ts":
/*!******************************************!*\
  !*** ./packages/mdc-data-table/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-data-table/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-data-table/foundation.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-data-table/constants.ts"));

/***/ }),

/***/ "./packages/mdc-dialog/component.ts":
/*!******************************************!*\
  !*** ./packages/mdc-dialog/component.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = this && this.__values || function (o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var focus_trap_1 = __webpack_require__(/*! @material/dom/focus-trap */ "./packages/mdc-dom/focus-trap.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var component_2 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-dialog/foundation.ts");
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-dialog/util.ts"));
var strings = foundation_1.MDCDialogFoundation.strings;
var MDCDialog = /** @class */function (_super) {
    __extends(MDCDialog, _super);
    function MDCDialog() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCDialog.prototype, "isOpen", {
        get: function get() {
            return this.foundation_.isOpen();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialog.prototype, "escapeKeyAction", {
        get: function get() {
            return this.foundation_.getEscapeKeyAction();
        },
        set: function set(action) {
            this.foundation_.setEscapeKeyAction(action);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialog.prototype, "scrimClickAction", {
        get: function get() {
            return this.foundation_.getScrimClickAction();
        },
        set: function set(action) {
            this.foundation_.setScrimClickAction(action);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialog.prototype, "autoStackButtons", {
        get: function get() {
            return this.foundation_.getAutoStackButtons();
        },
        set: function set(autoStack) {
            this.foundation_.setAutoStackButtons(autoStack);
        },
        enumerable: true,
        configurable: true
    });
    MDCDialog.attachTo = function (root) {
        return new MDCDialog(root);
    };
    MDCDialog.prototype.initialize = function (focusTrapFactory) {
        var e_1, _a;
        if (focusTrapFactory === void 0) {
            focusTrapFactory = function focusTrapFactory(el, focusOptions) {
                return new focus_trap_1.FocusTrap(el, focusOptions);
            };
        }
        var container = this.root_.querySelector(strings.CONTAINER_SELECTOR);
        if (!container) {
            throw new Error("Dialog component requires a " + strings.CONTAINER_SELECTOR + " container element");
        }
        this.container_ = container;
        this.content_ = this.root_.querySelector(strings.CONTENT_SELECTOR);
        this.buttons_ = [].slice.call(this.root_.querySelectorAll(strings.BUTTON_SELECTOR));
        this.defaultButton_ = this.root_.querySelector("[" + strings.BUTTON_DEFAULT_ATTRIBUTE + "]");
        this.focusTrapFactory_ = focusTrapFactory;
        this.buttonRipples_ = [];
        try {
            for (var _b = __values(this.buttons_), _c = _b.next(); !_c.done; _c = _b.next()) {
                var buttonEl = _c.value;
                this.buttonRipples_.push(new component_2.MDCRipple(buttonEl));
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    MDCDialog.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.focusTrap_ = util.createFocusTrapInstance(this.container_, this.focusTrapFactory_, this.getInitialFocusEl_() || undefined);
        this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
        this.handleKeydown_ = this.foundation_.handleKeydown.bind(this.foundation_);
        this.handleDocumentKeydown_ = this.foundation_.handleDocumentKeydown.bind(this.foundation_);
        this.handleLayout_ = this.layout.bind(this);
        var LAYOUT_EVENTS = ['resize', 'orientationchange'];
        this.handleOpening_ = function () {
            LAYOUT_EVENTS.forEach(function (evtType) {
                return window.addEventListener(evtType, _this.handleLayout_);
            });
            document.addEventListener('keydown', _this.handleDocumentKeydown_);
        };
        this.handleClosing_ = function () {
            LAYOUT_EVENTS.forEach(function (evtType) {
                return window.removeEventListener(evtType, _this.handleLayout_);
            });
            document.removeEventListener('keydown', _this.handleDocumentKeydown_);
        };
        this.listen('click', this.handleClick_);
        this.listen('keydown', this.handleKeydown_);
        this.listen(strings.OPENING_EVENT, this.handleOpening_);
        this.listen(strings.CLOSING_EVENT, this.handleClosing_);
    };
    MDCDialog.prototype.destroy = function () {
        this.unlisten('click', this.handleClick_);
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten(strings.OPENING_EVENT, this.handleOpening_);
        this.unlisten(strings.CLOSING_EVENT, this.handleClosing_);
        this.handleClosing_();
        this.buttonRipples_.forEach(function (ripple) {
            return ripple.destroy();
        });
        _super.prototype.destroy.call(this);
    };
    MDCDialog.prototype.layout = function () {
        this.foundation_.layout();
    };
    MDCDialog.prototype.open = function () {
        this.foundation_.open();
    };
    MDCDialog.prototype.close = function (action) {
        if (action === void 0) {
            action = '';
        }
        this.foundation_.close(action);
    };
    MDCDialog.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addBodyClass: function addBodyClass(className) {
                return document.body.classList.add(className);
            },
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            areButtonsStacked: function areButtonsStacked() {
                return util.areTopsMisaligned(_this.buttons_);
            },
            clickDefaultButton: function clickDefaultButton() {
                return _this.defaultButton_ && _this.defaultButton_.click();
            },
            eventTargetMatches: function eventTargetMatches(target, selector) {
                return target ? ponyfill_1.matches(target, selector) : false;
            },
            getActionFromEvent: function getActionFromEvent(evt) {
                if (!evt.target) {
                    return '';
                }
                var element = ponyfill_1.closest(evt.target, "[" + strings.ACTION_ATTRIBUTE + "]");
                return element && element.getAttribute(strings.ACTION_ATTRIBUTE);
            },
            getInitialFocusEl: function getInitialFocusEl() {
                return _this.getInitialFocusEl_();
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            isContentScrollable: function isContentScrollable() {
                return util.isScrollable(_this.content_);
            },
            notifyClosed: function notifyClosed(action) {
                return _this.emit(strings.CLOSED_EVENT, action ? { action: action } : {});
            },
            notifyClosing: function notifyClosing(action) {
                return _this.emit(strings.CLOSING_EVENT, action ? { action: action } : {});
            },
            notifyOpened: function notifyOpened() {
                return _this.emit(strings.OPENED_EVENT, {});
            },
            notifyOpening: function notifyOpening() {
                return _this.emit(strings.OPENING_EVENT, {});
            },
            releaseFocus: function releaseFocus() {
                return _this.focusTrap_.releaseFocus();
            },
            removeBodyClass: function removeBodyClass(className) {
                return document.body.classList.remove(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            reverseButtons: function reverseButtons() {
                _this.buttons_.reverse();
                _this.buttons_.forEach(function (button) {
                    button.parentElement.appendChild(button);
                });
            },
            trapFocus: function trapFocus() {
                return _this.focusTrap_.trapFocus();
            }
        };
        return new foundation_1.MDCDialogFoundation(adapter);
    };
    MDCDialog.prototype.getInitialFocusEl_ = function () {
        return document.querySelector("[" + strings.INITIAL_FOCUS_ATTRIBUTE + "]");
    };
    return MDCDialog;
}(component_1.MDCComponent);
exports.MDCDialog = MDCDialog;

/***/ }),

/***/ "./packages/mdc-dialog/constants.ts":
/*!******************************************!*\
  !*** ./packages/mdc-dialog/constants.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.cssClasses = {
    CLOSING: 'mdc-dialog--closing',
    OPEN: 'mdc-dialog--open',
    OPENING: 'mdc-dialog--opening',
    SCROLLABLE: 'mdc-dialog--scrollable',
    SCROLL_LOCK: 'mdc-dialog-scroll-lock',
    STACKED: 'mdc-dialog--stacked'
};
exports.strings = {
    ACTION_ATTRIBUTE: 'data-mdc-dialog-action',
    BUTTON_DEFAULT_ATTRIBUTE: 'data-mdc-dialog-button-default',
    BUTTON_SELECTOR: '.mdc-dialog__button',
    CLOSED_EVENT: 'MDCDialog:closed',
    CLOSE_ACTION: 'close',
    CLOSING_EVENT: 'MDCDialog:closing',
    CONTAINER_SELECTOR: '.mdc-dialog__container',
    CONTENT_SELECTOR: '.mdc-dialog__content',
    DESTROY_ACTION: 'destroy',
    INITIAL_FOCUS_ATTRIBUTE: 'data-mdc-dialog-initial-focus',
    OPENED_EVENT: 'MDCDialog:opened',
    OPENING_EVENT: 'MDCDialog:opening',
    SCRIM_SELECTOR: '.mdc-dialog__scrim',
    SUPPRESS_DEFAULT_PRESS_SELECTOR: ['textarea', '.mdc-menu .mdc-list-item'].join(', '),
    SURFACE_SELECTOR: '.mdc-dialog__surface'
};
exports.numbers = {
    DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
    DIALOG_ANIMATION_OPEN_TIME_MS: 150
};

/***/ }),

/***/ "./packages/mdc-dialog/foundation.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-dialog/foundation.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-dialog/constants.ts");
var MDCDialogFoundation = /** @class */function (_super) {
    __extends(MDCDialogFoundation, _super);
    function MDCDialogFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCDialogFoundation.defaultAdapter), adapter)) || this;
        _this.isOpen_ = false;
        _this.animationFrame_ = 0;
        _this.animationTimer_ = 0;
        _this.layoutFrame_ = 0;
        _this.escapeKeyAction_ = constants_1.strings.CLOSE_ACTION;
        _this.scrimClickAction_ = constants_1.strings.CLOSE_ACTION;
        _this.autoStackButtons_ = true;
        _this.areButtonsStacked_ = false;
        return _this;
    }
    Object.defineProperty(MDCDialogFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialogFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialogFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialogFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addBodyClass: function addBodyClass() {
                    return undefined;
                },
                addClass: function addClass() {
                    return undefined;
                },
                areButtonsStacked: function areButtonsStacked() {
                    return false;
                },
                clickDefaultButton: function clickDefaultButton() {
                    return undefined;
                },
                eventTargetMatches: function eventTargetMatches() {
                    return false;
                },
                getActionFromEvent: function getActionFromEvent() {
                    return '';
                },
                getInitialFocusEl: function getInitialFocusEl() {
                    return null;
                },
                hasClass: function hasClass() {
                    return false;
                },
                isContentScrollable: function isContentScrollable() {
                    return false;
                },
                notifyClosed: function notifyClosed() {
                    return undefined;
                },
                notifyClosing: function notifyClosing() {
                    return undefined;
                },
                notifyOpened: function notifyOpened() {
                    return undefined;
                },
                notifyOpening: function notifyOpening() {
                    return undefined;
                },
                releaseFocus: function releaseFocus() {
                    return undefined;
                },
                removeBodyClass: function removeBodyClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                reverseButtons: function reverseButtons() {
                    return undefined;
                },
                trapFocus: function trapFocus() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCDialogFoundation.prototype.init = function () {
        if (this.adapter_.hasClass(constants_1.cssClasses.STACKED)) {
            this.setAutoStackButtons(false);
        }
    };
    MDCDialogFoundation.prototype.destroy = function () {
        if (this.isOpen_) {
            this.close(constants_1.strings.DESTROY_ACTION);
        }
        if (this.animationTimer_) {
            clearTimeout(this.animationTimer_);
            this.handleAnimationTimerEnd_();
        }
        if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
            this.layoutFrame_ = 0;
        }
    };
    MDCDialogFoundation.prototype.open = function () {
        var _this = this;
        this.isOpen_ = true;
        this.adapter_.notifyOpening();
        this.adapter_.addClass(constants_1.cssClasses.OPENING);
        // Wait a frame once display is no longer "none", to establish basis for animation
        this.runNextAnimationFrame_(function () {
            _this.adapter_.addClass(constants_1.cssClasses.OPEN);
            _this.adapter_.addBodyClass(constants_1.cssClasses.SCROLL_LOCK);
            _this.layout();
            _this.animationTimer_ = setTimeout(function () {
                _this.handleAnimationTimerEnd_();
                _this.adapter_.trapFocus(_this.adapter_.getInitialFocusEl());
                _this.adapter_.notifyOpened();
            }, constants_1.numbers.DIALOG_ANIMATION_OPEN_TIME_MS);
        });
    };
    MDCDialogFoundation.prototype.close = function (action) {
        var _this = this;
        if (action === void 0) {
            action = '';
        }
        if (!this.isOpen_) {
            // Avoid redundant close calls (and events), e.g. from keydown on elements that inherently emit click
            return;
        }
        this.isOpen_ = false;
        this.adapter_.notifyClosing(action);
        this.adapter_.addClass(constants_1.cssClasses.CLOSING);
        this.adapter_.removeClass(constants_1.cssClasses.OPEN);
        this.adapter_.removeBodyClass(constants_1.cssClasses.SCROLL_LOCK);
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = setTimeout(function () {
            _this.adapter_.releaseFocus();
            _this.handleAnimationTimerEnd_();
            _this.adapter_.notifyClosed(action);
        }, constants_1.numbers.DIALOG_ANIMATION_CLOSE_TIME_MS);
    };
    MDCDialogFoundation.prototype.isOpen = function () {
        return this.isOpen_;
    };
    MDCDialogFoundation.prototype.getEscapeKeyAction = function () {
        return this.escapeKeyAction_;
    };
    MDCDialogFoundation.prototype.setEscapeKeyAction = function (action) {
        this.escapeKeyAction_ = action;
    };
    MDCDialogFoundation.prototype.getScrimClickAction = function () {
        return this.scrimClickAction_;
    };
    MDCDialogFoundation.prototype.setScrimClickAction = function (action) {
        this.scrimClickAction_ = action;
    };
    MDCDialogFoundation.prototype.getAutoStackButtons = function () {
        return this.autoStackButtons_;
    };
    MDCDialogFoundation.prototype.setAutoStackButtons = function (autoStack) {
        this.autoStackButtons_ = autoStack;
    };
    MDCDialogFoundation.prototype.layout = function () {
        var _this = this;
        if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
            _this.layoutInternal_();
            _this.layoutFrame_ = 0;
        });
    };
    /** Handles click on the dialog root element. */
    MDCDialogFoundation.prototype.handleClick = function (evt) {
        var isScrim = this.adapter_.eventTargetMatches(evt.target, constants_1.strings.SCRIM_SELECTOR);
        // Check for scrim click first since it doesn't require querying ancestors.
        if (isScrim && this.scrimClickAction_ !== '') {
            this.close(this.scrimClickAction_);
        } else {
            var action = this.adapter_.getActionFromEvent(evt);
            if (action) {
                this.close(action);
            }
        }
    };
    /** Handles keydown on the dialog root element. */
    MDCDialogFoundation.prototype.handleKeydown = function (evt) {
        var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
        if (!isEnter) {
            return;
        }
        var action = this.adapter_.getActionFromEvent(evt);
        if (action) {
            // Action button callback is handled in `handleClick`,
            // since space/enter keydowns on buttons trigger click events.
            return;
        }
        var isDefault = !this.adapter_.eventTargetMatches(evt.target, constants_1.strings.SUPPRESS_DEFAULT_PRESS_SELECTOR);
        if (isEnter && isDefault) {
            this.adapter_.clickDefaultButton();
        }
    };
    /** Handles keydown on the document. */
    MDCDialogFoundation.prototype.handleDocumentKeydown = function (evt) {
        var isEscape = evt.key === 'Escape' || evt.keyCode === 27;
        if (isEscape && this.escapeKeyAction_ !== '') {
            this.close(this.escapeKeyAction_);
        }
    };
    MDCDialogFoundation.prototype.layoutInternal_ = function () {
        if (this.autoStackButtons_) {
            this.detectStackedButtons_();
        }
        this.detectScrollableContent_();
    };
    MDCDialogFoundation.prototype.handleAnimationTimerEnd_ = function () {
        this.animationTimer_ = 0;
        this.adapter_.removeClass(constants_1.cssClasses.OPENING);
        this.adapter_.removeClass(constants_1.cssClasses.CLOSING);
    };
    /**
     * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
     */
    MDCDialogFoundation.prototype.runNextAnimationFrame_ = function (callback) {
        var _this = this;
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = requestAnimationFrame(function () {
            _this.animationFrame_ = 0;
            clearTimeout(_this.animationTimer_);
            _this.animationTimer_ = setTimeout(callback, 0);
        });
    };
    MDCDialogFoundation.prototype.detectStackedButtons_ = function () {
        // Remove the class first to let us measure the buttons' natural positions.
        this.adapter_.removeClass(constants_1.cssClasses.STACKED);
        var areButtonsStacked = this.adapter_.areButtonsStacked();
        if (areButtonsStacked) {
            this.adapter_.addClass(constants_1.cssClasses.STACKED);
        }
        if (areButtonsStacked !== this.areButtonsStacked_) {
            this.adapter_.reverseButtons();
            this.areButtonsStacked_ = areButtonsStacked;
        }
    };
    MDCDialogFoundation.prototype.detectScrollableContent_ = function () {
        // Remove the class first to let us measure the natural height of the content.
        this.adapter_.removeClass(constants_1.cssClasses.SCROLLABLE);
        if (this.adapter_.isContentScrollable()) {
            this.adapter_.addClass(constants_1.cssClasses.SCROLLABLE);
        }
    };
    return MDCDialogFoundation;
}(foundation_1.MDCFoundation);
exports.MDCDialogFoundation = MDCDialogFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCDialogFoundation;

/***/ }),

/***/ "./packages/mdc-dialog/index.ts":
/*!**************************************!*\
  !*** ./packages/mdc-dialog/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-dialog/util.ts"));
exports.util = util;
__export(__webpack_require__(/*! ./component */ "./packages/mdc-dialog/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-dialog/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-dialog/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-dialog/util.ts":
/*!*************************************!*\
  !*** ./packages/mdc-dialog/util.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
function createFocusTrapInstance(surfaceEl, focusTrapFactory, initialFocusEl) {
    return focusTrapFactory(surfaceEl, { initialFocusEl: initialFocusEl });
}
exports.createFocusTrapInstance = createFocusTrapInstance;
function isScrollable(el) {
    return el ? el.scrollHeight > el.offsetHeight : false;
}
exports.isScrollable = isScrollable;
function areTopsMisaligned(els) {
    var tops = new Set();
    [].forEach.call(els, function (el) {
        return tops.add(el.offsetTop);
    });
    return tops.size > 1;
}
exports.areTopsMisaligned = areTopsMisaligned;

/***/ }),

/***/ "./packages/mdc-dom/announce.ts":
/*!**************************************!*\
  !*** ./packages/mdc-dom/announce.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Priorities for the announce function
 */
var AnnouncerPriority;
(function (AnnouncerPriority) {
    AnnouncerPriority["POLITE"] = "polite";
    AnnouncerPriority["ASSERTIVE"] = "assertive";
})(AnnouncerPriority = exports.AnnouncerPriority || (exports.AnnouncerPriority = {}));
/**
 * Announces the given message with optional priority, defaulting to "polite"
 */
function announce(message, priority) {
    Announcer.getInstance().say(message, priority);
}
exports.announce = announce;
var Announcer = /** @class */function () {
    // Constructor made private to ensure only the singleton is used
    function Announcer() {
        this.liveRegions = new Map();
    }
    Announcer.getInstance = function () {
        if (!Announcer.instance) {
            Announcer.instance = new Announcer();
        }
        return Announcer.instance;
    };
    Announcer.prototype.say = function (message, priority) {
        if (priority === void 0) {
            priority = AnnouncerPriority.POLITE;
        }
        var liveRegion = this.getLiveRegion(priority);
        // Reset the region to pick up the message, even if the message is the
        // exact same as before.
        liveRegion.textContent = '';
        // Timeout is necessary for screen readers like NVDA and VoiceOver.
        setTimeout(function () {
            liveRegion.textContent = message;
        }, 1);
    };
    Announcer.prototype.getLiveRegion = function (priority) {
        var existingLiveRegion = this.liveRegions.get(priority);
        if (existingLiveRegion && document.body.contains(existingLiveRegion)) {
            return existingLiveRegion;
        }
        var liveRegion = this.createLiveRegion(priority);
        this.liveRegions.set(priority, liveRegion);
        return liveRegion;
    };
    Announcer.prototype.createLiveRegion = function (priority) {
        var el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.top = '-9999px';
        el.style.left = '-9999px';
        el.style.height = '1px';
        el.style.overflow = 'hidden';
        el.setAttribute('aria-atomic', 'true');
        el.setAttribute('aria-live', priority);
        document.body.appendChild(el);
        return el;
    };
    return Announcer;
}();

/***/ }),

/***/ "./packages/mdc-dom/events.ts":
/*!************************************!*\
  !*** ./packages/mdc-dom/events.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Determine whether the current browser supports passive event listeners, and
 * if so, use them.
 */
function applyPassive(globalObj) {
    if (globalObj === void 0) {
        globalObj = window;
    }
    return supportsPassiveOption(globalObj) ? { passive: true } : false;
}
exports.applyPassive = applyPassive;
function supportsPassiveOption(globalObj) {
    if (globalObj === void 0) {
        globalObj = window;
    }
    // See
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
    var passiveSupported = false;
    try {
        var options = {
            // This function will be called when the browser
            // attempts to access the passive property.
            get passive() {
                passiveSupported = true;
                return false;
            }
        };
        var handler = function handler() {};
        globalObj.document.addEventListener('test', handler, options);
        globalObj.document.removeEventListener('test', handler, options);
    } catch (err) {
        passiveSupported = false;
    }
    return passiveSupported;
}

/***/ }),

/***/ "./packages/mdc-dom/focus-trap.ts":
/*!****************************************!*\
  !*** ./packages/mdc-dom/focus-trap.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var FOCUS_SENTINEL_CLASS = 'mdc-dom-focus-sentinel';
/**
 * Utility to trap focus in a given root element, e.g. for modal components such
 * as dialogs. The root should have at least one focusable child element,
 * for setting initial focus when trapping focus.
 * Also tracks the previously focused element, and restores focus to that
 * element when releasing focus.
 */
var FocusTrap = /** @class */function () {
    function FocusTrap(root, options) {
        if (options === void 0) {
            options = {};
        }
        this.root = root;
        this.options = options;
        // Previously focused element before trapping focus.
        this.elFocusedBeforeTrapFocus = null;
    }
    /**
     * Traps focus in `root`. Also focuses on either `initialFocusEl` if set;
     * otherwises sets initial focus to the first focusable child element.
     */
    FocusTrap.prototype.trapFocus = function () {
        var focusableEls = this.getFocusableElements(this.root);
        if (focusableEls.length === 0) {
            throw new Error('FocusTrap: Element must have at least one focusable child.');
        }
        this.elFocusedBeforeTrapFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
        this.wrapTabFocus(this.root, focusableEls);
        if (!this.options.skipInitialFocus) {
            this.focusInitialElement(focusableEls, this.options.initialFocusEl);
        }
    };
    /**
     * Releases focus from `root`. Also restores focus to the previously focused
     * element.
     */
    FocusTrap.prototype.releaseFocus = function () {
        [].slice.call(this.root.querySelectorAll("." + FOCUS_SENTINEL_CLASS)).forEach(function (sentinelEl) {
            sentinelEl.parentElement.removeChild(sentinelEl);
        });
        if (this.elFocusedBeforeTrapFocus) {
            this.elFocusedBeforeTrapFocus.focus();
        }
    };
    /**
     * Wraps tab focus within `el` by adding two hidden sentinel divs which are
     * used to mark the beginning and the end of the tabbable region. When
     * focused, these sentinel elements redirect focus to the first/last
     * children elements of the tabbable region, ensuring that focus is trapped
     * within that region.
     */
    FocusTrap.prototype.wrapTabFocus = function (el, focusableEls) {
        var sentinelStart = this.createSentinel();
        var sentinelEnd = this.createSentinel();
        sentinelStart.addEventListener('focus', function () {
            if (focusableEls.length > 0) {
                focusableEls[focusableEls.length - 1].focus();
            }
        });
        sentinelEnd.addEventListener('focus', function () {
            if (focusableEls.length > 0) {
                focusableEls[0].focus();
            }
        });
        el.insertBefore(sentinelStart, el.children[0]);
        el.appendChild(sentinelEnd);
    };
    /**
     * Focuses on `initialFocusEl` if defined and a child of the root element.
     * Otherwise, focuses on the first focusable child element of the root.
     */
    FocusTrap.prototype.focusInitialElement = function (focusableEls, initialFocusEl) {
        var focusIndex = 0;
        if (initialFocusEl) {
            focusIndex = Math.max(focusableEls.indexOf(initialFocusEl), 0);
        }
        focusableEls[focusIndex].focus();
    };
    FocusTrap.prototype.getFocusableElements = function (root) {
        var focusableEls = [].slice.call(root.querySelectorAll('[autofocus], [tabindex], a, input, textarea, select, button'));
        return focusableEls.filter(function (el) {
            var isDisabledOrHidden = el.getAttribute('aria-disabled') === 'true' || el.getAttribute('disabled') != null || el.getAttribute('hidden') != null || el.getAttribute('aria-hidden') === 'true';
            var isTabbableAndVisible = el.tabIndex >= 0 && el.getBoundingClientRect().width > 0 && !el.classList.contains(FOCUS_SENTINEL_CLASS) && !isDisabledOrHidden;
            var isProgrammaticallyHidden = false;
            if (isTabbableAndVisible) {
                var style = getComputedStyle(el);
                isProgrammaticallyHidden = style.display === 'none' || style.visibility === 'hidden';
            }
            return isTabbableAndVisible && !isProgrammaticallyHidden;
        });
    };
    FocusTrap.prototype.createSentinel = function () {
        var sentinel = document.createElement('div');
        sentinel.setAttribute('tabindex', '0');
        // Don't announce in screen readers.
        sentinel.setAttribute('aria-hidden', 'true');
        sentinel.classList.add(FOCUS_SENTINEL_CLASS);
        return sentinel;
    };
    return FocusTrap;
}();
exports.FocusTrap = FocusTrap;

/***/ }),

/***/ "./packages/mdc-dom/index.ts":
/*!***********************************!*\
  !*** ./packages/mdc-dom/index.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }result["default"] = mod;
  return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var events = __importStar(__webpack_require__(/*! ./events */ "./packages/mdc-dom/events.ts"));
exports.events = events;
var focusTrap = __importStar(__webpack_require__(/*! ./focus-trap */ "./packages/mdc-dom/focus-trap.ts"));
exports.focusTrap = focusTrap;
var keyboard = __importStar(__webpack_require__(/*! ./keyboard */ "./packages/mdc-dom/keyboard.ts"));
exports.keyboard = keyboard;
var ponyfill = __importStar(__webpack_require__(/*! ./ponyfill */ "./packages/mdc-dom/ponyfill.ts"));
exports.ponyfill = ponyfill;

/***/ }),

/***/ "./packages/mdc-dom/keyboard.ts":
/*!**************************************!*\
  !*** ./packages/mdc-dom/keyboard.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * KEY provides normalized string values for keys.
 */
exports.KEY = {
    UNKNOWN: 'Unknown',
    BACKSPACE: 'Backspace',
    ENTER: 'Enter',
    SPACEBAR: 'Spacebar',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown',
    END: 'End',
    HOME: 'Home',
    ARROW_LEFT: 'ArrowLeft',
    ARROW_UP: 'ArrowUp',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_DOWN: 'ArrowDown',
    DELETE: 'Delete'
};
var normalizedKeys = new Set();
// IE11 has no support for new Map with iterable so we need to initialize this
// by hand.
normalizedKeys.add(exports.KEY.BACKSPACE);
normalizedKeys.add(exports.KEY.ENTER);
normalizedKeys.add(exports.KEY.SPACEBAR);
normalizedKeys.add(exports.KEY.PAGE_UP);
normalizedKeys.add(exports.KEY.PAGE_DOWN);
normalizedKeys.add(exports.KEY.END);
normalizedKeys.add(exports.KEY.HOME);
normalizedKeys.add(exports.KEY.ARROW_LEFT);
normalizedKeys.add(exports.KEY.ARROW_UP);
normalizedKeys.add(exports.KEY.ARROW_RIGHT);
normalizedKeys.add(exports.KEY.ARROW_DOWN);
normalizedKeys.add(exports.KEY.DELETE);
var KEY_CODE = {
    BACKSPACE: 8,
    ENTER: 13,
    SPACEBAR: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    ARROW_LEFT: 37,
    ARROW_UP: 38,
    ARROW_RIGHT: 39,
    ARROW_DOWN: 40,
    DELETE: 46
};
var mappedKeyCodes = new Map();
// IE11 has no support for new Map with iterable so we need to initialize this
// by hand.
mappedKeyCodes.set(KEY_CODE.BACKSPACE, exports.KEY.BACKSPACE);
mappedKeyCodes.set(KEY_CODE.ENTER, exports.KEY.ENTER);
mappedKeyCodes.set(KEY_CODE.SPACEBAR, exports.KEY.SPACEBAR);
mappedKeyCodes.set(KEY_CODE.PAGE_UP, exports.KEY.PAGE_UP);
mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, exports.KEY.PAGE_DOWN);
mappedKeyCodes.set(KEY_CODE.END, exports.KEY.END);
mappedKeyCodes.set(KEY_CODE.HOME, exports.KEY.HOME);
mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, exports.KEY.ARROW_LEFT);
mappedKeyCodes.set(KEY_CODE.ARROW_UP, exports.KEY.ARROW_UP);
mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, exports.KEY.ARROW_RIGHT);
mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, exports.KEY.ARROW_DOWN);
mappedKeyCodes.set(KEY_CODE.DELETE, exports.KEY.DELETE);
var navigationKeys = new Set();
// IE11 has no support for new Set with iterable so we need to initialize this
// by hand.
navigationKeys.add(exports.KEY.PAGE_UP);
navigationKeys.add(exports.KEY.PAGE_DOWN);
navigationKeys.add(exports.KEY.END);
navigationKeys.add(exports.KEY.HOME);
navigationKeys.add(exports.KEY.ARROW_LEFT);
navigationKeys.add(exports.KEY.ARROW_UP);
navigationKeys.add(exports.KEY.ARROW_RIGHT);
navigationKeys.add(exports.KEY.ARROW_DOWN);
/**
 * normalizeKey returns the normalized string for a navigational action.
 */
function normalizeKey(evt) {
    var key = evt.key;
    // If the event already has a normalized key, return it
    if (normalizedKeys.has(key)) {
        return key;
    }
    // tslint:disable-next-line:deprecation
    var mappedKey = mappedKeyCodes.get(evt.keyCode);
    if (mappedKey) {
        return mappedKey;
    }
    return exports.KEY.UNKNOWN;
}
exports.normalizeKey = normalizeKey;
/**
 * isNavigationEvent returns whether the event is a navigation event
 */
function isNavigationEvent(evt) {
    return navigationKeys.has(normalizeKey(evt));
}
exports.isNavigationEvent = isNavigationEvent;

/***/ }),

/***/ "./packages/mdc-dom/ponyfill.ts":
/*!**************************************!*\
  !*** ./packages/mdc-dom/ponyfill.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
 * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
 */
function closest(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
    var el = element;
    while (el) {
        if (matches(el, selector)) {
            return el;
        }
        el = el.parentElement;
    }
    return null;
}
exports.closest = closest;
function matches(element, selector) {
    var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
    return nativeMatches.call(element, selector);
}
exports.matches = matches;
/**
 * Used to compute the estimated scroll width of elements. When an element is
 * hidden due to display: none; being applied to a parent element, the width is
 * returned as 0. However, the element will have a true width once no longer
 * inside a display: none context. This method computes an estimated width when
 * the element is hidden or returns the true width when the element is visble.
 * @param {Element} element the element whose width to estimate
 */
function estimateScrollWidth(element) {
    // Check the offsetParent. If the element inherits display: none from any
    // parent, the offsetParent property will be null (see
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).
    // This check ensures we only clone the node when necessary.
    var htmlEl = element;
    if (htmlEl.offsetParent !== null) {
        return htmlEl.scrollWidth;
    }
    var clone = htmlEl.cloneNode(true);
    clone.style.setProperty('position', 'absolute');
    clone.style.setProperty('transform', 'translate(-9999px, -9999px)');
    document.documentElement.appendChild(clone);
    var scrollWidth = clone.scrollWidth;
    document.documentElement.removeChild(clone);
    return scrollWidth;
}
exports.estimateScrollWidth = estimateScrollWidth;

/***/ }),

/***/ "./packages/mdc-drawer/component.ts":
/*!******************************************!*\
  !*** ./packages/mdc-drawer/component.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var focus_trap_1 = __webpack_require__(/*! @material/dom/focus-trap */ "./packages/mdc-dom/focus-trap.ts");
var component_2 = __webpack_require__(/*! @material/list/component */ "./packages/mdc-list/component.ts");
var foundation_1 = __webpack_require__(/*! @material/list/foundation */ "./packages/mdc-list/foundation.ts");
var foundation_2 = __webpack_require__(/*! ./dismissible/foundation */ "./packages/mdc-drawer/dismissible/foundation.ts");
var foundation_3 = __webpack_require__(/*! ./modal/foundation */ "./packages/mdc-drawer/modal/foundation.ts");
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-drawer/util.ts"));
var cssClasses = foundation_2.MDCDismissibleDrawerFoundation.cssClasses,
    strings = foundation_2.MDCDismissibleDrawerFoundation.strings;
/**
 * @events `MDCDrawer:closed {}` Emits when the navigation drawer has closed.
 * @events `MDCDrawer:opened {}` Emits when the navigation drawer has opened.
 */
var MDCDrawer = /** @class */function (_super) {
    __extends(MDCDrawer, _super);
    function MDCDrawer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCDrawer.attachTo = function (root) {
        return new MDCDrawer(root);
    };
    Object.defineProperty(MDCDrawer.prototype, "open", {
        /**
         * @return boolean Proxies to the foundation's `open`/`close` methods.
         * Also returns true if drawer is in the open position.
         */
        get: function get() {
            return this.foundation_.isOpen();
        },
        /**
         * Toggles the drawer open and closed.
         */
        set: function set(isOpen) {
            if (isOpen) {
                this.foundation_.open();
            } else {
                this.foundation_.close();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDrawer.prototype, "list", {
        get: function get() {
            return this.list_;
        },
        enumerable: true,
        configurable: true
    });
    MDCDrawer.prototype.initialize = function (focusTrapFactory, listFactory) {
        if (focusTrapFactory === void 0) {
            focusTrapFactory = function focusTrapFactory(el) {
                return new focus_trap_1.FocusTrap(el);
            };
        }
        if (listFactory === void 0) {
            listFactory = function listFactory(el) {
                return new component_2.MDCList(el);
            };
        }
        var listEl = this.root_.querySelector("." + foundation_1.MDCListFoundation.cssClasses.ROOT);
        if (listEl) {
            this.list_ = listFactory(listEl);
            this.list_.wrapFocus = true;
        }
        this.focusTrapFactory_ = focusTrapFactory;
    };
    MDCDrawer.prototype.initialSyncWithDOM = function () {
        var _this = this;
        var MODAL = cssClasses.MODAL;
        var SCRIM_SELECTOR = strings.SCRIM_SELECTOR;
        this.scrim_ = this.root_.parentNode.querySelector(SCRIM_SELECTOR);
        if (this.scrim_ && this.root_.classList.contains(MODAL)) {
            this.handleScrimClick_ = function () {
                return _this.foundation_.handleScrimClick();
            };
            this.scrim_.addEventListener('click', this.handleScrimClick_);
            this.focusTrap_ = util.createFocusTrapInstance(this.root_, this.focusTrapFactory_);
        }
        this.handleKeydown_ = function (evt) {
            return _this.foundation_.handleKeydown(evt);
        };
        this.handleTransitionEnd_ = function (evt) {
            return _this.foundation_.handleTransitionEnd(evt);
        };
        this.listen('keydown', this.handleKeydown_);
        this.listen('transitionend', this.handleTransitionEnd_);
    };
    MDCDrawer.prototype.destroy = function () {
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten('transitionend', this.handleTransitionEnd_);
        if (this.list_) {
            this.list_.destroy();
        }
        var MODAL = cssClasses.MODAL;
        if (this.scrim_ && this.handleScrimClick_ && this.root_.classList.contains(MODAL)) {
            this.scrim_.removeEventListener('click', this.handleScrimClick_);
            // Ensure drawer is closed to hide scrim and release focus
            this.open = false;
        }
    };
    MDCDrawer.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            elementHasClass: function elementHasClass(element, className) {
                return element.classList.contains(className);
            },
            saveFocus: function saveFocus() {
                return _this.previousFocus_ = document.activeElement;
            },
            restoreFocus: function restoreFocus() {
                var previousFocus = _this.previousFocus_;
                if (previousFocus && previousFocus.focus && _this.root_.contains(document.activeElement)) {
                    previousFocus.focus();
                }
            },
            focusActiveNavigationItem: function focusActiveNavigationItem() {
                var activeNavItemEl = _this.root_.querySelector("." + foundation_1.MDCListFoundation.cssClasses.LIST_ITEM_ACTIVATED_CLASS);
                if (activeNavItemEl) {
                    activeNavItemEl.focus();
                }
            },
            notifyClose: function notifyClose() {
                return _this.emit(strings.CLOSE_EVENT, {}, true /* shouldBubble */);
            },
            notifyOpen: function notifyOpen() {
                return _this.emit(strings.OPEN_EVENT, {}, true /* shouldBubble */);
            },
            trapFocus: function trapFocus() {
                return _this.focusTrap_.trapFocus();
            },
            releaseFocus: function releaseFocus() {
                return _this.focusTrap_.releaseFocus();
            }
        };
        // tslint:enable:object-literal-sort-keys
        var DISMISSIBLE = cssClasses.DISMISSIBLE,
            MODAL = cssClasses.MODAL;
        if (this.root_.classList.contains(DISMISSIBLE)) {
            return new foundation_2.MDCDismissibleDrawerFoundation(adapter);
        } else if (this.root_.classList.contains(MODAL)) {
            return new foundation_3.MDCModalDrawerFoundation(adapter);
        } else {
            throw new Error("MDCDrawer: Failed to instantiate component. Supported variants are " + DISMISSIBLE + " and " + MODAL + ".");
        }
    };
    return MDCDrawer;
}(component_1.MDCComponent);
exports.MDCDrawer = MDCDrawer;

/***/ }),

/***/ "./packages/mdc-drawer/constants.ts":
/*!******************************************!*\
  !*** ./packages/mdc-drawer/constants.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    ANIMATE: 'mdc-drawer--animate',
    CLOSING: 'mdc-drawer--closing',
    DISMISSIBLE: 'mdc-drawer--dismissible',
    MODAL: 'mdc-drawer--modal',
    OPEN: 'mdc-drawer--open',
    OPENING: 'mdc-drawer--opening',
    ROOT: 'mdc-drawer'
};
exports.cssClasses = cssClasses;
var strings = {
    APP_CONTENT_SELECTOR: '.mdc-drawer-app-content',
    CLOSE_EVENT: 'MDCDrawer:closed',
    OPEN_EVENT: 'MDCDrawer:opened',
    SCRIM_SELECTOR: '.mdc-drawer-scrim'
};
exports.strings = strings;

/***/ }),

/***/ "./packages/mdc-drawer/dismissible/foundation.ts":
/*!*******************************************************!*\
  !*** ./packages/mdc-drawer/dismissible/foundation.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./packages/mdc-drawer/constants.ts");
var MDCDismissibleDrawerFoundation = /** @class */function (_super) {
    __extends(MDCDismissibleDrawerFoundation, _super);
    function MDCDismissibleDrawerFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCDismissibleDrawerFoundation.defaultAdapter), adapter)) || this;
        _this.animationFrame_ = 0;
        _this.animationTimer_ = 0;
        return _this;
    }
    Object.defineProperty(MDCDismissibleDrawerFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDismissibleDrawerFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDismissibleDrawerFoundation, "defaultAdapter", {
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return false;
                },
                elementHasClass: function elementHasClass() {
                    return false;
                },
                notifyClose: function notifyClose() {
                    return undefined;
                },
                notifyOpen: function notifyOpen() {
                    return undefined;
                },
                saveFocus: function saveFocus() {
                    return undefined;
                },
                restoreFocus: function restoreFocus() {
                    return undefined;
                },
                focusActiveNavigationItem: function focusActiveNavigationItem() {
                    return undefined;
                },
                trapFocus: function trapFocus() {
                    return undefined;
                },
                releaseFocus: function releaseFocus() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCDismissibleDrawerFoundation.prototype.destroy = function () {
        if (this.animationFrame_) {
            cancelAnimationFrame(this.animationFrame_);
        }
        if (this.animationTimer_) {
            clearTimeout(this.animationTimer_);
        }
    };
    /**
     * Opens the drawer from the closed state.
     */
    MDCDismissibleDrawerFoundation.prototype.open = function () {
        var _this = this;
        if (this.isOpen() || this.isOpening() || this.isClosing()) {
            return;
        }
        this.adapter_.addClass(constants_1.cssClasses.OPEN);
        this.adapter_.addClass(constants_1.cssClasses.ANIMATE);
        // Wait a frame once display is no longer "none", to establish basis for animation
        this.runNextAnimationFrame_(function () {
            _this.adapter_.addClass(constants_1.cssClasses.OPENING);
        });
        this.adapter_.saveFocus();
    };
    /**
     * Closes the drawer from the open state.
     */
    MDCDismissibleDrawerFoundation.prototype.close = function () {
        if (!this.isOpen() || this.isOpening() || this.isClosing()) {
            return;
        }
        this.adapter_.addClass(constants_1.cssClasses.CLOSING);
    };
    /**
     * Returns true if the drawer is in the open position.
     * @return true if drawer is in open state.
     */
    MDCDismissibleDrawerFoundation.prototype.isOpen = function () {
        return this.adapter_.hasClass(constants_1.cssClasses.OPEN);
    };
    /**
     * Returns true if the drawer is animating open.
     * @return true if drawer is animating open.
     */
    MDCDismissibleDrawerFoundation.prototype.isOpening = function () {
        return this.adapter_.hasClass(constants_1.cssClasses.OPENING) || this.adapter_.hasClass(constants_1.cssClasses.ANIMATE);
    };
    /**
     * Returns true if the drawer is animating closed.
     * @return true if drawer is animating closed.
     */
    MDCDismissibleDrawerFoundation.prototype.isClosing = function () {
        return this.adapter_.hasClass(constants_1.cssClasses.CLOSING);
    };
    /**
     * Keydown handler to close drawer when key is escape.
     */
    MDCDismissibleDrawerFoundation.prototype.handleKeydown = function (evt) {
        var keyCode = evt.keyCode,
            key = evt.key;
        var isEscape = key === 'Escape' || keyCode === 27;
        if (isEscape) {
            this.close();
        }
    };
    /**
     * Handles the `transitionend` event when the drawer finishes opening/closing.
     */
    MDCDismissibleDrawerFoundation.prototype.handleTransitionEnd = function (evt) {
        var OPENING = constants_1.cssClasses.OPENING,
            CLOSING = constants_1.cssClasses.CLOSING,
            OPEN = constants_1.cssClasses.OPEN,
            ANIMATE = constants_1.cssClasses.ANIMATE,
            ROOT = constants_1.cssClasses.ROOT;
        // In Edge, transitionend on ripple pseudo-elements yields a target without classList, so check for Element first.
        var isRootElement = this.isElement_(evt.target) && this.adapter_.elementHasClass(evt.target, ROOT);
        if (!isRootElement) {
            return;
        }
        if (this.isClosing()) {
            this.adapter_.removeClass(OPEN);
            this.closed_();
            this.adapter_.restoreFocus();
            this.adapter_.notifyClose();
        } else {
            this.adapter_.focusActiveNavigationItem();
            this.opened_();
            this.adapter_.notifyOpen();
        }
        this.adapter_.removeClass(ANIMATE);
        this.adapter_.removeClass(OPENING);
        this.adapter_.removeClass(CLOSING);
    };
    /**
     * Extension point for when drawer finishes open animation.
     */
    MDCDismissibleDrawerFoundation.prototype.opened_ = function () {}; // tslint:disable-line:no-empty
    /**
     * Extension point for when drawer finishes close animation.
     */
    MDCDismissibleDrawerFoundation.prototype.closed_ = function () {}; // tslint:disable-line:no-empty
    /**
     * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
     */
    MDCDismissibleDrawerFoundation.prototype.runNextAnimationFrame_ = function (callback) {
        var _this = this;
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = requestAnimationFrame(function () {
            _this.animationFrame_ = 0;
            clearTimeout(_this.animationTimer_);
            _this.animationTimer_ = setTimeout(callback, 0);
        });
    };
    MDCDismissibleDrawerFoundation.prototype.isElement_ = function (element) {
        // In Edge, transitionend on ripple pseudo-elements yields a target without classList.
        return Boolean(element.classList);
    };
    return MDCDismissibleDrawerFoundation;
}(foundation_1.MDCFoundation);
exports.MDCDismissibleDrawerFoundation = MDCDismissibleDrawerFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCDismissibleDrawerFoundation;

/***/ }),

/***/ "./packages/mdc-drawer/index.ts":
/*!**************************************!*\
  !*** ./packages/mdc-drawer/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-drawer/util.ts"));
exports.util = util;
__export(__webpack_require__(/*! ./component */ "./packages/mdc-drawer/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-drawer/constants.ts"));
__export(__webpack_require__(/*! ./dismissible/foundation */ "./packages/mdc-drawer/dismissible/foundation.ts"));
__export(__webpack_require__(/*! ./modal/foundation */ "./packages/mdc-drawer/modal/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-drawer/modal/foundation.ts":
/*!*************************************************!*\
  !*** ./packages/mdc-drawer/modal/foundation.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! ../dismissible/foundation */ "./packages/mdc-drawer/dismissible/foundation.ts");
/* istanbul ignore next: subclass is not a branch statement */
var MDCModalDrawerFoundation = /** @class */function (_super) {
    __extends(MDCModalDrawerFoundation, _super);
    function MDCModalDrawerFoundation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Handles click event on scrim.
     */
    MDCModalDrawerFoundation.prototype.handleScrimClick = function () {
        this.close();
    };
    /**
     * Called when drawer finishes open animation.
     */
    MDCModalDrawerFoundation.prototype.opened_ = function () {
        this.adapter_.trapFocus();
    };
    /**
     * Called when drawer finishes close animation.
     */
    MDCModalDrawerFoundation.prototype.closed_ = function () {
        this.adapter_.releaseFocus();
    };
    return MDCModalDrawerFoundation;
}(foundation_1.MDCDismissibleDrawerFoundation);
exports.MDCModalDrawerFoundation = MDCModalDrawerFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCModalDrawerFoundation;

/***/ }),

/***/ "./packages/mdc-drawer/util.ts":
/*!*************************************!*\
  !*** ./packages/mdc-drawer/util.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
function createFocusTrapInstance(surfaceEl, focusTrapFactory) {
    return focusTrapFactory(surfaceEl, {
        // Component handles focusing on active nav item.
        skipInitialFocus: true
    });
}
exports.createFocusTrapInstance = createFocusTrapInstance;

/***/ }),

/***/ "./packages/mdc-floating-label/component.ts":
/*!**************************************************!*\
  !*** ./packages/mdc-floating-label/component.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-floating-label/foundation.ts");
var MDCFloatingLabel = /** @class */function (_super) {
    __extends(MDCFloatingLabel, _super);
    function MDCFloatingLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCFloatingLabel.attachTo = function (root) {
        return new MDCFloatingLabel(root);
    };
    /**
     * Styles the label to produce the label shake for errors.
     * @param shouldShake If true, shakes the label by adding a CSS class; otherwise, stops shaking by removing the class.
     */
    MDCFloatingLabel.prototype.shake = function (shouldShake) {
        this.foundation_.shake(shouldShake);
    };
    /**
     * Styles the label to float/dock.
     * @param shouldFloat If true, floats the label by adding a CSS class; otherwise, docks it by removing the class.
     */
    MDCFloatingLabel.prototype.float = function (shouldFloat) {
        this.foundation_.float(shouldFloat);
    };
    MDCFloatingLabel.prototype.getWidth = function () {
        return this.foundation_.getWidth();
    };
    MDCFloatingLabel.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            getWidth: function getWidth() {
                return ponyfill_1.estimateScrollWidth(_this.root_);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                return _this.listen(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                return _this.unlisten(evtType, handler);
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_1.MDCFloatingLabelFoundation(adapter);
    };
    return MDCFloatingLabel;
}(component_1.MDCComponent);
exports.MDCFloatingLabel = MDCFloatingLabel;

/***/ }),

/***/ "./packages/mdc-floating-label/constants.ts":
/*!**************************************************!*\
  !*** ./packages/mdc-floating-label/constants.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.cssClasses = {
  LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
  LABEL_SHAKE: 'mdc-floating-label--shake',
  ROOT: 'mdc-floating-label'
};

/***/ }),

/***/ "./packages/mdc-floating-label/foundation.ts":
/*!***************************************************!*\
  !*** ./packages/mdc-floating-label/foundation.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-floating-label/constants.ts");
var MDCFloatingLabelFoundation = /** @class */function (_super) {
    __extends(MDCFloatingLabelFoundation, _super);
    function MDCFloatingLabelFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCFloatingLabelFoundation.defaultAdapter), adapter)) || this;
        _this.shakeAnimationEndHandler_ = function () {
            return _this.handleShakeAnimationEnd_();
        };
        return _this;
    }
    Object.defineProperty(MDCFloatingLabelFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFloatingLabelFoundation, "defaultAdapter", {
        /**
         * See {@link MDCFloatingLabelAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                getWidth: function getWidth() {
                    return 0;
                },
                registerInteractionHandler: function registerInteractionHandler() {
                    return undefined;
                },
                deregisterInteractionHandler: function deregisterInteractionHandler() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCFloatingLabelFoundation.prototype.init = function () {
        this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
    };
    MDCFloatingLabelFoundation.prototype.destroy = function () {
        this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
    };
    /**
     * Returns the width of the label element.
     */
    MDCFloatingLabelFoundation.prototype.getWidth = function () {
        return this.adapter_.getWidth();
    };
    /**
     * Styles the label to produce a shake animation to indicate an error.
     * @param shouldShake If true, adds the shake CSS class; otherwise, removes shake class.
     */
    MDCFloatingLabelFoundation.prototype.shake = function (shouldShake) {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
        if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
        } else {
            this.adapter_.removeClass(LABEL_SHAKE);
        }
    };
    /**
     * Styles the label to float or dock.
     * @param shouldFloat If true, adds the float CSS class; otherwise, removes float and shake classes to dock the label.
     */
    MDCFloatingLabelFoundation.prototype.float = function (shouldFloat) {
        var _a = MDCFloatingLabelFoundation.cssClasses,
            LABEL_FLOAT_ABOVE = _a.LABEL_FLOAT_ABOVE,
            LABEL_SHAKE = _a.LABEL_SHAKE;
        if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
        } else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
        }
    };
    MDCFloatingLabelFoundation.prototype.handleShakeAnimationEnd_ = function () {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
        this.adapter_.removeClass(LABEL_SHAKE);
    };
    return MDCFloatingLabelFoundation;
}(foundation_1.MDCFoundation);
exports.MDCFloatingLabelFoundation = MDCFloatingLabelFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCFloatingLabelFoundation;

/***/ }),

/***/ "./packages/mdc-floating-label/index.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-floating-label/index.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-floating-label/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-floating-label/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-floating-label/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-form-field/component.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-form-field/component.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-form-field/foundation.ts");
var MDCFormField = /** @class */function (_super) {
    __extends(MDCFormField, _super);
    function MDCFormField() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCFormField.attachTo = function (root) {
        return new MDCFormField(root);
    };
    Object.defineProperty(MDCFormField.prototype, "input", {
        get: function get() {
            return this.input_;
        },
        set: function set(input) {
            this.input_ = input;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFormField.prototype, "label_", {
        get: function get() {
            var LABEL_SELECTOR = foundation_1.MDCFormFieldFoundation.strings.LABEL_SELECTOR;
            return this.root_.querySelector(LABEL_SELECTOR);
        },
        enumerable: true,
        configurable: true
    });
    MDCFormField.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            activateInputRipple: function activateInputRipple() {
                if (_this.input_ && _this.input_.ripple) {
                    _this.input_.ripple.activate();
                }
            },
            deactivateInputRipple: function deactivateInputRipple() {
                if (_this.input_ && _this.input_.ripple) {
                    _this.input_.ripple.deactivate();
                }
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                if (_this.label_) {
                    _this.label_.removeEventListener(evtType, handler);
                }
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                if (_this.label_) {
                    _this.label_.addEventListener(evtType, handler);
                }
            }
        };
        return new foundation_1.MDCFormFieldFoundation(adapter);
    };
    return MDCFormField;
}(component_1.MDCComponent);
exports.MDCFormField = MDCFormField;

/***/ }),

/***/ "./packages/mdc-form-field/constants.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-form-field/constants.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.cssClasses = {
    ROOT: 'mdc-form-field'
};
exports.strings = {
    LABEL_SELECTOR: '.mdc-form-field > label'
};

/***/ }),

/***/ "./packages/mdc-form-field/foundation.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-form-field/foundation.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-form-field/constants.ts");
var MDCFormFieldFoundation = /** @class */function (_super) {
    __extends(MDCFormFieldFoundation, _super);
    function MDCFormFieldFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCFormFieldFoundation.defaultAdapter), adapter)) || this;
        _this.clickHandler_ = function () {
            return _this.handleClick_();
        };
        return _this;
    }
    Object.defineProperty(MDCFormFieldFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation, "defaultAdapter", {
        get: function get() {
            return {
                activateInputRipple: function activateInputRipple() {
                    return undefined;
                },
                deactivateInputRipple: function deactivateInputRipple() {
                    return undefined;
                },
                deregisterInteractionHandler: function deregisterInteractionHandler() {
                    return undefined;
                },
                registerInteractionHandler: function registerInteractionHandler() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCFormFieldFoundation.prototype.init = function () {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
    };
    MDCFormFieldFoundation.prototype.destroy = function () {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
    };
    MDCFormFieldFoundation.prototype.handleClick_ = function () {
        var _this = this;
        this.adapter_.activateInputRipple();
        requestAnimationFrame(function () {
            return _this.adapter_.deactivateInputRipple();
        });
    };
    return MDCFormFieldFoundation;
}(foundation_1.MDCFoundation);
exports.MDCFormFieldFoundation = MDCFormFieldFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCFormFieldFoundation;

/***/ }),

/***/ "./packages/mdc-form-field/index.ts":
/*!******************************************!*\
  !*** ./packages/mdc-form-field/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-form-field/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-form-field/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-form-field/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-icon-button/component.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-icon-button/component.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var component_2 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-icon-button/foundation.ts");
var strings = foundation_1.MDCIconButtonToggleFoundation.strings;
var MDCIconButtonToggle = /** @class */function (_super) {
    __extends(MDCIconButtonToggle, _super);
    function MDCIconButtonToggle() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ripple_ = _this.createRipple_();
        return _this;
    }
    MDCIconButtonToggle.attachTo = function (root) {
        return new MDCIconButtonToggle(root);
    };
    MDCIconButtonToggle.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleClick_ = function () {
            return _this.foundation_.handleClick();
        };
        this.listen('click', this.handleClick_);
    };
    MDCIconButtonToggle.prototype.destroy = function () {
        this.unlisten('click', this.handleClick_);
        this.ripple_.destroy();
        _super.prototype.destroy.call(this);
    };
    MDCIconButtonToggle.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            notifyChange: function notifyChange(evtData) {
                _this.emit(strings.CHANGE_EVENT, evtData);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            getAttr: function getAttr(attrName) {
                return _this.root_.getAttribute(attrName);
            },
            setAttr: function setAttr(attrName, attrValue) {
                return _this.root_.setAttribute(attrName, attrValue);
            }
        };
        return new foundation_1.MDCIconButtonToggleFoundation(adapter);
    };
    Object.defineProperty(MDCIconButtonToggle.prototype, "ripple", {
        get: function get() {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCIconButtonToggle.prototype, "on", {
        get: function get() {
            return this.foundation_.isOn();
        },
        set: function set(isOn) {
            this.foundation_.toggle(isOn);
        },
        enumerable: true,
        configurable: true
    });
    MDCIconButtonToggle.prototype.createRipple_ = function () {
        var ripple = new component_2.MDCRipple(this.root_);
        ripple.unbounded = true;
        return ripple;
    };
    return MDCIconButtonToggle;
}(component_1.MDCComponent);
exports.MDCIconButtonToggle = MDCIconButtonToggle;

/***/ }),

/***/ "./packages/mdc-icon-button/constants.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-icon-button/constants.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.cssClasses = {
    ICON_BUTTON_ON: 'mdc-icon-button--on',
    ROOT: 'mdc-icon-button'
};
exports.strings = {
    ARIA_LABEL: 'aria-label',
    ARIA_PRESSED: 'aria-pressed',
    DATA_ARIA_LABEL_OFF: 'data-aria-label-off',
    DATA_ARIA_LABEL_ON: 'data-aria-label-on',
    CHANGE_EVENT: 'MDCIconButtonToggle:change'
};

/***/ }),

/***/ "./packages/mdc-icon-button/foundation.ts":
/*!************************************************!*\
  !*** ./packages/mdc-icon-button/foundation.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-icon-button/constants.ts");
var MDCIconButtonToggleFoundation = /** @class */function (_super) {
    __extends(MDCIconButtonToggleFoundation, _super);
    function MDCIconButtonToggleFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCIconButtonToggleFoundation.defaultAdapter), adapter)) || this;
        /**
         * Whether the icon button has an aria label that changes depending on
         * toggled state.
         */
        _this.hasToggledAriaLabel = false;
        return _this;
    }
    Object.defineProperty(MDCIconButtonToggleFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCIconButtonToggleFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCIconButtonToggleFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return false;
                },
                notifyChange: function notifyChange() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                getAttr: function getAttr() {
                    return null;
                },
                setAttr: function setAttr() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCIconButtonToggleFoundation.prototype.init = function () {
        var ariaLabelOn = this.adapter_.getAttr(constants_1.strings.DATA_ARIA_LABEL_ON);
        var ariaLabelOff = this.adapter_.getAttr(constants_1.strings.DATA_ARIA_LABEL_OFF);
        if (ariaLabelOn && ariaLabelOff) {
            if (this.adapter_.getAttr(constants_1.strings.ARIA_PRESSED) !== null) {
                throw new Error('MDCIconButtonToggleFoundation: Button should not set ' + '`aria-pressed` if it has a toggled aria label.');
            }
            this.hasToggledAriaLabel = true;
        } else {
            this.adapter_.setAttr(constants_1.strings.ARIA_PRESSED, String(this.isOn()));
        }
    };
    MDCIconButtonToggleFoundation.prototype.handleClick = function () {
        this.toggle();
        this.adapter_.notifyChange({ isOn: this.isOn() });
    };
    MDCIconButtonToggleFoundation.prototype.isOn = function () {
        return this.adapter_.hasClass(constants_1.cssClasses.ICON_BUTTON_ON);
    };
    MDCIconButtonToggleFoundation.prototype.toggle = function (isOn) {
        if (isOn === void 0) {
            isOn = !this.isOn();
        }
        // Toggle UI based on state.
        if (isOn) {
            this.adapter_.addClass(constants_1.cssClasses.ICON_BUTTON_ON);
        } else {
            this.adapter_.removeClass(constants_1.cssClasses.ICON_BUTTON_ON);
        }
        // Toggle aria attributes based on state.
        if (this.hasToggledAriaLabel) {
            var ariaLabel = isOn ? this.adapter_.getAttr(constants_1.strings.DATA_ARIA_LABEL_ON) : this.adapter_.getAttr(constants_1.strings.DATA_ARIA_LABEL_OFF);
            this.adapter_.setAttr(constants_1.strings.ARIA_LABEL, ariaLabel || '');
        } else {
            this.adapter_.setAttr(constants_1.strings.ARIA_PRESSED, "" + isOn);
        }
    };
    return MDCIconButtonToggleFoundation;
}(foundation_1.MDCFoundation);
exports.MDCIconButtonToggleFoundation = MDCIconButtonToggleFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCIconButtonToggleFoundation;

/***/ }),

/***/ "./packages/mdc-icon-button/index.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-icon-button/index.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-icon-button/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-icon-button/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-icon-button/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-line-ripple/component.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-line-ripple/component.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-line-ripple/foundation.ts");
var MDCLineRipple = /** @class */function (_super) {
    __extends(MDCLineRipple, _super);
    function MDCLineRipple() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCLineRipple.attachTo = function (root) {
        return new MDCLineRipple(root);
    };
    /**
     * Activates the line ripple
     */
    MDCLineRipple.prototype.activate = function () {
        this.foundation_.activate();
    };
    /**
     * Deactivates the line ripple
     */
    MDCLineRipple.prototype.deactivate = function () {
        this.foundation_.deactivate();
    };
    /**
     * Sets the transform origin given a user's click location.
     * The `rippleCenter` is the x-coordinate of the middle of the ripple.
     */
    MDCLineRipple.prototype.setRippleCenter = function (xCoordinate) {
        this.foundation_.setRippleCenter(xCoordinate);
    };
    MDCLineRipple.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            setStyle: function setStyle(propertyName, value) {
                return _this.root_.style.setProperty(propertyName, value);
            },
            registerEventHandler: function registerEventHandler(evtType, handler) {
                return _this.listen(evtType, handler);
            },
            deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
                return _this.unlisten(evtType, handler);
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_1.MDCLineRippleFoundation(adapter);
    };
    return MDCLineRipple;
}(component_1.MDCComponent);
exports.MDCLineRipple = MDCLineRipple;

/***/ }),

/***/ "./packages/mdc-line-ripple/constants.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-line-ripple/constants.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
  LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
  LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
};
exports.cssClasses = cssClasses;

/***/ }),

/***/ "./packages/mdc-line-ripple/foundation.ts":
/*!************************************************!*\
  !*** ./packages/mdc-line-ripple/foundation.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-line-ripple/constants.ts");
var MDCLineRippleFoundation = /** @class */function (_super) {
    __extends(MDCLineRippleFoundation, _super);
    function MDCLineRippleFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCLineRippleFoundation.defaultAdapter), adapter)) || this;
        _this.transitionEndHandler_ = function (evt) {
            return _this.handleTransitionEnd(evt);
        };
        return _this;
    }
    Object.defineProperty(MDCLineRippleFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCLineRippleFoundation, "defaultAdapter", {
        /**
         * See {@link MDCLineRippleAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return false;
                },
                setStyle: function setStyle() {
                    return undefined;
                },
                registerEventHandler: function registerEventHandler() {
                    return undefined;
                },
                deregisterEventHandler: function deregisterEventHandler() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCLineRippleFoundation.prototype.init = function () {
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
    };
    MDCLineRippleFoundation.prototype.destroy = function () {
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
    };
    MDCLineRippleFoundation.prototype.activate = function () {
        this.adapter_.removeClass(constants_1.cssClasses.LINE_RIPPLE_DEACTIVATING);
        this.adapter_.addClass(constants_1.cssClasses.LINE_RIPPLE_ACTIVE);
    };
    MDCLineRippleFoundation.prototype.setRippleCenter = function (xCoordinate) {
        this.adapter_.setStyle('transform-origin', xCoordinate + "px center");
    };
    MDCLineRippleFoundation.prototype.deactivate = function () {
        this.adapter_.addClass(constants_1.cssClasses.LINE_RIPPLE_DEACTIVATING);
    };
    MDCLineRippleFoundation.prototype.handleTransitionEnd = function (evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter_.hasClass(constants_1.cssClasses.LINE_RIPPLE_DEACTIVATING);
        if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
                this.adapter_.removeClass(constants_1.cssClasses.LINE_RIPPLE_ACTIVE);
                this.adapter_.removeClass(constants_1.cssClasses.LINE_RIPPLE_DEACTIVATING);
            }
        }
    };
    return MDCLineRippleFoundation;
}(foundation_1.MDCFoundation);
exports.MDCLineRippleFoundation = MDCLineRippleFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCLineRippleFoundation;

/***/ }),

/***/ "./packages/mdc-line-ripple/index.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-line-ripple/index.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-line-ripple/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-line-ripple/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-line-ripple/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-linear-progress/component.ts":
/*!***************************************************!*\
  !*** ./packages/mdc-linear-progress/component.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-linear-progress/foundation.ts");
var MDCLinearProgress = /** @class */function (_super) {
    __extends(MDCLinearProgress, _super);
    function MDCLinearProgress() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCLinearProgress.attachTo = function (root) {
        return new MDCLinearProgress(root);
    };
    Object.defineProperty(MDCLinearProgress.prototype, "determinate", {
        set: function set(value) {
            this.foundation_.setDeterminate(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCLinearProgress.prototype, "progress", {
        set: function set(value) {
            this.foundation_.setProgress(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCLinearProgress.prototype, "buffer", {
        set: function set(value) {
            this.foundation_.setBuffer(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCLinearProgress.prototype, "reverse", {
        set: function set(value) {
            this.foundation_.setReverse(value);
        },
        enumerable: true,
        configurable: true
    });
    MDCLinearProgress.prototype.open = function () {
        this.foundation_.open();
    };
    MDCLinearProgress.prototype.close = function () {
        this.foundation_.close();
    };
    MDCLinearProgress.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            forceLayout: function forceLayout() {
                return _this.root_.offsetWidth;
            },
            setBufferBarStyle: function setBufferBarStyle(styleProperty, value) {
                _this.root_.querySelector(foundation_1.MDCLinearProgressFoundation.strings.BUFFER_BAR_SELECTOR).style.setProperty(styleProperty, value);
            },
            setPrimaryBarStyle: function setPrimaryBarStyle(styleProperty, value) {
                _this.root_.querySelector(foundation_1.MDCLinearProgressFoundation.strings.PRIMARY_BAR_SELECTOR).style.setProperty(styleProperty, value);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            removeAttribute: function removeAttribute(attributeName) {
                _this.root_.removeAttribute(attributeName);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            setAttribute: function setAttribute(attributeName, value) {
                _this.root_.setAttribute(attributeName, value);
            }
        };
        return new foundation_1.MDCLinearProgressFoundation(adapter);
    };
    return MDCLinearProgress;
}(component_1.MDCComponent);
exports.MDCLinearProgress = MDCLinearProgress;

/***/ }),

/***/ "./packages/mdc-linear-progress/constants.ts":
/*!***************************************************!*\
  !*** ./packages/mdc-linear-progress/constants.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.cssClasses = {
    CLOSED_CLASS: 'mdc-linear-progress--closed',
    INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
    REVERSED_CLASS: 'mdc-linear-progress--reversed'
};
exports.strings = {
    ARIA_VALUENOW: 'aria-valuenow',
    BUFFER_BAR_SELECTOR: '.mdc-linear-progress__buffer-bar',
    FLEX_BASIS: 'flex-basis',
    PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar'
};

/***/ }),

/***/ "./packages/mdc-linear-progress/foundation.ts":
/*!****************************************************!*\
  !*** ./packages/mdc-linear-progress/foundation.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(/*! @material/animation/util */ "./packages/mdc-animation/util.ts");
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-linear-progress/constants.ts");
var MDCLinearProgressFoundation = /** @class */function (_super) {
    __extends(MDCLinearProgressFoundation, _super);
    function MDCLinearProgressFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCLinearProgressFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCLinearProgressFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCLinearProgressFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCLinearProgressFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                forceLayout: function forceLayout() {
                    return undefined;
                },
                setBufferBarStyle: function setBufferBarStyle() {
                    return null;
                },
                setPrimaryBarStyle: function setPrimaryBarStyle() {
                    return null;
                },
                hasClass: function hasClass() {
                    return false;
                },
                removeAttribute: function removeAttribute() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                setAttribute: function setAttribute() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCLinearProgressFoundation.prototype.init = function () {
        this.isDeterminate_ = !this.adapter_.hasClass(constants_1.cssClasses.INDETERMINATE_CLASS);
        this.isReversed_ = this.adapter_.hasClass(constants_1.cssClasses.REVERSED_CLASS);
        this.progress_ = 0;
        this.buffer_ = 1;
    };
    MDCLinearProgressFoundation.prototype.setDeterminate = function (isDeterminate) {
        this.isDeterminate_ = isDeterminate;
        if (this.isDeterminate_) {
            this.adapter_.removeClass(constants_1.cssClasses.INDETERMINATE_CLASS);
            this.adapter_.setAttribute(constants_1.strings.ARIA_VALUENOW, this.progress_.toString());
            this.setPrimaryBarProgress_(this.progress_);
            this.setBufferBarProgress_(this.buffer_);
            return;
        }
        if (this.isReversed_) {
            // Adding/removing REVERSED_CLASS starts a translate animation, while
            // adding INDETERMINATE_CLASS starts a scale animation. Here, we reset
            // the translate animation in order to keep it in sync with the new
            // scale animation that will start from adding INDETERMINATE_CLASS
            // below.
            this.adapter_.removeClass(constants_1.cssClasses.REVERSED_CLASS);
            this.adapter_.forceLayout();
            this.adapter_.addClass(constants_1.cssClasses.REVERSED_CLASS);
        }
        this.adapter_.addClass(constants_1.cssClasses.INDETERMINATE_CLASS);
        this.adapter_.removeAttribute(constants_1.strings.ARIA_VALUENOW);
        this.setPrimaryBarProgress_(1);
        this.setBufferBarProgress_(1);
    };
    MDCLinearProgressFoundation.prototype.isDeterminate = function () {
        return this.isDeterminate_;
    };
    MDCLinearProgressFoundation.prototype.setProgress = function (value) {
        this.progress_ = value;
        if (this.isDeterminate_) {
            this.setPrimaryBarProgress_(value);
            this.adapter_.setAttribute(constants_1.strings.ARIA_VALUENOW, value.toString());
        }
    };
    MDCLinearProgressFoundation.prototype.getProgress = function () {
        return this.progress_;
    };
    MDCLinearProgressFoundation.prototype.setBuffer = function (value) {
        this.buffer_ = value;
        if (this.isDeterminate_) {
            this.setBufferBarProgress_(value);
        }
    };
    MDCLinearProgressFoundation.prototype.setReverse = function (isReversed) {
        this.isReversed_ = isReversed;
        if (!this.isDeterminate_) {
            // Adding INDETERMINATE_CLASS starts a scale animation, while
            // adding/removing REVERSED_CLASS starts a translate animation. Here, we
            // reset the scale animation in order to keep it in sync with the new
            // translate animation that will start from adding/removing REVERSED_CLASS
            // below.
            this.adapter_.removeClass(constants_1.cssClasses.INDETERMINATE_CLASS);
            this.adapter_.forceLayout();
            this.adapter_.addClass(constants_1.cssClasses.INDETERMINATE_CLASS);
        }
        if (this.isReversed_) {
            this.adapter_.addClass(constants_1.cssClasses.REVERSED_CLASS);
            return;
        }
        this.adapter_.removeClass(constants_1.cssClasses.REVERSED_CLASS);
    };
    MDCLinearProgressFoundation.prototype.open = function () {
        this.adapter_.removeClass(constants_1.cssClasses.CLOSED_CLASS);
    };
    MDCLinearProgressFoundation.prototype.close = function () {
        this.adapter_.addClass(constants_1.cssClasses.CLOSED_CLASS);
    };
    MDCLinearProgressFoundation.prototype.setPrimaryBarProgress_ = function (progressValue) {
        var value = "scaleX(" + progressValue + ")";
        // Accessing `window` without a `typeof` check will throw on Node environments.
        var transformProp = typeof window !== 'undefined' ? util_1.getCorrectPropertyName(window, 'transform') : 'transform';
        this.adapter_.setPrimaryBarStyle(transformProp, value);
    };
    MDCLinearProgressFoundation.prototype.setBufferBarProgress_ = function (progressValue) {
        var value = progressValue * 100 + "%";
        this.adapter_.setBufferBarStyle(constants_1.strings.FLEX_BASIS, value);
    };
    return MDCLinearProgressFoundation;
}(foundation_1.MDCFoundation);
exports.MDCLinearProgressFoundation = MDCLinearProgressFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCLinearProgressFoundation;

/***/ }),

/***/ "./packages/mdc-linear-progress/index.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-linear-progress/index.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-linear-progress/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-linear-progress/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-linear-progress/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-list/component.ts":
/*!****************************************!*\
  !*** ./packages/mdc-list/component.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-list/constants.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-list/foundation.ts");
var MDCList = /** @class */function (_super) {
    __extends(MDCList, _super);
    function MDCList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCList.prototype, "vertical", {
        set: function set(value) {
            this.foundation_.setVerticalOrientation(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCList.prototype, "listElements", {
        get: function get() {
            return [].slice.call(this.root_.querySelectorAll("." + constants_1.cssClasses.LIST_ITEM_CLASS));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCList.prototype, "wrapFocus", {
        set: function set(value) {
            this.foundation_.setWrapFocus(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCList.prototype, "singleSelection", {
        set: function set(isSingleSelectionList) {
            this.foundation_.setSingleSelection(isSingleSelectionList);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCList.prototype, "selectedIndex", {
        get: function get() {
            return this.foundation_.getSelectedIndex();
        },
        set: function set(index) {
            this.foundation_.setSelectedIndex(index);
        },
        enumerable: true,
        configurable: true
    });
    MDCList.attachTo = function (root) {
        return new MDCList(root);
    };
    MDCList.prototype.initialSyncWithDOM = function () {
        this.handleClick_ = this.handleClickEvent_.bind(this);
        this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
        this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
        this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
        this.listen('keydown', this.handleKeydown_);
        this.listen('click', this.handleClick_);
        this.listen('focusin', this.focusInEventListener_);
        this.listen('focusout', this.focusOutEventListener_);
        this.layout();
        this.initializeListType();
    };
    MDCList.prototype.destroy = function () {
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten('click', this.handleClick_);
        this.unlisten('focusin', this.focusInEventListener_);
        this.unlisten('focusout', this.focusOutEventListener_);
    };
    MDCList.prototype.layout = function () {
        var direction = this.root_.getAttribute(constants_1.strings.ARIA_ORIENTATION);
        this.vertical = direction !== constants_1.strings.ARIA_ORIENTATION_HORIZONTAL;
        // List items need to have at least tabindex=-1 to be focusable.
        [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])')).forEach(function (el) {
            el.setAttribute('tabindex', '-1');
        });
        // Child button/a elements are not tabbable until the list item is focused.
        [].slice.call(this.root_.querySelectorAll(constants_1.strings.FOCUSABLE_CHILD_ELEMENTS)).forEach(function (el) {
            return el.setAttribute('tabindex', '-1');
        });
        this.foundation_.layout();
    };
    /**
     * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
     */
    MDCList.prototype.initializeListType = function () {
        var _this = this;
        var checkboxListItems = this.root_.querySelectorAll(constants_1.strings.ARIA_ROLE_CHECKBOX_SELECTOR);
        var singleSelectedListItem = this.root_.querySelector("\n      ." + constants_1.cssClasses.LIST_ITEM_ACTIVATED_CLASS + ",\n      ." + constants_1.cssClasses.LIST_ITEM_SELECTED_CLASS + "\n    ");
        var radioSelectedListItem = this.root_.querySelector(constants_1.strings.ARIA_CHECKED_RADIO_SELECTOR);
        if (checkboxListItems.length) {
            var preselectedItems = this.root_.querySelectorAll(constants_1.strings.ARIA_CHECKED_CHECKBOX_SELECTOR);
            this.selectedIndex = [].map.call(preselectedItems, function (listItem) {
                return _this.listElements.indexOf(listItem);
            });
        } else if (singleSelectedListItem) {
            if (singleSelectedListItem.classList.contains(constants_1.cssClasses.LIST_ITEM_ACTIVATED_CLASS)) {
                this.foundation_.setUseActivatedClass(true);
            }
            this.singleSelection = true;
            this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
        } else if (radioSelectedListItem) {
            this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
        }
    };
    /**
     * Updates the list item at itemIndex to the desired isEnabled state.
     * @param itemIndex Index of the list item
     * @param isEnabled Sets the list item to enabled or disabled.
     */
    MDCList.prototype.setEnabled = function (itemIndex, isEnabled) {
        this.foundation_.setEnabled(itemIndex, isEnabled);
    };
    MDCList.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClassForElementIndex: function addClassForElementIndex(index, className) {
                var element = _this.listElements[index];
                if (element) {
                    element.classList.add(className);
                }
            },
            focusItemAtIndex: function focusItemAtIndex(index) {
                var element = _this.listElements[index];
                if (element) {
                    element.focus();
                }
            },
            getAttributeForElementIndex: function getAttributeForElementIndex(index, attr) {
                return _this.listElements[index].getAttribute(attr);
            },
            getFocusedElementIndex: function getFocusedElementIndex() {
                return _this.listElements.indexOf(document.activeElement);
            },
            getListItemCount: function getListItemCount() {
                return _this.listElements.length;
            },
            hasCheckboxAtIndex: function hasCheckboxAtIndex(index) {
                var listItem = _this.listElements[index];
                return !!listItem.querySelector(constants_1.strings.CHECKBOX_SELECTOR);
            },
            hasRadioAtIndex: function hasRadioAtIndex(index) {
                var listItem = _this.listElements[index];
                return !!listItem.querySelector(constants_1.strings.RADIO_SELECTOR);
            },
            isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex(index) {
                var listItem = _this.listElements[index];
                var toggleEl = listItem.querySelector(constants_1.strings.CHECKBOX_SELECTOR);
                return toggleEl.checked;
            },
            isFocusInsideList: function isFocusInsideList() {
                return _this.root_.contains(document.activeElement);
            },
            isRootFocused: function isRootFocused() {
                return document.activeElement === _this.root_;
            },
            listItemAtIndexHasClass: function listItemAtIndexHasClass(index, className) {
                return _this.listElements[index].classList.contains(className);
            },
            notifyAction: function notifyAction(index) {
                _this.emit(constants_1.strings.ACTION_EVENT, { index: index }, /** shouldBubble */true);
            },
            removeClassForElementIndex: function removeClassForElementIndex(index, className) {
                var element = _this.listElements[index];
                if (element) {
                    element.classList.remove(className);
                }
            },
            setAttributeForElementIndex: function setAttributeForElementIndex(index, attr, value) {
                var element = _this.listElements[index];
                if (element) {
                    element.setAttribute(attr, value);
                }
            },
            setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {
                var listItem = _this.listElements[index];
                var toggleEl = listItem.querySelector(constants_1.strings.CHECKBOX_RADIO_SELECTOR);
                toggleEl.checked = isChecked;
                var event = document.createEvent('Event');
                event.initEvent('change', true, true);
                toggleEl.dispatchEvent(event);
            },
            setTabIndexForListItemChildren: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {
                var element = _this.listElements[listItemIndex];
                var listItemChildren = [].slice.call(element.querySelectorAll(constants_1.strings.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
                listItemChildren.forEach(function (el) {
                    return el.setAttribute('tabindex', tabIndexValue);
                });
            }
        };
        return new foundation_1.MDCListFoundation(adapter);
    };
    /**
     * Used to figure out which list item this event is targetting. Or returns -1 if
     * there is no list item
     */
    MDCList.prototype.getListItemIndex_ = function (evt) {
        var eventTarget = evt.target;
        var nearestParent = ponyfill_1.closest(eventTarget, "." + constants_1.cssClasses.LIST_ITEM_CLASS + ", ." + constants_1.cssClasses.ROOT);
        // Get the index of the element if it is a list item.
        if (nearestParent && ponyfill_1.matches(nearestParent, "." + constants_1.cssClasses.LIST_ITEM_CLASS)) {
            return this.listElements.indexOf(nearestParent);
        }
        return -1;
    };
    /**
     * Used to figure out which element was clicked before sending the event to the foundation.
     */
    MDCList.prototype.handleFocusInEvent_ = function (evt) {
        var index = this.getListItemIndex_(evt);
        this.foundation_.handleFocusIn(evt, index);
    };
    /**
     * Used to figure out which element was clicked before sending the event to the foundation.
     */
    MDCList.prototype.handleFocusOutEvent_ = function (evt) {
        var index = this.getListItemIndex_(evt);
        this.foundation_.handleFocusOut(evt, index);
    };
    /**
     * Used to figure out which element was focused when keydown event occurred before sending the event to the
     * foundation.
     */
    MDCList.prototype.handleKeydownEvent_ = function (evt) {
        var index = this.getListItemIndex_(evt);
        var target = evt.target;
        this.foundation_.handleKeydown(evt, target.classList.contains(constants_1.cssClasses.LIST_ITEM_CLASS), index);
    };
    /**
     * Used to figure out which element was clicked before sending the event to the foundation.
     */
    MDCList.prototype.handleClickEvent_ = function (evt) {
        var index = this.getListItemIndex_(evt);
        var target = evt.target;
        // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.
        var toggleCheckbox = !ponyfill_1.matches(target, constants_1.strings.CHECKBOX_RADIO_SELECTOR);
        this.foundation_.handleClick(index, toggleCheckbox);
    };
    return MDCList;
}(component_1.MDCComponent);
exports.MDCList = MDCList;

/***/ }),

/***/ "./packages/mdc-list/constants.ts":
/*!****************************************!*\
  !*** ./packages/mdc-list/constants.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated',
    LIST_ITEM_CLASS: 'mdc-list-item',
    LIST_ITEM_DISABLED_CLASS: 'mdc-list-item--disabled',
    LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
    ROOT: 'mdc-list'
};
exports.cssClasses = cssClasses;
var strings = {
    ACTION_EVENT: 'MDCList:action',
    ARIA_CHECKED: 'aria-checked',
    ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
    ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
    ARIA_CURRENT: 'aria-current',
    ARIA_DISABLED: 'aria-disabled',
    ARIA_ORIENTATION: 'aria-orientation',
    ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
    ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
    ARIA_SELECTED: 'aria-selected',
    CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses.LIST_ITEM_CLASS + " a\n  ",
    FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses.LIST_ITEM_CLASS + " a,\n    ." + cssClasses.LIST_ITEM_CLASS + " input[type=\"radio\"]:not(:disabled),\n    ." + cssClasses.LIST_ITEM_CLASS + " input[type=\"checkbox\"]:not(:disabled)\n  ",
    RADIO_SELECTOR: 'input[type="radio"]'
};
exports.strings = strings;
var numbers = {
    UNSET_INDEX: -1
};
exports.numbers = numbers;

/***/ }),

/***/ "./packages/mdc-list/foundation.ts":
/*!*****************************************!*\
  !*** ./packages/mdc-list/foundation.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-list/constants.ts");
var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];
function isNumberArray(selectedIndex) {
    return selectedIndex instanceof Array;
}
var MDCListFoundation = /** @class */function (_super) {
    __extends(MDCListFoundation, _super);
    function MDCListFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCListFoundation.defaultAdapter), adapter)) || this;
        _this.wrapFocus_ = false;
        _this.isVertical_ = true;
        _this.isSingleSelectionList_ = false;
        _this.selectedIndex_ = constants_1.numbers.UNSET_INDEX;
        _this.focusedItemIndex_ = constants_1.numbers.UNSET_INDEX;
        _this.useActivatedClass_ = false;
        _this.ariaCurrentAttrValue_ = null;
        _this.isCheckboxList_ = false;
        _this.isRadioList_ = false;
        return _this;
    }
    Object.defineProperty(MDCListFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCListFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCListFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCListFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClassForElementIndex: function addClassForElementIndex() {
                    return undefined;
                },
                focusItemAtIndex: function focusItemAtIndex() {
                    return undefined;
                },
                getAttributeForElementIndex: function getAttributeForElementIndex() {
                    return null;
                },
                getFocusedElementIndex: function getFocusedElementIndex() {
                    return 0;
                },
                getListItemCount: function getListItemCount() {
                    return 0;
                },
                hasCheckboxAtIndex: function hasCheckboxAtIndex() {
                    return false;
                },
                hasRadioAtIndex: function hasRadioAtIndex() {
                    return false;
                },
                isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex() {
                    return false;
                },
                isFocusInsideList: function isFocusInsideList() {
                    return false;
                },
                isRootFocused: function isRootFocused() {
                    return false;
                },
                listItemAtIndexHasClass: function listItemAtIndexHasClass() {
                    return false;
                },
                notifyAction: function notifyAction() {
                    return undefined;
                },
                removeClassForElementIndex: function removeClassForElementIndex() {
                    return undefined;
                },
                setAttributeForElementIndex: function setAttributeForElementIndex() {
                    return undefined;
                },
                setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex() {
                    return undefined;
                },
                setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCListFoundation.prototype.layout = function () {
        if (this.adapter_.getListItemCount() === 0) {
            return;
        }
        if (this.adapter_.hasCheckboxAtIndex(0)) {
            this.isCheckboxList_ = true;
        } else if (this.adapter_.hasRadioAtIndex(0)) {
            this.isRadioList_ = true;
        }
    };
    /**
     * Sets the private wrapFocus_ variable.
     */
    MDCListFoundation.prototype.setWrapFocus = function (value) {
        this.wrapFocus_ = value;
    };
    /**
     * Sets the isVertical_ private variable.
     */
    MDCListFoundation.prototype.setVerticalOrientation = function (value) {
        this.isVertical_ = value;
    };
    /**
     * Sets the isSingleSelectionList_ private variable.
     */
    MDCListFoundation.prototype.setSingleSelection = function (value) {
        this.isSingleSelectionList_ = value;
    };
    /**
     * Sets the useActivatedClass_ private variable.
     */
    MDCListFoundation.prototype.setUseActivatedClass = function (useActivated) {
        this.useActivatedClass_ = useActivated;
    };
    MDCListFoundation.prototype.getSelectedIndex = function () {
        return this.selectedIndex_;
    };
    MDCListFoundation.prototype.setSelectedIndex = function (index) {
        if (!this.isIndexValid_(index)) {
            return;
        }
        if (this.isCheckboxList_) {
            this.setCheckboxAtIndex_(index);
        } else if (this.isRadioList_) {
            this.setRadioAtIndex_(index);
        } else {
            this.setSingleSelectionAtIndex_(index);
        }
    };
    /**
     * Focus in handler for the list items.
     */
    MDCListFoundation.prototype.handleFocusIn = function (_, listItemIndex) {
        if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, '0');
        }
    };
    /**
     * Focus out handler for the list items.
     */
    MDCListFoundation.prototype.handleFocusOut = function (_, listItemIndex) {
        var _this = this;
        if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, '-1');
        }
        /**
         * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
         * is moved to next element.
         */
        setTimeout(function () {
            if (!_this.adapter_.isFocusInsideList()) {
                _this.setTabindexToFirstSelectedItem_();
            }
        }, 0);
    };
    /**
     * Key handler for the list.
     */
    MDCListFoundation.prototype.handleKeydown = function (evt, isRootListItem, listItemIndex) {
        var isArrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
        var isArrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
        var isArrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
        var isArrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
        var isHome = evt.key === 'Home' || evt.keyCode === 36;
        var isEnd = evt.key === 'End' || evt.keyCode === 35;
        var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
        var isSpace = evt.key === 'Space' || evt.keyCode === 32;
        if (this.adapter_.isRootFocused()) {
            if (isArrowUp || isEnd) {
                evt.preventDefault();
                this.focusLastElement();
            } else if (isArrowDown || isHome) {
                evt.preventDefault();
                this.focusFirstElement();
            }
            return;
        }
        var currentIndex = this.adapter_.getFocusedElementIndex();
        if (currentIndex === -1) {
            currentIndex = listItemIndex;
            if (currentIndex < 0) {
                // If this event doesn't have a mdc-list-item ancestor from the
                // current list (not from a sublist), return early.
                return;
            }
        }
        var nextIndex;
        if (this.isVertical_ && isArrowDown || !this.isVertical_ && isArrowRight) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusNextElement(currentIndex);
        } else if (this.isVertical_ && isArrowUp || !this.isVertical_ && isArrowLeft) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusPrevElement(currentIndex);
        } else if (isHome) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusFirstElement();
        } else if (isEnd) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusLastElement();
        } else if (isEnter || isSpace) {
            if (isRootListItem) {
                // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
                var target = evt.target;
                if (target && target.tagName === 'A' && isEnter) {
                    return;
                }
                this.preventDefaultEvent_(evt);
                if (this.adapter_.listItemAtIndexHasClass(currentIndex, constants_1.cssClasses.LIST_ITEM_DISABLED_CLASS)) {
                    return;
                }
                if (this.isSelectableList_()) {
                    this.setSelectedIndexOnAction_(currentIndex);
                }
                this.adapter_.notifyAction(currentIndex);
            }
        }
        this.focusedItemIndex_ = currentIndex;
        if (nextIndex !== undefined) {
            this.setTabindexAtIndex_(nextIndex);
            this.focusedItemIndex_ = nextIndex;
        }
    };
    /**
     * Click handler for the list.
     */
    MDCListFoundation.prototype.handleClick = function (index, toggleCheckbox) {
        if (index === constants_1.numbers.UNSET_INDEX) {
            return;
        }
        this.setTabindexAtIndex_(index);
        this.focusedItemIndex_ = index;
        if (this.adapter_.listItemAtIndexHasClass(index, constants_1.cssClasses.LIST_ITEM_DISABLED_CLASS)) {
            return;
        }
        if (this.isSelectableList_()) {
            this.setSelectedIndexOnAction_(index, toggleCheckbox);
        }
        this.adapter_.notifyAction(index);
    };
    /**
     * Focuses the next element on the list.
     */
    MDCListFoundation.prototype.focusNextElement = function (index) {
        var count = this.adapter_.getListItemCount();
        var nextIndex = index + 1;
        if (nextIndex >= count) {
            if (this.wrapFocus_) {
                nextIndex = 0;
            } else {
                // Return early because last item is already focused.
                return index;
            }
        }
        this.adapter_.focusItemAtIndex(nextIndex);
        return nextIndex;
    };
    /**
     * Focuses the previous element on the list.
     */
    MDCListFoundation.prototype.focusPrevElement = function (index) {
        var prevIndex = index - 1;
        if (prevIndex < 0) {
            if (this.wrapFocus_) {
                prevIndex = this.adapter_.getListItemCount() - 1;
            } else {
                // Return early because first item is already focused.
                return index;
            }
        }
        this.adapter_.focusItemAtIndex(prevIndex);
        return prevIndex;
    };
    MDCListFoundation.prototype.focusFirstElement = function () {
        this.adapter_.focusItemAtIndex(0);
        return 0;
    };
    MDCListFoundation.prototype.focusLastElement = function () {
        var lastIndex = this.adapter_.getListItemCount() - 1;
        this.adapter_.focusItemAtIndex(lastIndex);
        return lastIndex;
    };
    /**
     * @param itemIndex Index of the list item
     * @param isEnabled Sets the list item to enabled or disabled.
     */
    MDCListFoundation.prototype.setEnabled = function (itemIndex, isEnabled) {
        if (!this.isIndexValid_(itemIndex)) {
            return;
        }
        if (isEnabled) {
            this.adapter_.removeClassForElementIndex(itemIndex, constants_1.cssClasses.LIST_ITEM_DISABLED_CLASS);
            this.adapter_.setAttributeForElementIndex(itemIndex, constants_1.strings.ARIA_DISABLED, 'false');
        } else {
            this.adapter_.addClassForElementIndex(itemIndex, constants_1.cssClasses.LIST_ITEM_DISABLED_CLASS);
            this.adapter_.setAttributeForElementIndex(itemIndex, constants_1.strings.ARIA_DISABLED, 'true');
        }
    };
    /**
     * Ensures that preventDefault is only called if the containing element doesn't
     * consume the event, and it will cause an unintended scroll.
     */
    MDCListFoundation.prototype.preventDefaultEvent_ = function (evt) {
        var target = evt.target;
        var tagName = ("" + target.tagName).toLowerCase();
        if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
            evt.preventDefault();
        }
    };
    MDCListFoundation.prototype.setSingleSelectionAtIndex_ = function (index) {
        if (this.selectedIndex_ === index) {
            return;
        }
        var selectedClassName = constants_1.cssClasses.LIST_ITEM_SELECTED_CLASS;
        if (this.useActivatedClass_) {
            selectedClassName = constants_1.cssClasses.LIST_ITEM_ACTIVATED_CLASS;
        }
        if (this.selectedIndex_ !== constants_1.numbers.UNSET_INDEX) {
            this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
        }
        this.adapter_.addClassForElementIndex(index, selectedClassName);
        this.setAriaForSingleSelectionAtIndex_(index);
        this.selectedIndex_ = index;
    };
    /**
     * Sets aria attribute for single selection at given index.
     */
    MDCListFoundation.prototype.setAriaForSingleSelectionAtIndex_ = function (index) {
        // Detect the presence of aria-current and get the value only during list initialization when it is in unset state.
        if (this.selectedIndex_ === constants_1.numbers.UNSET_INDEX) {
            this.ariaCurrentAttrValue_ = this.adapter_.getAttributeForElementIndex(index, constants_1.strings.ARIA_CURRENT);
        }
        var isAriaCurrent = this.ariaCurrentAttrValue_ !== null;
        var ariaAttribute = isAriaCurrent ? constants_1.strings.ARIA_CURRENT : constants_1.strings.ARIA_SELECTED;
        if (this.selectedIndex_ !== constants_1.numbers.UNSET_INDEX) {
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, 'false');
        }
        var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : 'true';
        this.adapter_.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
    };
    /**
     * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
     */
    MDCListFoundation.prototype.setRadioAtIndex_ = function (index) {
        this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);
        if (this.selectedIndex_ !== constants_1.numbers.UNSET_INDEX) {
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, constants_1.strings.ARIA_CHECKED, 'false');
        }
        this.adapter_.setAttributeForElementIndex(index, constants_1.strings.ARIA_CHECKED, 'true');
        this.selectedIndex_ = index;
    };
    MDCListFoundation.prototype.setCheckboxAtIndex_ = function (index) {
        for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
            var isChecked = false;
            if (index.indexOf(i) >= 0) {
                isChecked = true;
            }
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
            this.adapter_.setAttributeForElementIndex(i, constants_1.strings.ARIA_CHECKED, isChecked ? 'true' : 'false');
        }
        this.selectedIndex_ = index;
    };
    MDCListFoundation.prototype.setTabindexAtIndex_ = function (index) {
        if (this.focusedItemIndex_ === constants_1.numbers.UNSET_INDEX && index !== 0) {
            // If no list item was selected set first list item's tabindex to -1.
            // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
            this.adapter_.setAttributeForElementIndex(0, 'tabindex', '-1');
        } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
            this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', '-1');
        }
        this.adapter_.setAttributeForElementIndex(index, 'tabindex', '0');
    };
    /**
     * @return Return true if it is single selectin list, checkbox list or radio list.
     */
    MDCListFoundation.prototype.isSelectableList_ = function () {
        return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
    };
    MDCListFoundation.prototype.setTabindexToFirstSelectedItem_ = function () {
        var targetIndex = 0;
        if (this.isSelectableList_()) {
            if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== constants_1.numbers.UNSET_INDEX) {
                targetIndex = this.selectedIndex_;
            } else if (isNumberArray(this.selectedIndex_) && this.selectedIndex_.length > 0) {
                targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) {
                    return Math.min(currentIndex, minIndex);
                });
            }
        }
        this.setTabindexAtIndex_(targetIndex);
    };
    MDCListFoundation.prototype.isIndexValid_ = function (index) {
        var _this = this;
        if (index instanceof Array) {
            if (!this.isCheckboxList_) {
                throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
            }
            if (index.length === 0) {
                return true;
            } else {
                return index.some(function (i) {
                    return _this.isIndexInRange_(i);
                });
            }
        } else if (typeof index === 'number') {
            if (this.isCheckboxList_) {
                throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
            }
            return this.isIndexInRange_(index);
        } else {
            return false;
        }
    };
    MDCListFoundation.prototype.isIndexInRange_ = function (index) {
        var listSize = this.adapter_.getListItemCount();
        return index >= 0 && index < listSize;
    };
    /**
     * Sets selected index on user action, toggles checkbox / radio based on toggleCheckbox value.
     * User interaction should not toggle list item(s) when disabled.
     */
    MDCListFoundation.prototype.setSelectedIndexOnAction_ = function (index, toggleCheckbox) {
        if (toggleCheckbox === void 0) {
            toggleCheckbox = true;
        }
        if (this.isCheckboxList_) {
            this.toggleCheckboxAtIndex_(index, toggleCheckbox);
        } else {
            this.setSelectedIndex(index);
        }
    };
    MDCListFoundation.prototype.toggleCheckboxAtIndex_ = function (index, toggleCheckbox) {
        var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);
        if (toggleCheckbox) {
            isChecked = !isChecked;
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
        }
        this.adapter_.setAttributeForElementIndex(index, constants_1.strings.ARIA_CHECKED, isChecked ? 'true' : 'false');
        // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.
        var selectedIndexes = this.selectedIndex_ === constants_1.numbers.UNSET_INDEX ? [] : this.selectedIndex_.slice();
        if (isChecked) {
            selectedIndexes.push(index);
        } else {
            selectedIndexes = selectedIndexes.filter(function (i) {
                return i !== index;
            });
        }
        this.selectedIndex_ = selectedIndexes;
    };
    return MDCListFoundation;
}(foundation_1.MDCFoundation);
exports.MDCListFoundation = MDCListFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCListFoundation;

/***/ }),

/***/ "./packages/mdc-list/index.ts":
/*!************************************!*\
  !*** ./packages/mdc-list/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-list/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-list/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-list/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-menu-surface/component.ts":
/*!************************************************!*\
  !*** ./packages/mdc-menu-surface/component.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-menu-surface/constants.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-menu-surface/foundation.ts");
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-menu-surface/util.ts"));
var MDCMenuSurface = /** @class */function (_super) {
    __extends(MDCMenuSurface, _super);
    function MDCMenuSurface() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCMenuSurface.attachTo = function (root) {
        return new MDCMenuSurface(root);
    };
    MDCMenuSurface.prototype.initialSyncWithDOM = function () {
        var _this = this;
        var parentEl = this.root_.parentElement;
        this.anchorElement = parentEl && parentEl.classList.contains(constants_1.cssClasses.ANCHOR) ? parentEl : null;
        if (this.root_.classList.contains(constants_1.cssClasses.FIXED)) {
            this.setFixedPosition(true);
        }
        this.handleKeydown_ = function (evt) {
            return _this.foundation_.handleKeydown(evt);
        };
        this.handleBodyClick_ = function (evt) {
            return _this.foundation_.handleBodyClick(evt);
        };
        // capture so that no race between handleBodyClick and quickOpen when
        // menusurface opened on button click which registers this listener
        this.registerBodyClickListener_ = function () {
            return document.body.addEventListener('click', _this.handleBodyClick_, { capture: true });
        };
        this.deregisterBodyClickListener_ = function () {
            return document.body.removeEventListener('click', _this.handleBodyClick_);
        };
        this.listen('keydown', this.handleKeydown_);
        this.listen(constants_1.strings.OPENED_EVENT, this.registerBodyClickListener_);
        this.listen(constants_1.strings.CLOSED_EVENT, this.deregisterBodyClickListener_);
    };
    MDCMenuSurface.prototype.destroy = function () {
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten(constants_1.strings.OPENED_EVENT, this.registerBodyClickListener_);
        this.unlisten(constants_1.strings.CLOSED_EVENT, this.deregisterBodyClickListener_);
        _super.prototype.destroy.call(this);
    };
    MDCMenuSurface.prototype.isOpen = function () {
        return this.foundation_.isOpen();
    };
    MDCMenuSurface.prototype.open = function () {
        this.foundation_.open();
    };
    MDCMenuSurface.prototype.close = function (skipRestoreFocus) {
        if (skipRestoreFocus === void 0) {
            skipRestoreFocus = false;
        }
        this.foundation_.close(skipRestoreFocus);
    };
    Object.defineProperty(MDCMenuSurface.prototype, "quickOpen", {
        set: function set(quickOpen) {
            this.foundation_.setQuickOpen(quickOpen);
        },
        enumerable: true,
        configurable: true
    });
    /** Sets the foundation to use page offsets for an positioning when the menu is hoisted to the body. */
    MDCMenuSurface.prototype.setIsHoisted = function (isHoisted) {
        this.foundation_.setIsHoisted(isHoisted);
    };
    /** Sets the element that the menu-surface is anchored to. */
    MDCMenuSurface.prototype.setMenuSurfaceAnchorElement = function (element) {
        this.anchorElement = element;
    };
    /** Sets the menu-surface to position: fixed. */
    MDCMenuSurface.prototype.setFixedPosition = function (isFixed) {
        if (isFixed) {
            this.root_.classList.add(constants_1.cssClasses.FIXED);
        } else {
            this.root_.classList.remove(constants_1.cssClasses.FIXED);
        }
        this.foundation_.setFixedPosition(isFixed);
    };
    /** Sets the absolute x/y position to position based on. Requires the menu to be hoisted. */
    MDCMenuSurface.prototype.setAbsolutePosition = function (x, y) {
        this.foundation_.setAbsolutePosition(x, y);
        this.setIsHoisted(true);
    };
    /**
     * @param corner Default anchor corner alignment of top-left surface corner.
     */
    MDCMenuSurface.prototype.setAnchorCorner = function (corner) {
        this.foundation_.setAnchorCorner(corner);
    };
    MDCMenuSurface.prototype.setAnchorMargin = function (margin) {
        this.foundation_.setAnchorMargin(margin);
    };
    MDCMenuSurface.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            hasAnchor: function hasAnchor() {
                return !!_this.anchorElement;
            },
            notifyClose: function notifyClose() {
                return _this.emit(foundation_1.MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {});
            },
            notifyOpen: function notifyOpen() {
                return _this.emit(foundation_1.MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {});
            },
            isElementInContainer: function isElementInContainer(el) {
                return _this.root_.contains(el);
            },
            isRtl: function isRtl() {
                return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
            },
            setTransformOrigin: function setTransformOrigin(origin) {
                var propertyName = util.getTransformPropertyName(window) + "-origin";
                _this.root_.style.setProperty(propertyName, origin);
            },
            isFocused: function isFocused() {
                return document.activeElement === _this.root_;
            },
            saveFocus: function saveFocus() {
                _this.previousFocus_ = document.activeElement;
            },
            restoreFocus: function restoreFocus() {
                if (_this.root_.contains(document.activeElement)) {
                    if (_this.previousFocus_ && _this.previousFocus_.focus) {
                        _this.previousFocus_.focus();
                    }
                }
            },
            getInnerDimensions: function getInnerDimensions() {
                return { width: _this.root_.offsetWidth, height: _this.root_.offsetHeight };
            },
            getAnchorDimensions: function getAnchorDimensions() {
                return _this.anchorElement ? _this.anchorElement.getBoundingClientRect() : null;
            },
            getWindowDimensions: function getWindowDimensions() {
                return { width: window.innerWidth, height: window.innerHeight };
            },
            getBodyDimensions: function getBodyDimensions() {
                return { width: document.body.clientWidth, height: document.body.clientHeight };
            },
            getWindowScroll: function getWindowScroll() {
                return { x: window.pageXOffset, y: window.pageYOffset };
            },
            setPosition: function setPosition(position) {
                _this.root_.style.left = 'left' in position ? position.left + "px" : '';
                _this.root_.style.right = 'right' in position ? position.right + "px" : '';
                _this.root_.style.top = 'top' in position ? position.top + "px" : '';
                _this.root_.style.bottom = 'bottom' in position ? position.bottom + "px" : '';
            },
            setMaxHeight: function setMaxHeight(height) {
                _this.root_.style.maxHeight = height;
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_1.MDCMenuSurfaceFoundation(adapter);
    };
    return MDCMenuSurface;
}(component_1.MDCComponent);
exports.MDCMenuSurface = MDCMenuSurface;

/***/ }),

/***/ "./packages/mdc-menu-surface/constants.ts":
/*!************************************************!*\
  !*** ./packages/mdc-menu-surface/constants.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    ANCHOR: 'mdc-menu-surface--anchor',
    ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
    ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
    FIXED: 'mdc-menu-surface--fixed',
    IS_OPEN_BELOW: 'mdc-menu-surface--is-open-below',
    OPEN: 'mdc-menu-surface--open',
    ROOT: 'mdc-menu-surface'
};
exports.cssClasses = cssClasses;
// tslint:disable:object-literal-sort-keys
var strings = {
    CLOSED_EVENT: 'MDCMenuSurface:closed',
    OPENED_EVENT: 'MDCMenuSurface:opened',
    FOCUSABLE_ELEMENTS: ['button:not(:disabled)', '[href]:not([aria-disabled="true"])', 'input:not(:disabled)', 'select:not(:disabled)', 'textarea:not(:disabled)', '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'].join(', ')
};
exports.strings = strings;
// tslint:enable:object-literal-sort-keys
var numbers = {
    /** Total duration of menu-surface open animation. */
    TRANSITION_OPEN_DURATION: 120,
    /** Total duration of menu-surface close animation. */
    TRANSITION_CLOSE_DURATION: 75,
    /** Margin left to the edge of the viewport when menu-surface is at maximum possible height. Also used as a viewport margin. */
    MARGIN_TO_EDGE: 32,
    /** Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning. */
    ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67
};
exports.numbers = numbers;
/**
 * Enum for bits in the {@see Corner) bitmap.
 */
var CornerBit;
(function (CornerBit) {
    CornerBit[CornerBit["BOTTOM"] = 1] = "BOTTOM";
    CornerBit[CornerBit["CENTER"] = 2] = "CENTER";
    CornerBit[CornerBit["RIGHT"] = 4] = "RIGHT";
    CornerBit[CornerBit["FLIP_RTL"] = 8] = "FLIP_RTL";
})(CornerBit || (CornerBit = {}));
exports.CornerBit = CornerBit;
/**
 * Enum for representing an element corner for positioning the menu-surface.
 *
 * The START constants map to LEFT if element directionality is left
 * to right and RIGHT if the directionality is right to left.
 * Likewise END maps to RIGHT or LEFT depending on the directionality.
 */
var Corner;
(function (Corner) {
    Corner[Corner["TOP_LEFT"] = 0] = "TOP_LEFT";
    Corner[Corner["TOP_RIGHT"] = 4] = "TOP_RIGHT";
    Corner[Corner["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
    Corner[Corner["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
    Corner[Corner["TOP_START"] = 8] = "TOP_START";
    Corner[Corner["TOP_END"] = 12] = "TOP_END";
    Corner[Corner["BOTTOM_START"] = 9] = "BOTTOM_START";
    Corner[Corner["BOTTOM_END"] = 13] = "BOTTOM_END";
})(Corner || (Corner = {}));
exports.Corner = Corner;

/***/ }),

/***/ "./packages/mdc-menu-surface/foundation.ts":
/*!*************************************************!*\
  !*** ./packages/mdc-menu-surface/foundation.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = this && this.__values || function (o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
// Style preference for trailing underscores.
// tslint:disable:strip-private-property-underscore
// tslint:disable:strip-private-method-underscore
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-menu-surface/constants.ts");
var MDCMenuSurfaceFoundation = /** @class */function (_super) {
    __extends(MDCMenuSurfaceFoundation, _super);
    function MDCMenuSurfaceFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation.defaultAdapter), adapter)) || this;
        _this.isOpen_ = false;
        _this.isQuickOpen_ = false;
        _this.isHoistedElement_ = false;
        _this.isFixedPosition_ = false;
        _this.openAnimationEndTimerId_ = 0;
        _this.closeAnimationEndTimerId_ = 0;
        _this.animationRequestId_ = 0;
        _this.anchorCorner_ = constants_1.Corner.TOP_START;
        /**
         * Corner of the menu surface to which menu surface is attached to anchor.
         *
         *  Anchor corner --->+----------+
         *                    |  ANCHOR  |
         *                    +----------+
         *  Origin corner --->+--------------+
         *                    |              |
         *                    |              |
         *                    | MENU SURFACE |
         *                    |              |
         *                    |              |
         *                    +--------------+
         */
        _this.originCorner_ = constants_1.Corner.TOP_START;
        _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
        _this.position_ = { x: 0, y: 0 };
        return _this;
    }
    Object.defineProperty(MDCMenuSurfaceFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation, "Corner", {
        get: function get() {
            return constants_1.Corner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation, "defaultAdapter", {
        /**
         * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return false;
                },
                hasAnchor: function hasAnchor() {
                    return false;
                },
                isElementInContainer: function isElementInContainer() {
                    return false;
                },
                isFocused: function isFocused() {
                    return false;
                },
                isRtl: function isRtl() {
                    return false;
                },
                getInnerDimensions: function getInnerDimensions() {
                    return { height: 0, width: 0 };
                },
                getAnchorDimensions: function getAnchorDimensions() {
                    return null;
                },
                getWindowDimensions: function getWindowDimensions() {
                    return { height: 0, width: 0 };
                },
                getBodyDimensions: function getBodyDimensions() {
                    return { height: 0, width: 0 };
                },
                getWindowScroll: function getWindowScroll() {
                    return { x: 0, y: 0 };
                },
                setPosition: function setPosition() {
                    return undefined;
                },
                setMaxHeight: function setMaxHeight() {
                    return undefined;
                },
                setTransformOrigin: function setTransformOrigin() {
                    return undefined;
                },
                saveFocus: function saveFocus() {
                    return undefined;
                },
                restoreFocus: function restoreFocus() {
                    return undefined;
                },
                notifyClose: function notifyClose() {
                    return undefined;
                },
                notifyOpen: function notifyOpen() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCMenuSurfaceFoundation.prototype.init = function () {
        var _a = MDCMenuSurfaceFoundation.cssClasses,
            ROOT = _a.ROOT,
            OPEN = _a.OPEN;
        if (!this.adapter_.hasClass(ROOT)) {
            throw new Error(ROOT + " class required in root element.");
        }
        if (this.adapter_.hasClass(OPEN)) {
            this.isOpen_ = true;
        }
    };
    MDCMenuSurfaceFoundation.prototype.destroy = function () {
        clearTimeout(this.openAnimationEndTimerId_);
        clearTimeout(this.closeAnimationEndTimerId_);
        // Cancel any currently running animations.
        cancelAnimationFrame(this.animationRequestId_);
    };
    /**
     * @param corner Default anchor corner alignment of top-left menu surface corner.
     */
    MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {
        this.anchorCorner_ = corner;
    };
    /**
     * Flip menu corner horizontally.
     */
    MDCMenuSurfaceFoundation.prototype.flipCornerHorizontally = function () {
        this.originCorner_ = this.originCorner_ ^ constants_1.CornerBit.RIGHT;
    };
    /**
     * @param margin Set of margin values from anchor.
     */
    MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {
        this.anchorMargin_.top = margin.top || 0;
        this.anchorMargin_.right = margin.right || 0;
        this.anchorMargin_.bottom = margin.bottom || 0;
        this.anchorMargin_.left = margin.left || 0;
    };
    /** Used to indicate if the menu-surface is hoisted to the body. */
    MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {
        this.isHoistedElement_ = isHoisted;
    };
    /** Used to set the menu-surface calculations based on a fixed position menu. */
    MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {
        this.isFixedPosition_ = isFixedPosition;
    };
    /** Sets the menu-surface position on the page. */
    MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {
        this.position_.x = this.isFinite_(x) ? x : 0;
        this.position_.y = this.isFinite_(y) ? y : 0;
    };
    MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {
        this.isQuickOpen_ = quickOpen;
    };
    MDCMenuSurfaceFoundation.prototype.isOpen = function () {
        return this.isOpen_;
    };
    /**
     * Open the menu surface.
     */
    MDCMenuSurfaceFoundation.prototype.open = function () {
        var _this = this;
        if (this.isOpen_) {
            return;
        }
        this.adapter_.saveFocus();
        if (this.isQuickOpen_) {
            this.isOpen_ = true;
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
            this.dimensions_ = this.adapter_.getInnerDimensions();
            this.autoPosition_();
            this.adapter_.notifyOpen();
        } else {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
            this.animationRequestId_ = requestAnimationFrame(function () {
                _this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                _this.dimensions_ = _this.adapter_.getInnerDimensions();
                _this.autoPosition_();
                _this.openAnimationEndTimerId_ = setTimeout(function () {
                    _this.openAnimationEndTimerId_ = 0;
                    _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
                    _this.adapter_.notifyOpen();
                }, constants_1.numbers.TRANSITION_OPEN_DURATION);
            });
            this.isOpen_ = true;
        }
    };
    /**
     * Closes the menu surface.
     */
    MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {
        var _this = this;
        if (skipRestoreFocus === void 0) {
            skipRestoreFocus = false;
        }
        if (!this.isOpen_) {
            return;
        }
        if (this.isQuickOpen_) {
            this.isOpen_ = false;
            if (!skipRestoreFocus) {
                this.maybeRestoreFocus_();
            }
            this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
            this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
            this.adapter_.notifyClose();
        } else {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
            requestAnimationFrame(function () {
                _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
                _this.closeAnimationEndTimerId_ = setTimeout(function () {
                    _this.closeAnimationEndTimerId_ = 0;
                    _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
                    _this.adapter_.notifyClose();
                }, constants_1.numbers.TRANSITION_CLOSE_DURATION);
            });
            this.isOpen_ = false;
            if (!skipRestoreFocus) {
                this.maybeRestoreFocus_();
            }
        }
    };
    /** Handle clicks and close if not within menu-surface element. */
    MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {
        var el = evt.target;
        if (this.adapter_.isElementInContainer(el)) {
            return;
        }
        this.close();
    };
    /** Handle keys that close the surface. */
    MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {
        var keyCode = evt.keyCode,
            key = evt.key;
        var isEscape = key === 'Escape' || keyCode === 27;
        if (isEscape) {
            this.close();
        }
    };
    MDCMenuSurfaceFoundation.prototype.autoPosition_ = function () {
        var _a;
        // Compute measurements for autoposition methods reuse.
        this.measurements_ = this.getAutoLayoutMeasurements_();
        var corner = this.getOriginCorner_();
        var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
        var verticalAlignment = this.hasBit_(corner, constants_1.CornerBit.BOTTOM) ? 'bottom' : 'top';
        var horizontalAlignment = this.hasBit_(corner, constants_1.CornerBit.RIGHT) ? 'right' : 'left';
        var horizontalOffset = this.getHorizontalOriginOffset_(corner);
        var verticalOffset = this.getVerticalOriginOffset_(corner);
        var _b = this.measurements_,
            anchorSize = _b.anchorSize,
            surfaceSize = _b.surfaceSize;
        var position = (_a = {}, _a[horizontalAlignment] = horizontalOffset, _a[verticalAlignment] = verticalOffset, _a);
        // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.
        if (anchorSize.width / surfaceSize.width > constants_1.numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
            horizontalAlignment = 'center';
        }
        // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element
        if (this.isHoistedElement_ || this.isFixedPosition_) {
            this.adjustPositionForHoistedElement_(position);
        }
        this.adapter_.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
        this.adapter_.setPosition(position);
        this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');
        // If it is opened from the top then add is-open-below class
        if (!this.hasBit_(corner, constants_1.CornerBit.BOTTOM)) {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
        }
    };
    /**
     * @return Measurements used to position menu surface popup.
     */
    MDCMenuSurfaceFoundation.prototype.getAutoLayoutMeasurements_ = function () {
        var anchorRect = this.adapter_.getAnchorDimensions();
        var bodySize = this.adapter_.getBodyDimensions();
        var viewportSize = this.adapter_.getWindowDimensions();
        var windowScroll = this.adapter_.getWindowScroll();
        if (!anchorRect) {
            // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
            anchorRect = {
                top: this.position_.y,
                right: this.position_.x,
                bottom: this.position_.y,
                left: this.position_.x,
                width: 0,
                height: 0
            };
            // tslint:enable:object-literal-sort-keys
        }
        return {
            anchorSize: anchorRect,
            bodySize: bodySize,
            surfaceSize: this.dimensions_,
            viewportDistance: {
                // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
                top: anchorRect.top,
                right: viewportSize.width - anchorRect.right,
                bottom: viewportSize.height - anchorRect.bottom,
                left: anchorRect.left
            },
            viewportSize: viewportSize,
            windowScroll: windowScroll
        };
    };
    /**
     * Computes the corner of the anchor from which to animate and position the
     * menu surface.
     *
     * Only LEFT or RIGHT bit is used to position the menu surface ignoring RTL
     * context. E.g., menu surface will be positioned from right side on TOP_END.
     */
    MDCMenuSurfaceFoundation.prototype.getOriginCorner_ = function () {
        var corner = this.originCorner_;
        var _a = this.measurements_,
            viewportDistance = _a.viewportDistance,
            anchorSize = _a.anchorSize,
            surfaceSize = _a.surfaceSize;
        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;
        var isAnchoredToBottom = this.hasBit_(this.anchorCorner_, constants_1.CornerBit.BOTTOM);
        var availableTop;
        var availableBottom;
        if (isAnchoredToBottom) {
            availableTop = viewportDistance.top - MARGIN_TO_EDGE + anchorSize.height + this.anchorMargin_.bottom;
            availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin_.bottom;
        } else {
            availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin_.top;
            availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin_.top;
        }
        var isAvailableBottom = availableBottom - surfaceSize.height > 0;
        if (!isAvailableBottom && availableTop >= availableBottom) {
            // Attach bottom side of surface to the anchor.
            corner = this.setBit_(corner, constants_1.CornerBit.BOTTOM);
        }
        var isRtl = this.adapter_.isRtl();
        var isFlipRtl = this.hasBit_(this.anchorCorner_, constants_1.CornerBit.FLIP_RTL);
        var hasRightBit = this.hasBit_(this.anchorCorner_, constants_1.CornerBit.RIGHT);
        // Whether surface attached to right side of anchor element.
        var isAnchoredToRight = false;
        // Anchored to start
        if (isRtl && isFlipRtl) {
            isAnchoredToRight = !hasRightBit;
        } else {
            // Anchored to right
            isAnchoredToRight = hasRightBit;
        }
        var availableLeft;
        var availableRight;
        if (isAnchoredToRight) {
            availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin_.right;
            availableRight = viewportDistance.right - this.anchorMargin_.right;
        } else {
            availableLeft = viewportDistance.left + this.anchorMargin_.left;
            availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin_.left;
        }
        var isAvailableLeft = availableLeft - surfaceSize.width > 0;
        var isAvailableRight = availableRight - surfaceSize.width > 0;
        var isOriginCornerAlignedToEnd = this.hasBit_(corner, constants_1.CornerBit.FLIP_RTL) && this.hasBit_(corner, constants_1.CornerBit.RIGHT);
        if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {
            // Attach left side of surface to the anchor.
            corner = this.unsetBit_(corner, constants_1.CornerBit.RIGHT);
        } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {
            // Attach right side of surface to the anchor.
            corner = this.setBit_(corner, constants_1.CornerBit.RIGHT);
        }
        return corner;
    };
    /**
     * @param corner Origin corner of the menu surface.
     * @return Maximum height of the menu surface, based on available space. 0 indicates should not be set.
     */
    MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight_ = function (corner) {
        var viewportDistance = this.measurements_.viewportDistance;
        var maxHeight = 0;
        var isBottomAligned = this.hasBit_(corner, constants_1.CornerBit.BOTTOM);
        var isBottomAnchored = this.hasBit_(this.anchorCorner_, constants_1.CornerBit.BOTTOM);
        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;
        // When maximum height is not specified, it is handled from CSS.
        if (isBottomAligned) {
            maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;
            if (!isBottomAnchored) {
                maxHeight += this.measurements_.anchorSize.height;
            }
        } else {
            maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom + this.measurements_.anchorSize.height - MARGIN_TO_EDGE;
            if (isBottomAnchored) {
                maxHeight -= this.measurements_.anchorSize.height;
            }
        }
        return maxHeight;
    };
    /**
     * @param corner Origin corner of the menu surface.
     * @return Horizontal offset of menu surface origin corner from corresponding anchor corner.
     */
    MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset_ = function (corner) {
        var anchorSize = this.measurements_.anchorSize;
        // isRightAligned corresponds to using the 'right' property on the surface.
        var isRightAligned = this.hasBit_(corner, constants_1.CornerBit.RIGHT);
        var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, constants_1.CornerBit.RIGHT);
        if (isRightAligned) {
            var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.left : this.anchorMargin_.right;
            // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
            // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
            // the right property is correct.
            if (this.isHoistedElement_ || this.isFixedPosition_) {
                return rightOffset - (this.measurements_.viewportSize.width - this.measurements_.bodySize.width);
            }
            return rightOffset;
        }
        return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.right : this.anchorMargin_.left;
    };
    /**
     * @param corner Origin corner of the menu surface.
     * @return Vertical offset of menu surface origin corner from corresponding anchor corner.
     */
    MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset_ = function (corner) {
        var anchorSize = this.measurements_.anchorSize;
        var isBottomAligned = this.hasBit_(corner, constants_1.CornerBit.BOTTOM);
        var avoidVerticalOverlap = this.hasBit_(this.anchorCorner_, constants_1.CornerBit.BOTTOM);
        var y = 0;
        if (isBottomAligned) {
            y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin_.top : -this.anchorMargin_.bottom;
        } else {
            y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin_.bottom : this.anchorMargin_.top;
        }
        return y;
    };
    /** Calculates the offsets for positioning the menu-surface when the menu-surface has been hoisted to the body. */
    MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement_ = function (position) {
        var e_1, _a;
        var _b = this.measurements_,
            windowScroll = _b.windowScroll,
            viewportDistance = _b.viewportDistance;
        var props = Object.keys(position);
        try {
            for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
                var prop = props_1_1.value;
                var value = position[prop] || 0;
                // Hoisted surfaces need to have the anchor elements location on the page added to the
                // position properties for proper alignment on the body.
                value += viewportDistance[prop];
                // Surfaces that are absolutely positioned need to have additional calculations for scroll
                // and bottom positioning.
                if (!this.isFixedPosition_) {
                    if (prop === 'top') {
                        value += windowScroll.y;
                    } else if (prop === 'bottom') {
                        value -= windowScroll.y;
                    } else if (prop === 'left') {
                        value += windowScroll.x;
                    } else {
                        // prop === 'right'
                        value -= windowScroll.x;
                    }
                }
                position[prop] = value;
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    /**
     * The last focused element when the menu surface was opened should regain focus, if the user is
     * focused on or within the menu surface when it is closed.
     */
    MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus_ = function () {
        var isRootFocused = this.adapter_.isFocused();
        var childHasFocus = document.activeElement && this.adapter_.isElementInContainer(document.activeElement);
        if (isRootFocused || childHasFocus) {
            this.adapter_.restoreFocus();
        }
    };
    MDCMenuSurfaceFoundation.prototype.hasBit_ = function (corner, bit) {
        return Boolean(corner & bit); // tslint:disable-line:no-bitwise
    };
    MDCMenuSurfaceFoundation.prototype.setBit_ = function (corner, bit) {
        return corner | bit; // tslint:disable-line:no-bitwise
    };
    MDCMenuSurfaceFoundation.prototype.unsetBit_ = function (corner, bit) {
        return corner ^ bit;
    };
    /**
     * isFinite that doesn't force conversion to number type.
     * Equivalent to Number.isFinite in ES2015, which is not supported in IE.
     */
    MDCMenuSurfaceFoundation.prototype.isFinite_ = function (num) {
        return typeof num === 'number' && isFinite(num);
    };
    return MDCMenuSurfaceFoundation;
}(foundation_1.MDCFoundation);
exports.MDCMenuSurfaceFoundation = MDCMenuSurfaceFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCMenuSurfaceFoundation;

/***/ }),

/***/ "./packages/mdc-menu-surface/index.ts":
/*!********************************************!*\
  !*** ./packages/mdc-menu-surface/index.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-menu-surface/util.ts"));
exports.util = util;
__export(__webpack_require__(/*! ./component */ "./packages/mdc-menu-surface/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-menu-surface/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-menu-surface/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-menu-surface/util.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-menu-surface/util.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cachedCssTransformPropertyName_;
/**
 * Returns the name of the correct transform property to use on the current browser.
 */
function getTransformPropertyName(globalObj, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  if (cachedCssTransformPropertyName_ === undefined || forceRefresh) {
    var el = globalObj.document.createElement('div');
    cachedCssTransformPropertyName_ = 'transform' in el.style ? 'transform' : 'webkitTransform';
  }
  return cachedCssTransformPropertyName_;
}
exports.getTransformPropertyName = getTransformPropertyName;

/***/ }),

/***/ "./packages/mdc-menu/component.ts":
/*!****************************************!*\
  !*** ./packages/mdc-menu/component.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var component_2 = __webpack_require__(/*! @material/list/component */ "./packages/mdc-list/component.ts");
var foundation_1 = __webpack_require__(/*! @material/list/foundation */ "./packages/mdc-list/foundation.ts");
var component_3 = __webpack_require__(/*! @material/menu-surface/component */ "./packages/mdc-menu-surface/component.ts");
var foundation_2 = __webpack_require__(/*! @material/menu-surface/foundation */ "./packages/mdc-menu-surface/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-menu/constants.ts");
var foundation_3 = __webpack_require__(/*! ./foundation */ "./packages/mdc-menu/foundation.ts");
var MDCMenu = /** @class */function (_super) {
    __extends(MDCMenu, _super);
    function MDCMenu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCMenu.attachTo = function (root) {
        return new MDCMenu(root);
    };
    MDCMenu.prototype.initialize = function (menuSurfaceFactory, listFactory) {
        if (menuSurfaceFactory === void 0) {
            menuSurfaceFactory = function menuSurfaceFactory(el) {
                return new component_3.MDCMenuSurface(el);
            };
        }
        if (listFactory === void 0) {
            listFactory = function listFactory(el) {
                return new component_2.MDCList(el);
            };
        }
        this.menuSurfaceFactory_ = menuSurfaceFactory;
        this.listFactory_ = listFactory;
    };
    MDCMenu.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.menuSurface_ = this.menuSurfaceFactory_(this.root_);
        var list = this.root_.querySelector(constants_1.strings.LIST_SELECTOR);
        if (list) {
            this.list_ = this.listFactory_(list);
            this.list_.wrapFocus = true;
        } else {
            this.list_ = null;
        }
        this.handleKeydown_ = function (evt) {
            return _this.foundation_.handleKeydown(evt);
        };
        this.handleItemAction_ = function (evt) {
            return _this.foundation_.handleItemAction(_this.items[evt.detail.index]);
        };
        this.handleMenuSurfaceOpened_ = function () {
            return _this.foundation_.handleMenuSurfaceOpened();
        };
        this.menuSurface_.listen(foundation_2.MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
        this.listen('keydown', this.handleKeydown_);
        this.listen(foundation_1.MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
    };
    MDCMenu.prototype.destroy = function () {
        if (this.list_) {
            this.list_.destroy();
        }
        this.menuSurface_.destroy();
        this.menuSurface_.unlisten(foundation_2.MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten(foundation_1.MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
        _super.prototype.destroy.call(this);
    };
    Object.defineProperty(MDCMenu.prototype, "open", {
        get: function get() {
            return this.menuSurface_.isOpen();
        },
        set: function set(value) {
            if (value) {
                this.menuSurface_.open();
            } else {
                this.menuSurface_.close();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenu.prototype, "wrapFocus", {
        get: function get() {
            return this.list_ ? this.list_.wrapFocus : false;
        },
        set: function set(value) {
            if (this.list_) {
                this.list_.wrapFocus = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenu.prototype, "items", {
        /**
         * Return the items within the menu. Note that this only contains the set of elements within
         * the items container that are proper list items, and not supplemental / presentational DOM
         * elements.
         */
        get: function get() {
            return this.list_ ? this.list_.listElements : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenu.prototype, "quickOpen", {
        set: function set(quickOpen) {
            this.menuSurface_.quickOpen = quickOpen;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets default focus state where the menu should focus every time when menu
     * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
     * default.
     * @param focusState Default focus state.
     */
    MDCMenu.prototype.setDefaultFocusState = function (focusState) {
        this.foundation_.setDefaultFocusState(focusState);
    };
    /**
     * @param corner Default anchor corner alignment of top-left menu corner.
     */
    MDCMenu.prototype.setAnchorCorner = function (corner) {
        this.menuSurface_.setAnchorCorner(corner);
    };
    MDCMenu.prototype.setAnchorMargin = function (margin) {
        this.menuSurface_.setAnchorMargin(margin);
    };
    /**
     * Sets the list item as the selected row at the specified index.
     * @param index Index of list item within menu.
     */
    MDCMenu.prototype.setSelectedIndex = function (index) {
        this.foundation_.setSelectedIndex(index);
    };
    /**
     * Sets the enabled state to isEnabled for the menu item at the given index.
     * @param index Index of the menu item
     * @param isEnabled The desired enabled state of the menu item.
     */
    MDCMenu.prototype.setEnabled = function (index, isEnabled) {
        this.foundation_.setEnabled(index, isEnabled);
    };
    /**
     * @return The item within the menu at the index specified.
     */
    MDCMenu.prototype.getOptionByIndex = function (index) {
        var items = this.items;
        if (index < items.length) {
            return this.items[index];
        } else {
            return null;
        }
    };
    MDCMenu.prototype.setFixedPosition = function (isFixed) {
        this.menuSurface_.setFixedPosition(isFixed);
    };
    MDCMenu.prototype.setIsHoisted = function (isHoisted) {
        this.menuSurface_.setIsHoisted(isHoisted);
    };
    MDCMenu.prototype.setAbsolutePosition = function (x, y) {
        this.menuSurface_.setAbsolutePosition(x, y);
    };
    /**
     * Sets the element that the menu-surface is anchored to.
     */
    MDCMenu.prototype.setAnchorElement = function (element) {
        this.menuSurface_.anchorElement = element;
    };
    MDCMenu.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClassToElementAtIndex: function addClassToElementAtIndex(index, className) {
                var list = _this.items;
                list[index].classList.add(className);
            },
            removeClassFromElementAtIndex: function removeClassFromElementAtIndex(index, className) {
                var list = _this.items;
                list[index].classList.remove(className);
            },
            addAttributeToElementAtIndex: function addAttributeToElementAtIndex(index, attr, value) {
                var list = _this.items;
                list[index].setAttribute(attr, value);
            },
            removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex(index, attr) {
                var list = _this.items;
                list[index].removeAttribute(attr);
            },
            elementContainsClass: function elementContainsClass(element, className) {
                return element.classList.contains(className);
            },
            closeSurface: function closeSurface(skipRestoreFocus) {
                return _this.menuSurface_.close(skipRestoreFocus);
            },
            getElementIndex: function getElementIndex(element) {
                return _this.items.indexOf(element);
            },
            notifySelected: function notifySelected(evtData) {
                return _this.emit(constants_1.strings.SELECTED_EVENT, {
                    index: evtData.index,
                    item: _this.items[evtData.index]
                });
            },
            getMenuItemCount: function getMenuItemCount() {
                return _this.items.length;
            },
            focusItemAtIndex: function focusItemAtIndex(index) {
                return _this.items[index].focus();
            },
            focusListRoot: function focusListRoot() {
                return _this.root_.querySelector(constants_1.strings.LIST_SELECTOR).focus();
            },
            isSelectableItemAtIndex: function isSelectableItemAtIndex(index) {
                return !!ponyfill_1.closest(_this.items[index], "." + constants_1.cssClasses.MENU_SELECTION_GROUP);
            },
            getSelectedSiblingOfItemAtIndex: function getSelectedSiblingOfItemAtIndex(index) {
                var selectionGroupEl = ponyfill_1.closest(_this.items[index], "." + constants_1.cssClasses.MENU_SELECTION_GROUP);
                var selectedItemEl = selectionGroupEl.querySelector("." + constants_1.cssClasses.MENU_SELECTED_LIST_ITEM);
                return selectedItemEl ? _this.items.indexOf(selectedItemEl) : -1;
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_3.MDCMenuFoundation(adapter);
    };
    return MDCMenu;
}(component_1.MDCComponent);
exports.MDCMenu = MDCMenu;

/***/ }),

/***/ "./packages/mdc-menu/constants.ts":
/*!****************************************!*\
  !*** ./packages/mdc-menu/constants.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    MENU_SELECTED_LIST_ITEM: 'mdc-menu-item--selected',
    MENU_SELECTION_GROUP: 'mdc-menu__selection-group',
    ROOT: 'mdc-menu'
};
exports.cssClasses = cssClasses;
var strings = {
    ARIA_CHECKED_ATTR: 'aria-checked',
    ARIA_DISABLED_ATTR: 'aria-disabled',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    LIST_SELECTOR: '.mdc-list',
    SELECTED_EVENT: 'MDCMenu:selected'
};
exports.strings = strings;
var numbers = {
    FOCUS_ROOT_INDEX: -1
};
exports.numbers = numbers;
var DefaultFocusState;
(function (DefaultFocusState) {
    DefaultFocusState[DefaultFocusState["NONE"] = 0] = "NONE";
    DefaultFocusState[DefaultFocusState["LIST_ROOT"] = 1] = "LIST_ROOT";
    DefaultFocusState[DefaultFocusState["FIRST_ITEM"] = 2] = "FIRST_ITEM";
    DefaultFocusState[DefaultFocusState["LAST_ITEM"] = 3] = "LAST_ITEM";
})(DefaultFocusState || (DefaultFocusState = {}));
exports.DefaultFocusState = DefaultFocusState;

/***/ }),

/***/ "./packages/mdc-menu/foundation.ts":
/*!*****************************************!*\
  !*** ./packages/mdc-menu/foundation.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! @material/list/constants */ "./packages/mdc-list/constants.ts");
var foundation_2 = __webpack_require__(/*! @material/menu-surface/foundation */ "./packages/mdc-menu-surface/foundation.ts");
var constants_2 = __webpack_require__(/*! ./constants */ "./packages/mdc-menu/constants.ts");
var MDCMenuFoundation = /** @class */function (_super) {
    __extends(MDCMenuFoundation, _super);
    function MDCMenuFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCMenuFoundation.defaultAdapter), adapter)) || this;
        _this.closeAnimationEndTimerId_ = 0;
        _this.defaultFocusState_ = constants_2.DefaultFocusState.LIST_ROOT;
        return _this;
    }
    Object.defineProperty(MDCMenuFoundation, "cssClasses", {
        get: function get() {
            return constants_2.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuFoundation, "strings", {
        get: function get() {
            return constants_2.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuFoundation, "numbers", {
        get: function get() {
            return constants_2.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuFoundation, "defaultAdapter", {
        /**
         * @see {@link MDCMenuAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClassToElementAtIndex: function addClassToElementAtIndex() {
                    return undefined;
                },
                removeClassFromElementAtIndex: function removeClassFromElementAtIndex() {
                    return undefined;
                },
                addAttributeToElementAtIndex: function addAttributeToElementAtIndex() {
                    return undefined;
                },
                removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex() {
                    return undefined;
                },
                elementContainsClass: function elementContainsClass() {
                    return false;
                },
                closeSurface: function closeSurface() {
                    return undefined;
                },
                getElementIndex: function getElementIndex() {
                    return -1;
                },
                notifySelected: function notifySelected() {
                    return undefined;
                },
                getMenuItemCount: function getMenuItemCount() {
                    return 0;
                },
                focusItemAtIndex: function focusItemAtIndex() {
                    return undefined;
                },
                focusListRoot: function focusListRoot() {
                    return undefined;
                },
                getSelectedSiblingOfItemAtIndex: function getSelectedSiblingOfItemAtIndex() {
                    return -1;
                },
                isSelectableItemAtIndex: function isSelectableItemAtIndex() {
                    return false;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCMenuFoundation.prototype.destroy = function () {
        if (this.closeAnimationEndTimerId_) {
            clearTimeout(this.closeAnimationEndTimerId_);
        }
        this.adapter_.closeSurface();
    };
    MDCMenuFoundation.prototype.handleKeydown = function (evt) {
        var key = evt.key,
            keyCode = evt.keyCode;
        var isTab = key === 'Tab' || keyCode === 9;
        if (isTab) {
            this.adapter_.closeSurface( /** skipRestoreFocus */true);
        }
    };
    MDCMenuFoundation.prototype.handleItemAction = function (listItem) {
        var _this = this;
        var index = this.adapter_.getElementIndex(listItem);
        if (index < 0) {
            return;
        }
        this.adapter_.notifySelected({ index: index });
        this.adapter_.closeSurface();
        // Wait for the menu to close before adding/removing classes that affect styles.
        this.closeAnimationEndTimerId_ = setTimeout(function () {
            // Recompute the index in case the menu contents have changed.
            var recomputedIndex = _this.adapter_.getElementIndex(listItem);
            if (_this.adapter_.isSelectableItemAtIndex(recomputedIndex)) {
                _this.setSelectedIndex(recomputedIndex);
            }
        }, foundation_2.MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
    };
    MDCMenuFoundation.prototype.handleMenuSurfaceOpened = function () {
        switch (this.defaultFocusState_) {
            case constants_2.DefaultFocusState.FIRST_ITEM:
                this.adapter_.focusItemAtIndex(0);
                break;
            case constants_2.DefaultFocusState.LAST_ITEM:
                this.adapter_.focusItemAtIndex(this.adapter_.getMenuItemCount() - 1);
                break;
            case constants_2.DefaultFocusState.NONE:
                // Do nothing.
                break;
            default:
                this.adapter_.focusListRoot();
                break;
        }
    };
    /**
     * Sets default focus state where the menu should focus every time when menu
     * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
     * default.
     */
    MDCMenuFoundation.prototype.setDefaultFocusState = function (focusState) {
        this.defaultFocusState_ = focusState;
    };
    /**
     * Selects the list item at `index` within the menu.
     * @param index Index of list item within the menu.
     */
    MDCMenuFoundation.prototype.setSelectedIndex = function (index) {
        this.validatedIndex_(index);
        if (!this.adapter_.isSelectableItemAtIndex(index)) {
            throw new Error('MDCMenuFoundation: No selection group at specified index.');
        }
        var prevSelectedIndex = this.adapter_.getSelectedSiblingOfItemAtIndex(index);
        if (prevSelectedIndex >= 0) {
            this.adapter_.removeAttributeFromElementAtIndex(prevSelectedIndex, constants_2.strings.ARIA_CHECKED_ATTR);
            this.adapter_.removeClassFromElementAtIndex(prevSelectedIndex, constants_2.cssClasses.MENU_SELECTED_LIST_ITEM);
        }
        this.adapter_.addClassToElementAtIndex(index, constants_2.cssClasses.MENU_SELECTED_LIST_ITEM);
        this.adapter_.addAttributeToElementAtIndex(index, constants_2.strings.ARIA_CHECKED_ATTR, 'true');
    };
    /**
     * Sets the enabled state to isEnabled for the menu item at the given index.
     * @param index Index of the menu item
     * @param isEnabled The desired enabled state of the menu item.
     */
    MDCMenuFoundation.prototype.setEnabled = function (index, isEnabled) {
        this.validatedIndex_(index);
        if (isEnabled) {
            this.adapter_.removeClassFromElementAtIndex(index, constants_1.cssClasses.LIST_ITEM_DISABLED_CLASS);
            this.adapter_.addAttributeToElementAtIndex(index, constants_2.strings.ARIA_DISABLED_ATTR, 'false');
        } else {
            this.adapter_.addClassToElementAtIndex(index, constants_1.cssClasses.LIST_ITEM_DISABLED_CLASS);
            this.adapter_.addAttributeToElementAtIndex(index, constants_2.strings.ARIA_DISABLED_ATTR, 'true');
        }
    };
    MDCMenuFoundation.prototype.validatedIndex_ = function (index) {
        var menuSize = this.adapter_.getMenuItemCount();
        var isIndexInRange = index >= 0 && index < menuSize;
        if (!isIndexInRange) {
            throw new Error('MDCMenuFoundation: No list item at specified index.');
        }
    };
    return MDCMenuFoundation;
}(foundation_1.MDCFoundation);
exports.MDCMenuFoundation = MDCMenuFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCMenuFoundation;

/***/ }),

/***/ "./packages/mdc-menu/index.ts":
/*!************************************!*\
  !*** ./packages/mdc-menu/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(/*! @material/menu-surface/constants */ "./packages/mdc-menu-surface/constants.ts"); // for backward compatibility
exports.Corner = constants_1.Corner;
__export(__webpack_require__(/*! ./component */ "./packages/mdc-menu/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-menu/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-menu/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-notched-outline/component.ts":
/*!***************************************************!*\
  !*** ./packages/mdc-notched-outline/component.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! @material/floating-label/foundation */ "./packages/mdc-floating-label/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-notched-outline/constants.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-notched-outline/foundation.ts");
var MDCNotchedOutline = /** @class */function (_super) {
    __extends(MDCNotchedOutline, _super);
    function MDCNotchedOutline() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCNotchedOutline.attachTo = function (root) {
        return new MDCNotchedOutline(root);
    };
    MDCNotchedOutline.prototype.initialSyncWithDOM = function () {
        this.notchElement_ = this.root_.querySelector(constants_1.strings.NOTCH_ELEMENT_SELECTOR);
        var label = this.root_.querySelector('.' + foundation_1.MDCFloatingLabelFoundation.cssClasses.ROOT);
        if (label) {
            label.style.transitionDuration = '0s';
            this.root_.classList.add(constants_1.cssClasses.OUTLINE_UPGRADED);
            requestAnimationFrame(function () {
                label.style.transitionDuration = '';
            });
        } else {
            this.root_.classList.add(constants_1.cssClasses.NO_LABEL);
        }
    };
    /**
     * Updates classes and styles to open the notch to the specified width.
     * @param notchWidth The notch width in the outline.
     */
    MDCNotchedOutline.prototype.notch = function (notchWidth) {
        this.foundation_.notch(notchWidth);
    };
    /**
     * Updates classes and styles to close the notch.
     */
    MDCNotchedOutline.prototype.closeNotch = function () {
        this.foundation_.closeNotch();
    };
    MDCNotchedOutline.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            setNotchWidthProperty: function setNotchWidthProperty(width) {
                return _this.notchElement_.style.setProperty('width', width + 'px');
            },
            removeNotchWidthProperty: function removeNotchWidthProperty() {
                return _this.notchElement_.style.removeProperty('width');
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_2.MDCNotchedOutlineFoundation(adapter);
    };
    return MDCNotchedOutline;
}(component_1.MDCComponent);
exports.MDCNotchedOutline = MDCNotchedOutline;

/***/ }),

/***/ "./packages/mdc-notched-outline/constants.ts":
/*!***************************************************!*\
  !*** ./packages/mdc-notched-outline/constants.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var strings = {
    NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch'
};
exports.strings = strings;
var numbers = {
    // This should stay in sync with $mdc-notched-outline-padding * 2.
    NOTCH_ELEMENT_PADDING: 8
};
exports.numbers = numbers;
var cssClasses = {
    NO_LABEL: 'mdc-notched-outline--no-label',
    OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
    OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded'
};
exports.cssClasses = cssClasses;

/***/ }),

/***/ "./packages/mdc-notched-outline/foundation.ts":
/*!****************************************************!*\
  !*** ./packages/mdc-notched-outline/foundation.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-notched-outline/constants.ts");
var MDCNotchedOutlineFoundation = /** @class */function (_super) {
    __extends(MDCNotchedOutlineFoundation, _super);
    function MDCNotchedOutlineFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCNotchedOutlineFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCNotchedOutlineFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation, "defaultAdapter", {
        /**
         * See {@link MDCNotchedOutlineAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                setNotchWidthProperty: function setNotchWidthProperty() {
                    return undefined;
                },
                removeNotchWidthProperty: function removeNotchWidthProperty() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds the outline notched selector and updates the notch width calculated based off of notchWidth.
     */
    MDCNotchedOutlineFoundation.prototype.notch = function (notchWidth) {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
        if (notchWidth > 0) {
            notchWidth += constants_1.numbers.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
        }
        this.adapter_.setNotchWidthProperty(notchWidth);
        this.adapter_.addClass(OUTLINE_NOTCHED);
    };
    /**
     * Removes notched outline selector to close the notch in the outline.
     */
    MDCNotchedOutlineFoundation.prototype.closeNotch = function () {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
        this.adapter_.removeClass(OUTLINE_NOTCHED);
        this.adapter_.removeNotchWidthProperty();
    };
    return MDCNotchedOutlineFoundation;
}(foundation_1.MDCFoundation);
exports.MDCNotchedOutlineFoundation = MDCNotchedOutlineFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCNotchedOutlineFoundation;

/***/ }),

/***/ "./packages/mdc-notched-outline/index.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-notched-outline/index.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-notched-outline/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-notched-outline/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-notched-outline/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-radio/component.ts":
/*!*****************************************!*\
  !*** ./packages/mdc-radio/component.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var events_1 = __webpack_require__(/*! @material/dom/events */ "./packages/mdc-dom/events.ts");
var component_2 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! @material/ripple/foundation */ "./packages/mdc-ripple/foundation.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-radio/foundation.ts");
var MDCRadio = /** @class */function (_super) {
    __extends(MDCRadio, _super);
    function MDCRadio() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ripple_ = _this.createRipple_();
        return _this;
    }
    MDCRadio.attachTo = function (root) {
        return new MDCRadio(root);
    };
    Object.defineProperty(MDCRadio.prototype, "checked", {
        get: function get() {
            return this.nativeControl_.checked;
        },
        set: function set(checked) {
            this.nativeControl_.checked = checked;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadio.prototype, "disabled", {
        get: function get() {
            return this.nativeControl_.disabled;
        },
        set: function set(disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadio.prototype, "value", {
        get: function get() {
            return this.nativeControl_.value;
        },
        set: function set(value) {
            this.nativeControl_.value = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadio.prototype, "ripple", {
        get: function get() {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    MDCRadio.prototype.destroy = function () {
        this.ripple_.destroy();
        _super.prototype.destroy.call(this);
    };
    MDCRadio.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            setNativeControlDisabled: function setNativeControlDisabled(disabled) {
                return _this.nativeControl_.disabled = disabled;
            }
        };
        return new foundation_2.MDCRadioFoundation(adapter);
    };
    MDCRadio.prototype.createRipple_ = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = __assign(__assign({}, component_2.MDCRipple.createAdapter(this)), { registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                return _this.nativeControl_.addEventListener(evtType, handler, events_1.applyPassive());
            }, deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                return _this.nativeControl_.removeEventListener(evtType, handler, events_1.applyPassive());
            },
            // Radio buttons technically go "active" whenever there is *any* keyboard interaction.
            // This is not the UI we desire.
            isSurfaceActive: function isSurfaceActive() {
                return false;
            }, isUnbounded: function isUnbounded() {
                return true;
            } });
        // tslint:enable:object-literal-sort-keys
        return new component_2.MDCRipple(this.root_, new foundation_1.MDCRippleFoundation(adapter));
    };
    Object.defineProperty(MDCRadio.prototype, "nativeControl_", {
        get: function get() {
            var NATIVE_CONTROL_SELECTOR = foundation_2.MDCRadioFoundation.strings.NATIVE_CONTROL_SELECTOR;
            var el = this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
            if (!el) {
                throw new Error("Radio component requires a " + NATIVE_CONTROL_SELECTOR + " element");
            }
            return el;
        },
        enumerable: true,
        configurable: true
    });
    return MDCRadio;
}(component_1.MDCComponent);
exports.MDCRadio = MDCRadio;

/***/ }),

/***/ "./packages/mdc-radio/constants.ts":
/*!*****************************************!*\
  !*** ./packages/mdc-radio/constants.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var strings = {
    NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
};
exports.strings = strings;
var cssClasses = {
    DISABLED: 'mdc-radio--disabled',
    ROOT: 'mdc-radio'
};
exports.cssClasses = cssClasses;

/***/ }),

/***/ "./packages/mdc-radio/foundation.ts":
/*!******************************************!*\
  !*** ./packages/mdc-radio/foundation.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-radio/constants.ts");
var MDCRadioFoundation = /** @class */function (_super) {
    __extends(MDCRadioFoundation, _super);
    function MDCRadioFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCRadioFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCRadioFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadioFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadioFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                setNativeControlDisabled: function setNativeControlDisabled() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCRadioFoundation.prototype.setDisabled = function (disabled) {
        var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;
        this.adapter_.setNativeControlDisabled(disabled);
        if (disabled) {
            this.adapter_.addClass(DISABLED);
        } else {
            this.adapter_.removeClass(DISABLED);
        }
    };
    return MDCRadioFoundation;
}(foundation_1.MDCFoundation);
exports.MDCRadioFoundation = MDCRadioFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCRadioFoundation;

/***/ }),

/***/ "./packages/mdc-radio/index.ts":
/*!*************************************!*\
  !*** ./packages/mdc-radio/index.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-radio/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-radio/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-radio/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-ripple/component.ts":
/*!******************************************!*\
  !*** ./packages/mdc-ripple/component.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var events_1 = __webpack_require__(/*! @material/dom/events */ "./packages/mdc-dom/events.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-ripple/foundation.ts");
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-ripple/util.ts"));
var MDCRipple = /** @class */function (_super) {
    __extends(MDCRipple, _super);
    function MDCRipple() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.disabled = false;
        return _this;
    }
    MDCRipple.attachTo = function (root, opts) {
        if (opts === void 0) {
            opts = { isUnbounded: undefined };
        }
        var ripple = new MDCRipple(root);
        // Only override unbounded behavior if option is explicitly specified
        if (opts.isUnbounded !== undefined) {
            ripple.unbounded = opts.isUnbounded;
        }
        return ripple;
    };
    MDCRipple.createAdapter = function (instance) {
        return {
            addClass: function addClass(className) {
                return instance.root_.classList.add(className);
            },
            browserSupportsCssVars: function browserSupportsCssVars() {
                return util.supportsCssVariables(window);
            },
            computeBoundingRect: function computeBoundingRect() {
                return instance.root_.getBoundingClientRect();
            },
            containsEventTarget: function containsEventTarget(target) {
                return instance.root_.contains(target);
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
                return document.documentElement.removeEventListener(evtType, handler, events_1.applyPassive());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                return instance.root_.removeEventListener(evtType, handler, events_1.applyPassive());
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
                return window.removeEventListener('resize', handler);
            },
            getWindowPageOffset: function getWindowPageOffset() {
                return { x: window.pageXOffset, y: window.pageYOffset };
            },
            isSurfaceActive: function isSurfaceActive() {
                return ponyfill_1.matches(instance.root_, ':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
                return Boolean(instance.disabled);
            },
            isUnbounded: function isUnbounded() {
                return Boolean(instance.unbounded);
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
                return document.documentElement.addEventListener(evtType, handler, events_1.applyPassive());
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                return instance.root_.addEventListener(evtType, handler, events_1.applyPassive());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
                return window.addEventListener('resize', handler);
            },
            removeClass: function removeClass(className) {
                return instance.root_.classList.remove(className);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
                return instance.root_.style.setProperty(varName, value);
            }
        };
    };
    Object.defineProperty(MDCRipple.prototype, "unbounded", {
        get: function get() {
            return Boolean(this.unbounded_);
        },
        set: function set(unbounded) {
            this.unbounded_ = Boolean(unbounded);
            this.setUnbounded_();
        },
        enumerable: true,
        configurable: true
    });
    MDCRipple.prototype.activate = function () {
        this.foundation_.activate();
    };
    MDCRipple.prototype.deactivate = function () {
        this.foundation_.deactivate();
    };
    MDCRipple.prototype.layout = function () {
        this.foundation_.layout();
    };
    MDCRipple.prototype.getDefaultFoundation = function () {
        return new foundation_1.MDCRippleFoundation(MDCRipple.createAdapter(this));
    };
    MDCRipple.prototype.initialSyncWithDOM = function () {
        var root = this.root_;
        this.unbounded = 'mdcRippleIsUnbounded' in root.dataset;
    };
    /**
     * Closure Compiler throws an access control error when directly accessing a
     * protected or private property inside a getter/setter, like unbounded above.
     * By accessing the protected property inside a method, we solve that problem.
     * That's why this function exists.
     */
    MDCRipple.prototype.setUnbounded_ = function () {
        this.foundation_.setUnbounded(Boolean(this.unbounded_));
    };
    return MDCRipple;
}(component_1.MDCComponent);
exports.MDCRipple = MDCRipple;

/***/ }),

/***/ "./packages/mdc-ripple/constants.ts":
/*!******************************************!*\
  !*** ./packages/mdc-ripple/constants.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.cssClasses = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded'
};
exports.strings = {
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top'
};
exports.numbers = {
    DEACTIVATION_TIMEOUT_MS: 225,
    FG_DEACTIVATION_MS: 150,
    INITIAL_ORIGIN_SCALE: 0.6,
    PADDING: 10,
    TAP_DELAY_MS: 300
};

/***/ }),

/***/ "./packages/mdc-ripple/foundation.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-ripple/foundation.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-ripple/constants.ts");
var util_1 = __webpack_require__(/*! ./util */ "./packages/mdc-ripple/util.ts");
// Activation events registered on the root element of each instance for activation
var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];
// Deactivation events registered on documentElement when a pointer-related down event occurs
var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu'];
// simultaneous nested activations
var activatedTargets = [];
var MDCRippleFoundation = /** @class */function (_super) {
    __extends(MDCRippleFoundation, _super);
    function MDCRippleFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation.defaultAdapter), adapter)) || this;
        _this.activationAnimationHasEnded_ = false;
        _this.activationTimer_ = 0;
        _this.fgDeactivationRemovalTimer_ = 0;
        _this.fgScale_ = '0';
        _this.frame_ = { width: 0, height: 0 };
        _this.initialSize_ = 0;
        _this.layoutFrame_ = 0;
        _this.maxRadius_ = 0;
        _this.unboundedCoords_ = { left: 0, top: 0 };
        _this.activationState_ = _this.defaultActivationState_();
        _this.activationTimerCallback_ = function () {
            _this.activationAnimationHasEnded_ = true;
            _this.runDeactivationUXLogicIfReady_();
        };
        _this.activateHandler_ = function (e) {
            return _this.activate_(e);
        };
        _this.deactivateHandler_ = function () {
            return _this.deactivate_();
        };
        _this.focusHandler_ = function () {
            return _this.handleFocus();
        };
        _this.blurHandler_ = function () {
            return _this.handleBlur();
        };
        _this.resizeHandler_ = function () {
            return _this.layout();
        };
        return _this;
    }
    Object.defineProperty(MDCRippleFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRippleFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRippleFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                browserSupportsCssVars: function browserSupportsCssVars() {
                    return true;
                },
                computeBoundingRect: function computeBoundingRect() {
                    return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
                },
                containsEventTarget: function containsEventTarget() {
                    return true;
                },
                deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() {
                    return undefined;
                },
                deregisterInteractionHandler: function deregisterInteractionHandler() {
                    return undefined;
                },
                deregisterResizeHandler: function deregisterResizeHandler() {
                    return undefined;
                },
                getWindowPageOffset: function getWindowPageOffset() {
                    return { x: 0, y: 0 };
                },
                isSurfaceActive: function isSurfaceActive() {
                    return true;
                },
                isSurfaceDisabled: function isSurfaceDisabled() {
                    return true;
                },
                isUnbounded: function isUnbounded() {
                    return true;
                },
                registerDocumentInteractionHandler: function registerDocumentInteractionHandler() {
                    return undefined;
                },
                registerInteractionHandler: function registerInteractionHandler() {
                    return undefined;
                },
                registerResizeHandler: function registerResizeHandler() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                updateCssVariable: function updateCssVariable() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCRippleFoundation.prototype.init = function () {
        var _this = this;
        var supportsPressRipple = this.supportsPressRipple_();
        this.registerRootHandlers_(supportsPressRipple);
        if (supportsPressRipple) {
            var _a = MDCRippleFoundation.cssClasses,
                ROOT_1 = _a.ROOT,
                UNBOUNDED_1 = _a.UNBOUNDED;
            requestAnimationFrame(function () {
                _this.adapter_.addClass(ROOT_1);
                if (_this.adapter_.isUnbounded()) {
                    _this.adapter_.addClass(UNBOUNDED_1);
                    // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
                    _this.layoutInternal_();
                }
            });
        }
    };
    MDCRippleFoundation.prototype.destroy = function () {
        var _this = this;
        if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
                clearTimeout(this.activationTimer_);
                this.activationTimer_ = 0;
                this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }
            if (this.fgDeactivationRemovalTimer_) {
                clearTimeout(this.fgDeactivationRemovalTimer_);
                this.fgDeactivationRemovalTimer_ = 0;
                this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }
            var _a = MDCRippleFoundation.cssClasses,
                ROOT_2 = _a.ROOT,
                UNBOUNDED_2 = _a.UNBOUNDED;
            requestAnimationFrame(function () {
                _this.adapter_.removeClass(ROOT_2);
                _this.adapter_.removeClass(UNBOUNDED_2);
                _this.removeCssVars_();
            });
        }
        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();
    };
    /**
     * @param evt Optional event containing position information.
     */
    MDCRippleFoundation.prototype.activate = function (evt) {
        this.activate_(evt);
    };
    MDCRippleFoundation.prototype.deactivate = function () {
        this.deactivate_();
    };
    MDCRippleFoundation.prototype.layout = function () {
        var _this = this;
        if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
            _this.layoutInternal_();
            _this.layoutFrame_ = 0;
        });
    };
    MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;
        if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
        } else {
            this.adapter_.removeClass(UNBOUNDED);
        }
    };
    MDCRippleFoundation.prototype.handleFocus = function () {
        var _this = this;
        requestAnimationFrame(function () {
            return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
    };
    MDCRippleFoundation.prototype.handleBlur = function () {
        var _this = this;
        requestAnimationFrame(function () {
            return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
    };
    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     */
    MDCRippleFoundation.prototype.supportsPressRipple_ = function () {
        return this.adapter_.browserSupportsCssVars();
    };
    MDCRippleFoundation.prototype.defaultActivationState_ = function () {
        return {
            activationEvent: undefined,
            hasDeactivationUXRun: false,
            isActivated: false,
            isProgrammatic: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false
        };
    };
    /**
     * supportsPressRipple Passed from init to save a redundant function call
     */
    MDCRippleFoundation.prototype.registerRootHandlers_ = function (supportsPressRipple) {
        var _this = this;
        if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                _this.adapter_.registerInteractionHandler(evtType, _this.activateHandler_);
            });
            if (this.adapter_.isUnbounded()) {
                this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
        }
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
    };
    MDCRippleFoundation.prototype.registerDeactivationHandlers_ = function (evt) {
        var _this = this;
        if (evt.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
            POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                _this.adapter_.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
            });
        }
    };
    MDCRippleFoundation.prototype.deregisterRootHandlers_ = function () {
        var _this = this;
        ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
            _this.adapter_.deregisterInteractionHandler(evtType, _this.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
    };
    MDCRippleFoundation.prototype.deregisterDeactivationHandlers_ = function () {
        var _this = this;
        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
            _this.adapter_.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
        });
    };
    MDCRippleFoundation.prototype.removeCssVars_ = function () {
        var _this = this;
        var rippleStrings = MDCRippleFoundation.strings;
        var keys = Object.keys(rippleStrings);
        keys.forEach(function (key) {
            if (key.indexOf('VAR_') === 0) {
                _this.adapter_.updateCssVariable(rippleStrings[key], null);
            }
        });
    };
    MDCRippleFoundation.prototype.activate_ = function (evt) {
        var _this = this;
        if (this.adapter_.isSurfaceDisabled()) {
            return;
        }
        var activationState = this.activationState_;
        if (activationState.isActivated) {
            return;
        }
        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;
        if (isSameInteraction) {
            return;
        }
        activationState.isActivated = true;
        activationState.isProgrammatic = evt === undefined;
        activationState.activationEvent = evt;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === 'mousedown' || evt.type === 'touchstart' || evt.type === 'pointerdown');
        var hasActivatedChild = evt !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) {
            return _this.adapter_.containsEventTarget(target);
        });
        if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
        }
        if (evt !== undefined) {
            activatedTargets.push(evt.target);
            this.registerDeactivationHandlers_(evt);
        }
        activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);
        if (activationState.wasElementMadeActive) {
            this.animateActivation_();
        }
        requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets = [];
            if (!activationState.wasElementMadeActive && evt !== undefined && (evt.key === ' ' || evt.keyCode === 32)) {
                // If space was pressed, try again within an rAF call to detect :active, because different UAs report
                // active states inconsistently when they're called within event handling code:
                // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
                // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
                // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
                // variable is set within a rAF callback for a submit button interaction (#2241).
                activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);
                if (activationState.wasElementMadeActive) {
                    _this.animateActivation_();
                }
            }
            if (!activationState.wasElementMadeActive) {
                // Reset activation state immediately if element was not made active.
                _this.activationState_ = _this.defaultActivationState_();
            }
        });
    };
    MDCRippleFoundation.prototype.checkElementMadeActive_ = function (evt) {
        return evt !== undefined && evt.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
    };
    MDCRippleFoundation.prototype.animateActivation_ = function () {
        var _this = this;
        var _a = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
        var _b = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _b.FG_DEACTIVATION,
            FG_ACTIVATION = _b.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
        this.layoutInternal_();
        var translateStart = '';
        var translateEnd = '';
        if (!this.adapter_.isUnbounded()) {
            var _c = this.getFgTranslationCoordinates_(),
                startPoint = _c.startPoint,
                endPoint = _c.endPoint;
            translateStart = startPoint.x + "px, " + startPoint.y + "px";
            translateEnd = endPoint.x + "px, " + endPoint.y + "px";
        }
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
        // Cancel any ongoing activation/deactivation animations
        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION);
        // Force layout in order to re-trigger the animation.
        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
            return _this.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
    };
    MDCRippleFoundation.prototype.getFgTranslationCoordinates_ = function () {
        var _a = this.activationState_,
            activationEvent = _a.activationEvent,
            wasActivatedByPointer = _a.wasActivatedByPointer;
        var startPoint;
        if (wasActivatedByPointer) {
            startPoint = util_1.getNormalizedEventCoords(activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
            startPoint = {
                x: this.frame_.width / 2,
                y: this.frame_.height / 2
            };
        }
        // Center the element around the start point.
        startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
        };
        var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
        };
        return { startPoint: startPoint, endPoint: endPoint };
    };
    MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady_ = function () {
        var _this = this;
        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _a = this.activationState_,
            hasDeactivationUXRun = _a.hasDeactivationUXRun,
            isActivated = _a.isActivated;
        var activationHasEnded = hasDeactivationUXRun || !isActivated;
        if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
                _this.adapter_.removeClass(FG_DEACTIVATION);
            }, constants_1.numbers.FG_DEACTIVATION_MS);
        }
    };
    MDCRippleFoundation.prototype.rmBoundedActivationClasses_ = function () {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
    };
    MDCRippleFoundation.prototype.resetActivationState_ = function () {
        var _this = this;
        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_();
        // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.
        setTimeout(function () {
            return _this.previousActivationEvent_ = undefined;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
    };
    MDCRippleFoundation.prototype.deactivate_ = function () {
        var _this = this;
        var activationState = this.activationState_;
        // This can happen in scenarios such as when you have a keyup event that blurs the element.
        if (!activationState.isActivated) {
            return;
        }
        var state = __assign({}, activationState);
        if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
                return _this.animateDeactivation_(state);
            });
            this.resetActivationState_();
        } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
                _this.activationState_.hasDeactivationUXRun = true;
                _this.animateDeactivation_(state);
                _this.resetActivationState_();
            });
        }
    };
    MDCRippleFoundation.prototype.animateDeactivation_ = function (_a) {
        var wasActivatedByPointer = _a.wasActivatedByPointer,
            wasElementMadeActive = _a.wasElementMadeActive;
        if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
        }
    };
    MDCRippleFoundation.prototype.layoutInternal_ = function () {
        var _this = this;
        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width);
        // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.
        var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };
        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();
        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
        var initialSize = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
        // Unbounded ripple size should always be even number to equally center align.
        if (this.adapter_.isUnbounded() && initialSize % 2 !== 0) {
            this.initialSize_ = initialSize - 1;
        } else {
            this.initialSize_ = initialSize;
        }
        this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
        this.updateLayoutCssVars_();
    };
    MDCRippleFoundation.prototype.updateLayoutCssVars_ = function () {
        var _a = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _a.VAR_FG_SIZE,
            VAR_LEFT = _a.VAR_LEFT,
            VAR_TOP = _a.VAR_TOP,
            VAR_FG_SCALE = _a.VAR_FG_SCALE;
        this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);
        if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
                left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
                top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
            this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
        }
    };
    return MDCRippleFoundation;
}(foundation_1.MDCFoundation);
exports.MDCRippleFoundation = MDCRippleFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCRippleFoundation;

/***/ }),

/***/ "./packages/mdc-ripple/index.ts":
/*!**************************************!*\
  !*** ./packages/mdc-ripple/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-ripple/util.ts"));
exports.util = util;
__export(__webpack_require__(/*! ./component */ "./packages/mdc-ripple/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-ripple/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-ripple/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-ripple/util.ts":
/*!*************************************!*\
  !*** ./packages/mdc-ripple/util.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Stores result from supportsCssVariables to avoid redundant processing to
 * detect CSS custom variable support.
 */
var supportsCssVariables_;
function supportsCssVariables(windowObj, forceRefresh) {
    if (forceRefresh === void 0) {
        forceRefresh = false;
    }
    var CSS = windowObj.CSS;
    var supportsCssVars = supportsCssVariables_;
    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
        return supportsCssVariables_;
    }
    var supportsFunctionPresent = CSS && typeof CSS.supports === 'function';
    if (!supportsFunctionPresent) {
        return false;
    }
    var explicitlySupportsCssVars = CSS.supports('--css-vars', 'yes');
    // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari
    var weAreFeatureDetectingSafari10plus = CSS.supports('(--css-vars: yes)') && CSS.supports('color', '#00000000');
    supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
    if (!forceRefresh) {
        supportsCssVariables_ = supportsCssVars;
    }
    return supportsCssVars;
}
exports.supportsCssVariables = supportsCssVariables;
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
    if (!evt) {
        return { x: 0, y: 0 };
    }
    var x = pageOffset.x,
        y = pageOffset.y;
    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;
    var normalizedX;
    var normalizedY;
    // Determine touch point relative to the ripple container.
    if (evt.type === 'touchstart') {
        var touchEvent = evt;
        normalizedX = touchEvent.changedTouches[0].pageX - documentX;
        normalizedY = touchEvent.changedTouches[0].pageY - documentY;
    } else {
        var mouseEvent = evt;
        normalizedX = mouseEvent.pageX - documentX;
        normalizedY = mouseEvent.pageY - documentY;
    }
    return { x: normalizedX, y: normalizedY };
}
exports.getNormalizedEventCoords = getNormalizedEventCoords;

/***/ }),

/***/ "./packages/mdc-select/component.ts":
/*!******************************************!*\
  !*** ./packages/mdc-select/component.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var component_2 = __webpack_require__(/*! @material/floating-label/component */ "./packages/mdc-floating-label/component.ts");
var component_3 = __webpack_require__(/*! @material/line-ripple/component */ "./packages/mdc-line-ripple/component.ts");
var menuSurfaceConstants = __importStar(__webpack_require__(/*! @material/menu-surface/constants */ "./packages/mdc-menu-surface/constants.ts"));
var component_4 = __webpack_require__(/*! @material/menu/component */ "./packages/mdc-menu/component.ts");
var menuConstants = __importStar(__webpack_require__(/*! @material/menu/constants */ "./packages/mdc-menu/constants.ts"));
var component_5 = __webpack_require__(/*! @material/notched-outline/component */ "./packages/mdc-notched-outline/component.ts");
var component_6 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! @material/ripple/foundation */ "./packages/mdc-ripple/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-select/constants.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-select/foundation.ts");
var component_7 = __webpack_require__(/*! ./helper-text/component */ "./packages/mdc-select/helper-text/component.ts");
var component_8 = __webpack_require__(/*! ./icon/component */ "./packages/mdc-select/icon/component.ts");
var MDCSelect = /** @class */function (_super) {
    __extends(MDCSelect, _super);
    function MDCSelect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSelect.attachTo = function (root) {
        return new MDCSelect(root);
    };
    MDCSelect.prototype.initialize = function (labelFactory, lineRippleFactory, outlineFactory, menuFactory, iconFactory, helperTextFactory) {
        if (labelFactory === void 0) {
            labelFactory = function labelFactory(el) {
                return new component_2.MDCFloatingLabel(el);
            };
        }
        if (lineRippleFactory === void 0) {
            lineRippleFactory = function lineRippleFactory(el) {
                return new component_3.MDCLineRipple(el);
            };
        }
        if (outlineFactory === void 0) {
            outlineFactory = function outlineFactory(el) {
                return new component_5.MDCNotchedOutline(el);
            };
        }
        if (menuFactory === void 0) {
            menuFactory = function menuFactory(el) {
                return new component_4.MDCMenu(el);
            };
        }
        if (iconFactory === void 0) {
            iconFactory = function iconFactory(el) {
                return new component_8.MDCSelectIcon(el);
            };
        }
        if (helperTextFactory === void 0) {
            helperTextFactory = function helperTextFactory(el) {
                return new component_7.MDCSelectHelperText(el);
            };
        }
        this.selectAnchor = this.root_.querySelector(constants_1.strings.SELECT_ANCHOR_SELECTOR);
        this.selectedText = this.root_.querySelector(constants_1.strings.SELECTED_TEXT_SELECTOR);
        if (!this.selectedText) {
            throw new Error('MDCSelect: Missing required element: The following selector must be present: ' + ("'" + constants_1.strings.SELECTED_TEXT_SELECTOR + "'"));
        }
        if (this.selectAnchor.hasAttribute(constants_1.strings.ARIA_CONTROLS)) {
            var helperTextElement = document.getElementById(this.selectAnchor.getAttribute(constants_1.strings.ARIA_CONTROLS));
            if (helperTextElement) {
                this.helperText = helperTextFactory(helperTextElement);
            }
        }
        this.menuSetup(menuFactory);
        var labelElement = this.root_.querySelector(constants_1.strings.LABEL_SELECTOR);
        this.label = labelElement ? labelFactory(labelElement) : null;
        var lineRippleElement = this.root_.querySelector(constants_1.strings.LINE_RIPPLE_SELECTOR);
        this.lineRipple = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
        var outlineElement = this.root_.querySelector(constants_1.strings.OUTLINE_SELECTOR);
        this.outline = outlineElement ? outlineFactory(outlineElement) : null;
        var leadingIcon = this.root_.querySelector(constants_1.strings.LEADING_ICON_SELECTOR);
        if (leadingIcon) {
            this.leadingIcon = iconFactory(leadingIcon);
        }
        if (!this.root_.classList.contains(constants_1.cssClasses.OUTLINED)) {
            this.ripple = this.createRipple();
        }
    };
    /**
     * Initializes the select's event listeners and internal state based
     * on the environment's state.
     */
    MDCSelect.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleChange = function () {
            _this.foundation_.handleChange();
        };
        this.handleFocus = function () {
            _this.foundation_.handleFocus();
        };
        this.handleBlur = function () {
            _this.foundation_.handleBlur();
        };
        this.handleClick = function (evt) {
            _this.selectAnchor.focus();
            _this.foundation_.handleClick(_this.getNormalizedXCoordinate(evt));
        };
        this.handleKeydown = function (evt) {
            _this.foundation_.handleKeydown(evt);
        };
        this.handleMenuItemAction = function (evt) {
            _this.foundation_.handleMenuItemAction(evt.detail.index);
        };
        this.handleMenuOpened = function () {
            _this.foundation_.handleMenuOpened();
        };
        this.handleMenuClosed = function () {
            _this.foundation_.handleMenuClosed();
        };
        this.selectAnchor.addEventListener('focus', this.handleFocus);
        this.selectAnchor.addEventListener('blur', this.handleBlur);
        this.selectAnchor.addEventListener('click', this.handleClick);
        this.selectAnchor.addEventListener('keydown', this.handleKeydown);
        this.menu.listen(menuSurfaceConstants.strings.CLOSED_EVENT, this.handleMenuClosed);
        this.menu.listen(menuSurfaceConstants.strings.OPENED_EVENT, this.handleMenuOpened);
        this.menu.listen(menuConstants.strings.SELECTED_EVENT, this.handleMenuItemAction);
        this.foundation_.init();
    };
    MDCSelect.prototype.destroy = function () {
        this.selectAnchor.removeEventListener('change', this.handleChange);
        this.selectAnchor.removeEventListener('focus', this.handleFocus);
        this.selectAnchor.removeEventListener('blur', this.handleBlur);
        this.selectAnchor.removeEventListener('keydown', this.handleKeydown);
        this.selectAnchor.removeEventListener('click', this.handleClick);
        this.menu.unlisten(menuSurfaceConstants.strings.CLOSED_EVENT, this.handleMenuClosed);
        this.menu.unlisten(menuSurfaceConstants.strings.OPENED_EVENT, this.handleMenuOpened);
        this.menu.unlisten(menuConstants.strings.SELECTED_EVENT, this.handleMenuItemAction);
        this.menu.destroy();
        if (this.ripple) {
            this.ripple.destroy();
        }
        if (this.outline) {
            this.outline.destroy();
        }
        if (this.leadingIcon) {
            this.leadingIcon.destroy();
        }
        if (this.helperText) {
            this.helperText.destroy();
        }
        _super.prototype.destroy.call(this);
    };
    Object.defineProperty(MDCSelect.prototype, "value", {
        get: function get() {
            return this.foundation_.getValue();
        },
        set: function set(value) {
            this.foundation_.setValue(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "selectedIndex", {
        get: function get() {
            return this.foundation_.getSelectedIndex();
        },
        set: function set(selectedIndex) {
            this.foundation_.setSelectedIndex(selectedIndex, /** closeMenu */true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "disabled", {
        get: function get() {
            return this.foundation_.getDisabled();
        },
        set: function set(disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "leadingIconAriaLabel", {
        set: function set(label) {
            this.foundation_.setLeadingIconAriaLabel(label);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "leadingIconContent", {
        /**
         * Sets the text content of the leading icon.
         */
        set: function set(content) {
            this.foundation_.setLeadingIconContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "helperTextContent", {
        /**
         * Sets the text content of the helper text.
         */
        set: function set(content) {
            this.foundation_.setHelperTextContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "valid", {
        /**
         * Checks if the select is in a valid state.
         */
        get: function get() {
            return this.foundation_.isValid();
        },
        /**
         * Sets the current invalid state of the select.
         */
        set: function set(isValid) {
            this.foundation_.setValid(isValid);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "required", {
        /**
         * Returns whether the select is required.
         */
        get: function get() {
            return this.foundation_.getRequired();
        },
        /**
         * Sets the control to the required state.
         */
        set: function set(isRequired) {
            this.foundation_.setRequired(isRequired);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Recomputes the outline SVG path for the outline element.
     */
    MDCSelect.prototype.layout = function () {
        this.foundation_.layout();
    };
    MDCSelect.prototype.getDefaultFoundation = function () {
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = __assign(__assign(__assign(__assign({}, this.getSelectAdapterMethods()), this.getCommonAdapterMethods()), this.getOutlineAdapterMethods()), this.getLabelAdapterMethods());
        return new foundation_2.MDCSelectFoundation(adapter, this.getFoundationMap());
    };
    /**
     * Handles setup for the menu.
     */
    MDCSelect.prototype.menuSetup = function (menuFactory) {
        this.menuElement = this.root_.querySelector(constants_1.strings.MENU_SELECTOR);
        this.menu = menuFactory(this.menuElement);
    };
    MDCSelect.prototype.createRipple = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = __assign(__assign({}, component_6.MDCRipple.createAdapter({ root_: this.selectAnchor })), { registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                _this.selectAnchor.addEventListener(evtType, handler);
            }, deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                _this.selectAnchor.removeEventListener(evtType, handler);
            } });
        // tslint:enable:object-literal-sort-keys
        return new component_6.MDCRipple(this.selectAnchor, new foundation_1.MDCRippleFoundation(adapter));
    };
    MDCSelect.prototype.getSelectAdapterMethods = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            getSelectedMenuItem: function getSelectedMenuItem() {
                return _this.menuElement.querySelector(constants_1.strings.SELECTED_ITEM_SELECTOR);
            },
            getMenuItemAttr: function getMenuItemAttr(menuItem, attr) {
                return menuItem.getAttribute(attr);
            },
            setSelectedText: function setSelectedText(text) {
                _this.selectedText.value = text;
            },
            isSelectAnchorFocused: function isSelectAnchorFocused() {
                return document.activeElement === _this.selectAnchor;
            },
            getSelectAnchorAttr: function getSelectAnchorAttr(attr) {
                return _this.selectAnchor.getAttribute(attr);
            },
            setSelectAnchorAttr: function setSelectAnchorAttr(attr, value) {
                _this.selectAnchor.setAttribute(attr, value);
            },
            openMenu: function openMenu() {
                _this.menu.open = true;
            },
            closeMenu: function closeMenu() {
                _this.menu.open = false;
            },
            getAnchorElement: function getAnchorElement() {
                return _this.root_.querySelector(constants_1.strings.SELECT_ANCHOR_SELECTOR);
            },
            setMenuAnchorElement: function setMenuAnchorElement(anchorEl) {
                _this.menu.setAnchorElement(anchorEl);
            },
            setMenuAnchorCorner: function setMenuAnchorCorner(anchorCorner) {
                _this.menu.setAnchorCorner(anchorCorner);
            },
            setMenuWrapFocus: function setMenuWrapFocus(wrapFocus) {
                _this.menu.wrapFocus = wrapFocus;
            },
            setAttributeAtIndex: function setAttributeAtIndex(index, attributeName, attributeValue) {
                _this.menu.items[index].setAttribute(attributeName, attributeValue);
            },
            removeAttributeAtIndex: function removeAttributeAtIndex(index, attributeName) {
                _this.menu.items[index].removeAttribute(attributeName);
            },
            focusMenuItemAtIndex: function focusMenuItemAtIndex(index) {
                _this.menu.items[index].focus();
            },
            getMenuItemCount: function getMenuItemCount() {
                return _this.menu.items.length;
            },
            getMenuItemValues: function getMenuItemValues() {
                return _this.menu.items.map(function (el) {
                    return el.getAttribute(constants_1.strings.VALUE_ATTR) || '';
                });
            },
            getMenuItemTextAtIndex: function getMenuItemTextAtIndex(index) {
                return _this.menu.items[index].textContent;
            },
            addClassAtIndex: function addClassAtIndex(index, className) {
                _this.menu.items[index].classList.add(className);
            },
            removeClassAtIndex: function removeClassAtIndex(index, className) {
                _this.menu.items[index].classList.remove(className);
            }
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCSelect.prototype.getCommonAdapterMethods = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            addClass: function addClass(className) {
                _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            setRippleCenter: function setRippleCenter(normalizedX) {
                _this.lineRipple && _this.lineRipple.setRippleCenter(normalizedX);
            },
            activateBottomLine: function activateBottomLine() {
                _this.lineRipple && _this.lineRipple.activate();
            },
            deactivateBottomLine: function deactivateBottomLine() {
                _this.lineRipple && _this.lineRipple.deactivate();
            },
            notifyChange: function notifyChange(value) {
                var index = _this.selectedIndex;
                _this.emit(constants_1.strings.CHANGE_EVENT, { value: value, index: index }, true /* shouldBubble  */);
            }
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCSelect.prototype.getOutlineAdapterMethods = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            hasOutline: function hasOutline() {
                return Boolean(_this.outline);
            },
            notchOutline: function notchOutline(labelWidth) {
                _this.outline && _this.outline.notch(labelWidth);
            },
            closeOutline: function closeOutline() {
                _this.outline && _this.outline.closeNotch();
            }
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCSelect.prototype.getLabelAdapterMethods = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            hasLabel: function hasLabel() {
                return !!_this.label;
            },
            floatLabel: function floatLabel(shouldFloat) {
                _this.label && _this.label.float(shouldFloat);
            },
            getLabelWidth: function getLabelWidth() {
                return _this.label ? _this.label.getWidth() : 0;
            }
        };
        // tslint:enable:object-literal-sort-keys
    };
    /**
     * Calculates where the line ripple should start based on the x coordinate within the component.
     */
    MDCSelect.prototype.getNormalizedXCoordinate = function (evt) {
        var targetClientRect = evt.target.getBoundingClientRect();
        var xCoordinate = this.isTouchEvent(evt) ? evt.touches[0].clientX : evt.clientX;
        return xCoordinate - targetClientRect.left;
    };
    MDCSelect.prototype.isTouchEvent = function (evt) {
        return Boolean(evt.touches);
    };
    /**
     * Returns a map of all subcomponents to subfoundations.
     */
    MDCSelect.prototype.getFoundationMap = function () {
        return {
            helperText: this.helperText ? this.helperText.foundation : undefined,
            leadingIcon: this.leadingIcon ? this.leadingIcon.foundation : undefined
        };
    };
    return MDCSelect;
}(component_1.MDCComponent);
exports.MDCSelect = MDCSelect;

/***/ }),

/***/ "./packages/mdc-select/constants.ts":
/*!******************************************!*\
  !*** ./packages/mdc-select/constants.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    ACTIVATED: 'mdc-select--activated',
    DISABLED: 'mdc-select--disabled',
    FOCUSED: 'mdc-select--focused',
    INVALID: 'mdc-select--invalid',
    OUTLINED: 'mdc-select--outlined',
    REQUIRED: 'mdc-select--required',
    ROOT: 'mdc-select',
    SELECTED_ITEM_CLASS: 'mdc-list-item--selected',
    WITH_LEADING_ICON: 'mdc-select--with-leading-icon'
};
exports.cssClasses = cssClasses;
var strings = {
    ARIA_CONTROLS: 'aria-controls',
    ARIA_SELECTED_ATTR: 'aria-selected',
    CHANGE_EVENT: 'MDCSelect:change',
    LABEL_SELECTOR: '.mdc-floating-label',
    LEADING_ICON_SELECTOR: '.mdc-select__icon',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    MENU_SELECTOR: '.mdc-select__menu',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    SELECTED_ITEM_SELECTOR: "." + cssClasses.SELECTED_ITEM_CLASS,
    SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text',
    SELECT_ANCHOR_SELECTOR: '.mdc-select__anchor',
    VALUE_ATTR: 'data-value'
};
exports.strings = strings;
var numbers = {
    LABEL_SCALE: 0.75,
    UNSET_INDEX: -1
};
exports.numbers = numbers;

/***/ }),

/***/ "./packages/mdc-select/foundation.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-select/foundation.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! @material/menu-surface/constants */ "./packages/mdc-menu-surface/constants.ts");
var constants_2 = __webpack_require__(/*! ./constants */ "./packages/mdc-select/constants.ts");
var MDCSelectFoundation = /** @class */function (_super) {
    __extends(MDCSelectFoundation, _super);
    /* istanbul ignore next: optional argument is not a branch statement */
    /**
     * @param adapter
     * @param foundationMap Map from subcomponent names to their subfoundations.
     */
    function MDCSelectFoundation(adapter, foundationMap) {
        if (foundationMap === void 0) {
            foundationMap = {};
        }
        var _this = _super.call(this, __assign(__assign({}, MDCSelectFoundation.defaultAdapter), adapter)) || this;
        // Index of the currently selected menu item.
        _this.selectedIndex = constants_2.numbers.UNSET_INDEX;
        // Disabled state
        _this.disabled = false;
        // isMenuOpen is used to track the state of the menu by listening to the
        // MDCMenuSurface:closed event For reference, menu.open will return false if
        // the menu is still closing, but isMenuOpen returns false only after the menu
        // has closed
        _this.isMenuOpen = false;
        _this.leadingIcon = foundationMap.leadingIcon;
        _this.helperText = foundationMap.helperText;
        _this.menuItemValues = _this.adapter_.getMenuItemValues();
        _this.setDisabled(_this.adapter_.hasClass(constants_2.cssClasses.DISABLED));
        return _this;
    }
    Object.defineProperty(MDCSelectFoundation, "cssClasses", {
        get: function get() {
            return constants_2.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectFoundation, "numbers", {
        get: function get() {
            return constants_2.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectFoundation, "strings", {
        get: function get() {
            return constants_2.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectFoundation, "defaultAdapter", {
        /**
         * See {@link MDCSelectAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return false;
                },
                activateBottomLine: function activateBottomLine() {
                    return undefined;
                },
                deactivateBottomLine: function deactivateBottomLine() {
                    return undefined;
                },
                getSelectedMenuItem: function getSelectedMenuItem() {
                    return null;
                },
                hasLabel: function hasLabel() {
                    return false;
                },
                floatLabel: function floatLabel() {
                    return undefined;
                },
                getLabelWidth: function getLabelWidth() {
                    return 0;
                },
                hasOutline: function hasOutline() {
                    return false;
                },
                notchOutline: function notchOutline() {
                    return undefined;
                },
                closeOutline: function closeOutline() {
                    return undefined;
                },
                setRippleCenter: function setRippleCenter() {
                    return undefined;
                },
                notifyChange: function notifyChange() {
                    return undefined;
                },
                setSelectedText: function setSelectedText() {
                    return undefined;
                },
                isSelectAnchorFocused: function isSelectAnchorFocused() {
                    return false;
                },
                getSelectAnchorAttr: function getSelectAnchorAttr() {
                    return '';
                },
                setSelectAnchorAttr: function setSelectAnchorAttr() {
                    return undefined;
                },
                openMenu: function openMenu() {
                    return undefined;
                },
                closeMenu: function closeMenu() {
                    return undefined;
                },
                getAnchorElement: function getAnchorElement() {
                    return null;
                },
                setMenuAnchorElement: function setMenuAnchorElement() {
                    return undefined;
                },
                setMenuAnchorCorner: function setMenuAnchorCorner() {
                    return undefined;
                },
                setMenuWrapFocus: function setMenuWrapFocus() {
                    return undefined;
                },
                setAttributeAtIndex: function setAttributeAtIndex() {
                    return undefined;
                },
                removeAttributeAtIndex: function removeAttributeAtIndex() {
                    return undefined;
                },
                focusMenuItemAtIndex: function focusMenuItemAtIndex() {
                    return undefined;
                },
                getMenuItemCount: function getMenuItemCount() {
                    return 0;
                },
                getMenuItemValues: function getMenuItemValues() {
                    return [];
                },
                getMenuItemTextAtIndex: function getMenuItemTextAtIndex() {
                    return '';
                },
                getMenuItemAttr: function getMenuItemAttr() {
                    return '';
                },
                addClassAtIndex: function addClassAtIndex() {
                    return undefined;
                },
                removeClassAtIndex: function removeClassAtIndex() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /** Returns the index of the currently selected menu item, or -1 if none. */
    MDCSelectFoundation.prototype.getSelectedIndex = function () {
        return this.selectedIndex;
    };
    MDCSelectFoundation.prototype.setSelectedIndex = function (index, closeMenu) {
        if (closeMenu === void 0) {
            closeMenu = false;
        }
        if (index >= this.adapter_.getMenuItemCount()) {
            return;
        }
        var previouslySelectedIndex = this.selectedIndex;
        this.selectedIndex = index;
        if (this.selectedIndex === constants_2.numbers.UNSET_INDEX) {
            this.adapter_.setSelectedText('');
        } else {
            this.adapter_.setSelectedText(this.adapter_.getMenuItemTextAtIndex(this.selectedIndex).trim());
        }
        if (previouslySelectedIndex !== constants_2.numbers.UNSET_INDEX) {
            this.adapter_.removeClassAtIndex(previouslySelectedIndex, constants_2.cssClasses.SELECTED_ITEM_CLASS);
            this.adapter_.removeAttributeAtIndex(previouslySelectedIndex, constants_2.strings.ARIA_SELECTED_ATTR);
        }
        if (this.selectedIndex !== constants_2.numbers.UNSET_INDEX) {
            this.adapter_.addClassAtIndex(this.selectedIndex, constants_2.cssClasses.SELECTED_ITEM_CLASS);
            this.adapter_.setAttributeAtIndex(this.selectedIndex, constants_2.strings.ARIA_SELECTED_ATTR, 'true');
        }
        this.layout();
        if (closeMenu) {
            this.adapter_.closeMenu();
        }
        this.handleChange();
    };
    MDCSelectFoundation.prototype.setValue = function (value) {
        var index = this.menuItemValues.indexOf(value);
        this.setSelectedIndex(index);
    };
    MDCSelectFoundation.prototype.getValue = function () {
        var listItem = this.adapter_.getSelectedMenuItem();
        if (listItem) {
            return this.adapter_.getMenuItemAttr(listItem, constants_2.strings.VALUE_ATTR) || '';
        }
        return '';
    };
    MDCSelectFoundation.prototype.getDisabled = function () {
        return this.disabled;
    };
    MDCSelectFoundation.prototype.setDisabled = function (isDisabled) {
        this.disabled = isDisabled;
        if (this.disabled) {
            this.adapter_.addClass(constants_2.cssClasses.DISABLED);
            this.adapter_.closeMenu();
        } else {
            this.adapter_.removeClass(constants_2.cssClasses.DISABLED);
        }
        if (this.leadingIcon) {
            this.leadingIcon.setDisabled(this.disabled);
        }
        this.adapter_.setSelectAnchorAttr('tabindex', this.disabled ? '-1' : '0');
        this.adapter_.setSelectAnchorAttr('aria-disabled', this.disabled.toString());
    };
    /**
     * @param content Sets the content of the helper text.
     */
    MDCSelectFoundation.prototype.setHelperTextContent = function (content) {
        if (this.helperText) {
            this.helperText.setContent(content);
        }
    };
    MDCSelectFoundation.prototype.layout = function () {
        if (this.adapter_.hasLabel()) {
            var openNotch = this.getValue().length > 0;
            this.notchOutline(openNotch);
        }
    };
    MDCSelectFoundation.prototype.handleMenuOpened = function () {
        if (this.adapter_.getMenuItemValues().length === 0) {
            return;
        }
        this.adapter_.addClass(constants_2.cssClasses.ACTIVATED);
        // Menu should open to the last selected element, should open to first menu item otherwise.
        var focusItemIndex = this.selectedIndex >= 0 ? this.selectedIndex : 0;
        this.adapter_.focusMenuItemAtIndex(focusItemIndex);
    };
    MDCSelectFoundation.prototype.handleMenuClosed = function () {
        this.adapter_.removeClass(constants_2.cssClasses.ACTIVATED);
        this.isMenuOpen = false;
        this.adapter_.setSelectAnchorAttr('aria-expanded', 'false');
        // Unfocus the select if menu is closed without a selection
        if (!this.adapter_.isSelectAnchorFocused()) {
            this.blur();
        }
    };
    /**
     * Handles value changes, via change event or programmatic updates.
     */
    MDCSelectFoundation.prototype.handleChange = function () {
        this.updateLabel();
        this.adapter_.notifyChange(this.getValue());
        var isRequired = this.adapter_.hasClass(constants_2.cssClasses.REQUIRED);
        if (isRequired) {
            this.setValid(this.isValid());
            if (this.helperText) {
                this.helperText.setValidity(this.isValid());
            }
        }
    };
    MDCSelectFoundation.prototype.handleMenuItemAction = function (index) {
        this.setSelectedIndex(index, /** closeMenu */true);
    };
    /**
     * Handles focus events from select element.
     */
    MDCSelectFoundation.prototype.handleFocus = function () {
        this.adapter_.addClass(constants_2.cssClasses.FOCUSED);
        if (this.adapter_.hasLabel()) {
            this.notchOutline(true);
            this.adapter_.floatLabel(true);
        }
        this.adapter_.activateBottomLine();
        if (this.helperText) {
            this.helperText.showToScreenReader();
        }
    };
    /**
     * Handles blur events from select element.
     */
    MDCSelectFoundation.prototype.handleBlur = function () {
        if (this.isMenuOpen) {
            return;
        }
        this.blur();
    };
    MDCSelectFoundation.prototype.handleClick = function (normalizedX) {
        if (this.isMenuOpen) {
            return;
        }
        this.adapter_.setRippleCenter(normalizedX);
        this.adapter_.openMenu();
        this.isMenuOpen = true;
        this.adapter_.setSelectAnchorAttr('aria-expanded', 'true');
    };
    MDCSelectFoundation.prototype.handleKeydown = function (event) {
        if (this.isMenuOpen) {
            return;
        }
        var isEnter = event.key === 'Enter' || event.keyCode === 13;
        var isSpace = event.key === 'Space' || event.keyCode === 32;
        var arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
        var arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;
        if (this.adapter_.hasClass(constants_2.cssClasses.FOCUSED) && (isEnter || isSpace || arrowUp || arrowDown)) {
            this.adapter_.openMenu();
            this.isMenuOpen = true;
            this.adapter_.setSelectAnchorAttr('aria-expanded', 'true');
            event.preventDefault();
        }
    };
    /**
     * Opens/closes the notched outline.
     */
    MDCSelectFoundation.prototype.notchOutline = function (openNotch) {
        if (!this.adapter_.hasOutline()) {
            return;
        }
        var isFocused = this.adapter_.hasClass(constants_2.cssClasses.FOCUSED);
        if (openNotch) {
            var labelScale = constants_2.numbers.LABEL_SCALE;
            var labelWidth = this.adapter_.getLabelWidth() * labelScale;
            this.adapter_.notchOutline(labelWidth);
        } else if (!isFocused) {
            this.adapter_.closeOutline();
        }
    };
    /**
     * Sets the aria label of the leading icon.
     */
    MDCSelectFoundation.prototype.setLeadingIconAriaLabel = function (label) {
        if (this.leadingIcon) {
            this.leadingIcon.setAriaLabel(label);
        }
    };
    /**
     * Sets the text content of the leading icon.
     */
    MDCSelectFoundation.prototype.setLeadingIconContent = function (content) {
        if (this.leadingIcon) {
            this.leadingIcon.setContent(content);
        }
    };
    MDCSelectFoundation.prototype.setValid = function (isValid) {
        this.adapter_.setSelectAnchorAttr('aria-invalid', (!isValid).toString());
        if (isValid) {
            this.adapter_.removeClass(constants_2.cssClasses.INVALID);
        } else {
            this.adapter_.addClass(constants_2.cssClasses.INVALID);
        }
    };
    MDCSelectFoundation.prototype.isValid = function () {
        if (this.adapter_.hasClass(constants_2.cssClasses.REQUIRED) && !this.adapter_.hasClass(constants_2.cssClasses.DISABLED)) {
            // See notes for required attribute under https://www.w3.org/TR/html52/sec-forms.html#the-select-element
            // TL;DR: Invalid if no index is selected, or if the first index is selected and has an empty value.
            return this.selectedIndex !== constants_2.numbers.UNSET_INDEX && (this.selectedIndex !== 0 || Boolean(this.getValue()));
        }
        return true;
    };
    MDCSelectFoundation.prototype.setRequired = function (isRequired) {
        if (isRequired) {
            this.adapter_.addClass(constants_2.cssClasses.REQUIRED);
        } else {
            this.adapter_.removeClass(constants_2.cssClasses.REQUIRED);
        }
        this.adapter_.setSelectAnchorAttr('aria-required', isRequired.toString());
    };
    MDCSelectFoundation.prototype.getRequired = function () {
        return this.adapter_.getSelectAnchorAttr('aria-required') === 'true';
    };
    MDCSelectFoundation.prototype.init = function () {
        var anchorEl = this.adapter_.getAnchorElement();
        if (anchorEl) {
            this.adapter_.setMenuAnchorElement(anchorEl);
            this.adapter_.setMenuAnchorCorner(constants_1.Corner.BOTTOM_START);
        }
        this.adapter_.setMenuWrapFocus(false);
        var value = this.getValue();
        if (value) {
            this.setValue(value);
        }
        // Initially sync floating label
        this.updateLabel();
    };
    /**
     * Notches the outline and floats the label when appropriate.
     */
    MDCSelectFoundation.prototype.updateLabel = function () {
        var value = this.getValue();
        var optionHasValue = value.length > 0;
        if (this.adapter_.hasLabel()) {
            this.notchOutline(optionHasValue);
            if (!this.adapter_.hasClass(constants_2.cssClasses.FOCUSED)) {
                this.adapter_.floatLabel(optionHasValue);
            }
        }
    };
    /**
     * Unfocuses the select component.
     */
    MDCSelectFoundation.prototype.blur = function () {
        this.adapter_.removeClass(constants_2.cssClasses.FOCUSED);
        this.updateLabel();
        this.adapter_.deactivateBottomLine();
        var isRequired = this.adapter_.hasClass(constants_2.cssClasses.REQUIRED);
        if (isRequired) {
            this.setValid(this.isValid());
            if (this.helperText) {
                this.helperText.setValidity(this.isValid());
            }
        }
    };
    return MDCSelectFoundation;
}(foundation_1.MDCFoundation);
exports.MDCSelectFoundation = MDCSelectFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCSelectFoundation;

/***/ }),

/***/ "./packages/mdc-select/helper-text/component.ts":
/*!******************************************************!*\
  !*** ./packages/mdc-select/helper-text/component.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-select/helper-text/foundation.ts");
var MDCSelectHelperText = /** @class */function (_super) {
    __extends(MDCSelectHelperText, _super);
    function MDCSelectHelperText() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSelectHelperText.attachTo = function (root) {
        return new MDCSelectHelperText(root);
    };
    Object.defineProperty(MDCSelectHelperText.prototype, "foundation", {
        get: function get() {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCSelectHelperText.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            setAttr: function setAttr(attr, value) {
                return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
                return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
                _this.root_.textContent = content;
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_1.MDCSelectHelperTextFoundation(adapter);
    };
    return MDCSelectHelperText;
}(component_1.MDCComponent);
exports.MDCSelectHelperText = MDCSelectHelperText;

/***/ }),

/***/ "./packages/mdc-select/helper-text/constants.ts":
/*!******************************************************!*\
  !*** ./packages/mdc-select/helper-text/constants.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var strings = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role'
};
exports.strings = strings;
var cssClasses = {
    HELPER_TEXT_PERSISTENT: 'mdc-select-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-select-helper-text--validation-msg'
};
exports.cssClasses = cssClasses;

/***/ }),

/***/ "./packages/mdc-select/helper-text/foundation.ts":
/*!*******************************************************!*\
  !*** ./packages/mdc-select/helper-text/foundation.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-select/helper-text/constants.ts");
var MDCSelectHelperTextFoundation = /** @class */function (_super) {
    __extends(MDCSelectHelperTextFoundation, _super);
    function MDCSelectHelperTextFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCSelectHelperTextFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCSelectHelperTextFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectHelperTextFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectHelperTextFoundation, "defaultAdapter", {
        /**
         * See {@link MDCSelectHelperTextAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return false;
                },
                setAttr: function setAttr() {
                    return undefined;
                },
                removeAttr: function removeAttr() {
                    return undefined;
                },
                setContent: function setContent() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the content of the helper text field.
     */
    MDCSelectHelperTextFoundation.prototype.setContent = function (content) {
        this.adapter_.setContent(content);
    };
    /**
     *  Sets the persistency of the helper text.
     */
    MDCSelectHelperTextFoundation.prototype.setPersistent = function (isPersistent) {
        if (isPersistent) {
            this.adapter_.addClass(constants_1.cssClasses.HELPER_TEXT_PERSISTENT);
        } else {
            this.adapter_.removeClass(constants_1.cssClasses.HELPER_TEXT_PERSISTENT);
        }
    };
    /**
     * @param isValidation True to make the helper text act as an error validation message.
     */
    MDCSelectHelperTextFoundation.prototype.setValidation = function (isValidation) {
        if (isValidation) {
            this.adapter_.addClass(constants_1.cssClasses.HELPER_TEXT_VALIDATION_MSG);
        } else {
            this.adapter_.removeClass(constants_1.cssClasses.HELPER_TEXT_VALIDATION_MSG);
        }
    };
    /**
     * Makes the helper text visible to screen readers.
     */
    MDCSelectHelperTextFoundation.prototype.showToScreenReader = function () {
        this.adapter_.removeAttr(constants_1.strings.ARIA_HIDDEN);
    };
    /**
     * Sets the validity of the helper text based on the select validity.
     */
    MDCSelectHelperTextFoundation.prototype.setValidity = function (selectIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(constants_1.cssClasses.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(constants_1.cssClasses.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !selectIsValid;
        if (validationMsgNeedsDisplay) {
            this.adapter_.setAttr(constants_1.strings.ROLE, 'alert');
        } else {
            this.adapter_.removeAttr(constants_1.strings.ROLE);
        }
        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
            this.hide_();
        }
    };
    /**
     * Hides the help text from screen readers.
     */
    MDCSelectHelperTextFoundation.prototype.hide_ = function () {
        this.adapter_.setAttr(constants_1.strings.ARIA_HIDDEN, 'true');
    };
    return MDCSelectHelperTextFoundation;
}(foundation_1.MDCFoundation);
exports.MDCSelectHelperTextFoundation = MDCSelectHelperTextFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCSelectHelperTextFoundation;

/***/ }),

/***/ "./packages/mdc-select/helper-text/index.ts":
/*!**************************************************!*\
  !*** ./packages/mdc-select/helper-text/index.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-select/helper-text/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-select/helper-text/foundation.ts"));
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-select/helper-text/constants.ts");
exports.helperTextCssClasses = constants_1.cssClasses;
exports.helperTextStrings = constants_1.strings;

/***/ }),

/***/ "./packages/mdc-select/icon/component.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-select/icon/component.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-select/icon/foundation.ts");
var MDCSelectIcon = /** @class */function (_super) {
    __extends(MDCSelectIcon, _super);
    function MDCSelectIcon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSelectIcon.attachTo = function (root) {
        return new MDCSelectIcon(root);
    };
    Object.defineProperty(MDCSelectIcon.prototype, "foundation", {
        get: function get() {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCSelectIcon.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            getAttr: function getAttr(attr) {
                return _this.root_.getAttribute(attr);
            },
            setAttr: function setAttr(attr, value) {
                return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
                return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
                _this.root_.textContent = content;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                return _this.listen(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                return _this.unlisten(evtType, handler);
            },
            notifyIconAction: function notifyIconAction() {
                return _this.emit(foundation_1.MDCSelectIconFoundation.strings.ICON_EVENT, {} /* evtData */, true /* shouldBubble */);
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_1.MDCSelectIconFoundation(adapter);
    };
    return MDCSelectIcon;
}(component_1.MDCComponent);
exports.MDCSelectIcon = MDCSelectIcon;

/***/ }),

/***/ "./packages/mdc-select/icon/constants.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-select/icon/constants.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var strings = {
  ICON_EVENT: 'MDCSelect:icon',
  ICON_ROLE: 'button'
};
exports.strings = strings;

/***/ }),

/***/ "./packages/mdc-select/icon/foundation.ts":
/*!************************************************!*\
  !*** ./packages/mdc-select/icon/foundation.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-select/icon/constants.ts");
var INTERACTION_EVENTS = ['click', 'keydown'];
var MDCSelectIconFoundation = /** @class */function (_super) {
    __extends(MDCSelectIconFoundation, _super);
    function MDCSelectIconFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCSelectIconFoundation.defaultAdapter), adapter)) || this;
        _this.savedTabIndex_ = null;
        _this.interactionHandler_ = function (evt) {
            return _this.handleInteraction(evt);
        };
        return _this;
    }
    Object.defineProperty(MDCSelectIconFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectIconFoundation, "defaultAdapter", {
        /**
         * See {@link MDCSelectIconAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                getAttr: function getAttr() {
                    return null;
                },
                setAttr: function setAttr() {
                    return undefined;
                },
                removeAttr: function removeAttr() {
                    return undefined;
                },
                setContent: function setContent() {
                    return undefined;
                },
                registerInteractionHandler: function registerInteractionHandler() {
                    return undefined;
                },
                deregisterInteractionHandler: function deregisterInteractionHandler() {
                    return undefined;
                },
                notifyIconAction: function notifyIconAction() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCSelectIconFoundation.prototype.init = function () {
        var _this = this;
        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.adapter_.registerInteractionHandler(evtType, _this.interactionHandler_);
        });
    };
    MDCSelectIconFoundation.prototype.destroy = function () {
        var _this = this;
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.adapter_.deregisterInteractionHandler(evtType, _this.interactionHandler_);
        });
    };
    MDCSelectIconFoundation.prototype.setDisabled = function (disabled) {
        if (!this.savedTabIndex_) {
            return;
        }
        if (disabled) {
            this.adapter_.setAttr('tabindex', '-1');
            this.adapter_.removeAttr('role');
        } else {
            this.adapter_.setAttr('tabindex', this.savedTabIndex_);
            this.adapter_.setAttr('role', constants_1.strings.ICON_ROLE);
        }
    };
    MDCSelectIconFoundation.prototype.setAriaLabel = function (label) {
        this.adapter_.setAttr('aria-label', label);
    };
    MDCSelectIconFoundation.prototype.setContent = function (content) {
        this.adapter_.setContent(content);
    };
    MDCSelectIconFoundation.prototype.handleInteraction = function (evt) {
        var isEnterKey = evt.key === 'Enter' || evt.keyCode === 13;
        if (evt.type === 'click' || isEnterKey) {
            this.adapter_.notifyIconAction();
        }
    };
    return MDCSelectIconFoundation;
}(foundation_1.MDCFoundation);
exports.MDCSelectIconFoundation = MDCSelectIconFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCSelectIconFoundation;

/***/ }),

/***/ "./packages/mdc-select/icon/index.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-select/icon/index.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-select/icon/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-select/icon/foundation.ts"));
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-select/icon/constants.ts");
exports.iconStrings = constants_1.strings;

/***/ }),

/***/ "./packages/mdc-select/index.ts":
/*!**************************************!*\
  !*** ./packages/mdc-select/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-select/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-select/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-select/foundation.ts"));
__export(__webpack_require__(/*! ./helper-text/index */ "./packages/mdc-select/helper-text/index.ts"));
__export(__webpack_require__(/*! ./icon/index */ "./packages/mdc-select/icon/index.ts"));

/***/ }),

/***/ "./packages/mdc-slider/component.ts":
/*!******************************************!*\
  !*** ./packages/mdc-slider/component.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var events_1 = __webpack_require__(/*! @material/dom/events */ "./packages/mdc-dom/events.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-slider/constants.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-slider/foundation.ts");
var MDCSlider = /** @class */function (_super) {
    __extends(MDCSlider, _super);
    function MDCSlider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSlider.attachTo = function (root) {
        return new MDCSlider(root);
    };
    Object.defineProperty(MDCSlider.prototype, "value", {
        get: function get() {
            return this.foundation_.getValue();
        },
        set: function set(value) {
            this.foundation_.setValue(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSlider.prototype, "min", {
        get: function get() {
            return this.foundation_.getMin();
        },
        set: function set(min) {
            this.foundation_.setMin(min);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSlider.prototype, "max", {
        get: function get() {
            return this.foundation_.getMax();
        },
        set: function set(max) {
            this.foundation_.setMax(max);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSlider.prototype, "step", {
        get: function get() {
            return this.foundation_.getStep();
        },
        set: function set(step) {
            this.foundation_.setStep(step);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSlider.prototype, "disabled", {
        get: function get() {
            return this.foundation_.isDisabled();
        },
        set: function set(disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    MDCSlider.prototype.initialize = function () {
        this.thumbContainer_ = this.root_.querySelector(constants_1.strings.THUMB_CONTAINER_SELECTOR);
        this.track_ = this.root_.querySelector(constants_1.strings.TRACK_SELECTOR);
        this.pinValueMarker_ = this.root_.querySelector(constants_1.strings.PIN_VALUE_MARKER_SELECTOR);
        this.trackMarkerContainer_ = this.root_.querySelector(constants_1.strings.TRACK_MARKER_CONTAINER_SELECTOR);
    };
    MDCSlider.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take
        // a Partial<MDCFooAdapter>. To ensure we don't accidentally omit any
        // methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same
        // order as the adapter interface.
        var adapter = {
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            getAttribute: function getAttribute(name) {
                return _this.root_.getAttribute(name);
            },
            setAttribute: function setAttribute(name, value) {
                return _this.root_.setAttribute(name, value);
            },
            removeAttribute: function removeAttribute(name) {
                return _this.root_.removeAttribute(name);
            },
            computeBoundingRect: function computeBoundingRect() {
                return _this.root_.getBoundingClientRect();
            },
            getTabIndex: function getTabIndex() {
                return _this.root_.tabIndex;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                return _this.listen(evtType, handler, events_1.applyPassive());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                return _this.unlisten(evtType, handler, events_1.applyPassive());
            },
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(evtType, handler) {
                _this.thumbContainer_.addEventListener(evtType, handler, events_1.applyPassive());
            },
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(evtType, handler) {
                _this.thumbContainer_.removeEventListener(evtType, handler, events_1.applyPassive());
            },
            registerBodyInteractionHandler: function registerBodyInteractionHandler(evtType, handler) {
                return document.body.addEventListener(evtType, handler);
            },
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(evtType, handler) {
                return document.body.removeEventListener(evtType, handler);
            },
            registerResizeHandler: function registerResizeHandler(handler) {
                return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
                return window.removeEventListener('resize', handler);
            },
            notifyInput: function notifyInput() {
                return _this.emit(constants_1.strings.INPUT_EVENT, _this);
            },
            notifyChange: function notifyChange() {
                return _this.emit(constants_1.strings.CHANGE_EVENT, _this);
            },
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
                _this.thumbContainer_.style.setProperty(propertyName, value);
            },
            setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
                return _this.track_.style.setProperty(propertyName, value);
            },
            setMarkerValue: function setMarkerValue(value) {
                return _this.pinValueMarker_.innerText = value.toLocaleString();
            },
            setTrackMarkers: function setTrackMarkers(step, max, min) {
                var stepStr = step.toLocaleString();
                var maxStr = max.toLocaleString();
                var minStr = min.toLocaleString();
                // keep calculation in css for better rounding/subpixel behavior
                var markerAmount = "((" + maxStr + " - " + minStr + ") / " + stepStr + ")";
                var markerWidth = "2px";
                var markerBkgdImage = "linear-gradient(to right, currentColor " + markerWidth + ", transparent 0)";
                var markerBkgdLayout = "0 center / calc((100% - " + markerWidth + ") / " + markerAmount + ") 100% repeat-x";
                var markerBkgdShorthand = markerBkgdImage + " " + markerBkgdLayout;
                _this.trackMarkerContainer_.style.setProperty('background', markerBkgdShorthand);
            },
            isRTL: function isRTL() {
                return getComputedStyle(_this.root_).direction === 'rtl';
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_1.MDCSliderFoundation(adapter);
    };
    MDCSlider.prototype.initialSyncWithDOM = function () {
        var origValueNow = this.parseFloat_(this.root_.getAttribute(constants_1.strings.ARIA_VALUENOW), this.value);
        var min = this.parseFloat_(this.root_.getAttribute(constants_1.strings.ARIA_VALUEMIN), this.min);
        var max = this.parseFloat_(this.root_.getAttribute(constants_1.strings.ARIA_VALUEMAX), this.max);
        // min and max need to be set in the right order to avoid throwing an error
        // when the new min is greater than the default max.
        if (min >= this.max) {
            this.max = max;
            this.min = min;
        } else {
            this.min = min;
            this.max = max;
        }
        this.step = this.parseFloat_(this.root_.getAttribute(constants_1.strings.STEP_DATA_ATTR), this.step);
        this.value = origValueNow;
        this.disabled = this.root_.hasAttribute(constants_1.strings.ARIA_DISABLED) && this.root_.getAttribute(constants_1.strings.ARIA_DISABLED) !== 'false';
        this.foundation_.setupTrackMarker();
    };
    MDCSlider.prototype.layout = function () {
        this.foundation_.layout();
    };
    MDCSlider.prototype.stepUp = function (amount) {
        if (amount === void 0) {
            amount = this.step || 1;
        }
        this.value += amount;
    };
    MDCSlider.prototype.stepDown = function (amount) {
        if (amount === void 0) {
            amount = this.step || 1;
        }
        this.value -= amount;
    };
    MDCSlider.prototype.parseFloat_ = function (str, defaultValue) {
        var num = parseFloat(str); // tslint:disable-line:ban
        var isNumeric = typeof num === 'number' && isFinite(num);
        return isNumeric ? num : defaultValue;
    };
    return MDCSlider;
}(component_1.MDCComponent);
exports.MDCSlider = MDCSlider;

/***/ }),

/***/ "./packages/mdc-slider/constants.ts":
/*!******************************************!*\
  !*** ./packages/mdc-slider/constants.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    ACTIVE: 'mdc-slider--active',
    DISABLED: 'mdc-slider--disabled',
    DISCRETE: 'mdc-slider--discrete',
    FOCUS: 'mdc-slider--focus',
    HAS_TRACK_MARKER: 'mdc-slider--display-markers',
    IN_TRANSIT: 'mdc-slider--in-transit',
    IS_DISCRETE: 'mdc-slider--discrete'
};
exports.cssClasses = cssClasses;
var strings = {
    ARIA_DISABLED: 'aria-disabled',
    ARIA_VALUEMAX: 'aria-valuemax',
    ARIA_VALUEMIN: 'aria-valuemin',
    ARIA_VALUENOW: 'aria-valuenow',
    CHANGE_EVENT: 'MDCSlider:change',
    INPUT_EVENT: 'MDCSlider:input',
    PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
    STEP_DATA_ATTR: 'data-step',
    THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
    TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
    TRACK_SELECTOR: '.mdc-slider__track'
};
exports.strings = strings;
var numbers = {
    PAGE_FACTOR: 4
};
exports.numbers = numbers;

/***/ }),

/***/ "./packages/mdc-slider/foundation.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-slider/foundation.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(/*! @material/animation/util */ "./packages/mdc-animation/util.ts");
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-slider/constants.ts");
var hasPointer = !!window.PointerEvent;
var DOWN_EVENTS = hasPointer ? ['pointerdown'] : ['mousedown', 'touchstart'];
var UP_EVENTS = hasPointer ? ['pointerup'] : ['mouseup', 'touchend'];
var MOVE_EVENT_MAP = {
    mousedown: 'mousemove',
    pointerdown: 'pointermove',
    touchstart: 'touchmove'
};
var KEY_IDS = {
    ARROW_DOWN: 'ArrowDown',
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    END: 'End',
    HOME: 'Home',
    PAGE_DOWN: 'PageDown',
    PAGE_UP: 'PageUp'
};
var MDCSliderFoundation = /** @class */function (_super) {
    __extends(MDCSliderFoundation, _super);
    function MDCSliderFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCSliderFoundation.defaultAdapter), adapter)) || this;
        /**
         * We set this to NaN since we want it to be a number, but we can't use '0' or
         * '-1' because those could be valid tabindices set by the client code.
         */
        _this.savedTabIndex_ = NaN;
        _this.active_ = false;
        _this.inTransit_ = false;
        _this.isDiscrete_ = false;
        _this.hasTrackMarker_ = false;
        _this.handlingThumbTargetEvt_ = false;
        _this.min_ = 0;
        _this.max_ = 100;
        _this.step_ = 0;
        _this.value_ = 0;
        _this.disabled_ = false;
        _this.preventFocusState_ = false;
        _this.thumbContainerPointerHandler_ = function () {
            return _this.handlingThumbTargetEvt_ = true;
        };
        _this.interactionStartHandler_ = function (evt) {
            return _this.handleDown_(evt);
        };
        _this.keydownHandler_ = function (evt) {
            return _this.handleKeydown_(evt);
        };
        _this.focusHandler_ = function () {
            return _this.handleFocus_();
        };
        _this.blurHandler_ = function () {
            return _this.handleBlur_();
        };
        _this.resizeHandler_ = function () {
            return _this.layout();
        };
        return _this;
    }
    Object.defineProperty(MDCSliderFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSliderFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSliderFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSliderFoundation, "defaultAdapter", {
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same
            // order as the adapter interface.
            return {
                hasClass: function hasClass() {
                    return false;
                },
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                getAttribute: function getAttribute() {
                    return null;
                },
                setAttribute: function setAttribute() {
                    return undefined;
                },
                removeAttribute: function removeAttribute() {
                    return undefined;
                },
                computeBoundingRect: function computeBoundingRect() {
                    return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
                },
                getTabIndex: function getTabIndex() {
                    return 0;
                },
                registerInteractionHandler: function registerInteractionHandler() {
                    return undefined;
                },
                deregisterInteractionHandler: function deregisterInteractionHandler() {
                    return undefined;
                },
                registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler() {
                    return undefined;
                },
                deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler() {
                    return undefined;
                },
                registerBodyInteractionHandler: function registerBodyInteractionHandler() {
                    return undefined;
                },
                deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler() {
                    return undefined;
                },
                registerResizeHandler: function registerResizeHandler() {
                    return undefined;
                },
                deregisterResizeHandler: function deregisterResizeHandler() {
                    return undefined;
                },
                notifyInput: function notifyInput() {
                    return undefined;
                },
                notifyChange: function notifyChange() {
                    return undefined;
                },
                setThumbContainerStyleProperty: function setThumbContainerStyleProperty() {
                    return undefined;
                },
                setTrackStyleProperty: function setTrackStyleProperty() {
                    return undefined;
                },
                setMarkerValue: function setMarkerValue() {
                    return undefined;
                },
                setTrackMarkers: function setTrackMarkers() {
                    return undefined;
                },
                isRTL: function isRTL() {
                    return false;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCSliderFoundation.prototype.init = function () {
        var _this = this;
        this.isDiscrete_ = this.adapter_.hasClass(constants_1.cssClasses.IS_DISCRETE);
        this.hasTrackMarker_ = this.adapter_.hasClass(constants_1.cssClasses.HAS_TRACK_MARKER);
        DOWN_EVENTS.forEach(function (evtName) {
            _this.adapter_.registerInteractionHandler(evtName, _this.interactionStartHandler_);
            _this.adapter_.registerThumbContainerInteractionHandler(evtName, _this.thumbContainerPointerHandler_);
        });
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.layout();
        // At last step, provide a reasonable default value to discrete slider
        if (this.isDiscrete_ && this.getStep() === 0) {
            this.step_ = 1;
        }
    };
    MDCSliderFoundation.prototype.destroy = function () {
        var _this = this;
        DOWN_EVENTS.forEach(function (evtName) {
            _this.adapter_.deregisterInteractionHandler(evtName, _this.interactionStartHandler_);
            _this.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this.thumbContainerPointerHandler_);
        });
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    };
    MDCSliderFoundation.prototype.setupTrackMarker = function () {
        if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() !== 0) {
            this.adapter_.setTrackMarkers(this.getStep(), this.getMax(), this.getMin());
        }
    };
    MDCSliderFoundation.prototype.layout = function () {
        this.rect_ = this.adapter_.computeBoundingRect();
        this.updateUIForCurrentValue_();
    };
    MDCSliderFoundation.prototype.getValue = function () {
        return this.value_;
    };
    MDCSliderFoundation.prototype.setValue = function (value) {
        this.setValue_(value, false);
    };
    MDCSliderFoundation.prototype.getMax = function () {
        return this.max_;
    };
    MDCSliderFoundation.prototype.setMax = function (max) {
        if (max < this.min_) {
            throw new Error('Cannot set max to be less than the slider\'s minimum value');
        }
        this.max_ = max;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(constants_1.strings.ARIA_VALUEMAX, String(this.max_));
        this.setupTrackMarker();
    };
    MDCSliderFoundation.prototype.getMin = function () {
        return this.min_;
    };
    MDCSliderFoundation.prototype.setMin = function (min) {
        if (min > this.max_) {
            throw new Error('Cannot set min to be greater than the slider\'s maximum value');
        }
        this.min_ = min;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(constants_1.strings.ARIA_VALUEMIN, String(this.min_));
        this.setupTrackMarker();
    };
    MDCSliderFoundation.prototype.getStep = function () {
        return this.step_;
    };
    MDCSliderFoundation.prototype.setStep = function (step) {
        if (step < 0) {
            throw new Error('Step cannot be set to a negative number');
        }
        if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
            step = 1;
        }
        this.step_ = step;
        this.setValue_(this.value_, false, true);
        this.setupTrackMarker();
    };
    MDCSliderFoundation.prototype.isDisabled = function () {
        return this.disabled_;
    };
    MDCSliderFoundation.prototype.setDisabled = function (disabled) {
        this.disabled_ = disabled;
        this.toggleClass_(constants_1.cssClasses.DISABLED, this.disabled_);
        if (this.disabled_) {
            this.savedTabIndex_ = this.adapter_.getTabIndex();
            this.adapter_.setAttribute(constants_1.strings.ARIA_DISABLED, 'true');
            this.adapter_.removeAttribute('tabindex');
        } else {
            this.adapter_.removeAttribute(constants_1.strings.ARIA_DISABLED);
            if (!isNaN(this.savedTabIndex_)) {
                this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
            }
        }
    };
    /**
     * Called when the user starts interacting with the slider
     */
    MDCSliderFoundation.prototype.handleDown_ = function (downEvent) {
        var _this = this;
        if (this.disabled_) {
            return;
        }
        this.preventFocusState_ = true;
        this.setInTransit_(!this.handlingThumbTargetEvt_);
        this.handlingThumbTargetEvt_ = false;
        this.setActive_(true);
        var moveHandler = function moveHandler(moveEvent) {
            _this.handleMove_(moveEvent);
        };
        var moveEventType = MOVE_EVENT_MAP[downEvent.type];
        // Note: upHandler is [de]registered on ALL potential pointer-related
        // release event types, since some browsers do not always fire these
        // consistently in pairs. (See
        // https://github.com/material-components/material-components-web/issues/1192)
        var upHandler = function upHandler() {
            _this.handleUp_();
            _this.adapter_.deregisterBodyInteractionHandler(moveEventType, moveHandler);
            UP_EVENTS.forEach(function (evtName) {
                return _this.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
            });
        };
        this.adapter_.registerBodyInteractionHandler(moveEventType, moveHandler);
        UP_EVENTS.forEach(function (evtName) {
            return _this.adapter_.registerBodyInteractionHandler(evtName, upHandler);
        });
        this.setValueFromEvt_(downEvent);
    };
    /**
     * Called when the user moves the slider
     */
    MDCSliderFoundation.prototype.handleMove_ = function (evt) {
        evt.preventDefault();
        this.setValueFromEvt_(evt);
    };
    /**
     * Called when the user's interaction with the slider ends
     */
    MDCSliderFoundation.prototype.handleUp_ = function () {
        this.setActive_(false);
        this.adapter_.notifyChange();
    };
    /**
     * Returns the clientX of the event
     */
    MDCSliderFoundation.prototype.getClientX_ = function (evt) {
        if (evt.targetTouches && evt.targetTouches.length > 0) {
            return evt.targetTouches[0].clientX;
        }
        return evt.clientX;
    };
    /**
     * Sets the slider value from an event
     */
    MDCSliderFoundation.prototype.setValueFromEvt_ = function (evt) {
        var clientX = this.getClientX_(evt);
        var value = this.computeValueFromClientX_(clientX);
        this.setValue_(value, true);
    };
    /**
     * Computes the new value from the clientX position
     */
    MDCSliderFoundation.prototype.computeValueFromClientX_ = function (clientX) {
        var _a = this,
            max = _a.max_,
            min = _a.min_;
        var xPos = clientX - this.rect_.left;
        var pctComplete = xPos / this.rect_.width;
        if (this.adapter_.isRTL()) {
            pctComplete = 1 - pctComplete;
        }
        // Fit the percentage complete between the range [min,max]
        // by remapping from [0, 1] to [min, min+(max-min)].
        return min + pctComplete * (max - min);
    };
    /**
     * Handles keydown events
     */
    MDCSliderFoundation.prototype.handleKeydown_ = function (evt) {
        var keyId = this.getKeyId_(evt);
        var value = this.getValueForKeyId_(keyId);
        if (isNaN(value)) {
            return;
        }
        // Prevent page from scrolling due to key presses that would normally scroll
        // the page
        evt.preventDefault();
        this.adapter_.addClass(constants_1.cssClasses.FOCUS);
        this.setValue_(value, true);
        this.adapter_.notifyChange();
    };
    /**
     * Returns the computed name of the event
     */
    MDCSliderFoundation.prototype.getKeyId_ = function (kbdEvt) {
        if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
            return KEY_IDS.ARROW_LEFT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
            return KEY_IDS.ARROW_RIGHT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
            return KEY_IDS.ARROW_UP;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
            return KEY_IDS.ARROW_DOWN;
        }
        if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
            return KEY_IDS.HOME;
        }
        if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
            return KEY_IDS.END;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
            return KEY_IDS.PAGE_UP;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
            return KEY_IDS.PAGE_DOWN;
        }
        return '';
    };
    /**
     * Computes the value given a keyboard key ID
     */
    MDCSliderFoundation.prototype.getValueForKeyId_ = function (keyId) {
        var _a = this,
            max = _a.max_,
            min = _a.min_,
            step = _a.step_;
        var delta = step || (max - min) / 100;
        var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);
        if (valueNeedsToBeFlipped) {
            delta = -delta;
        }
        switch (keyId) {
            case KEY_IDS.ARROW_LEFT:
            case KEY_IDS.ARROW_DOWN:
                return this.value_ - delta;
            case KEY_IDS.ARROW_RIGHT:
            case KEY_IDS.ARROW_UP:
                return this.value_ + delta;
            case KEY_IDS.HOME:
                return this.min_;
            case KEY_IDS.END:
                return this.max_;
            case KEY_IDS.PAGE_UP:
                return this.value_ + delta * constants_1.numbers.PAGE_FACTOR;
            case KEY_IDS.PAGE_DOWN:
                return this.value_ - delta * constants_1.numbers.PAGE_FACTOR;
            default:
                return NaN;
        }
    };
    MDCSliderFoundation.prototype.handleFocus_ = function () {
        if (this.preventFocusState_) {
            return;
        }
        this.adapter_.addClass(constants_1.cssClasses.FOCUS);
    };
    MDCSliderFoundation.prototype.handleBlur_ = function () {
        this.preventFocusState_ = false;
        this.adapter_.removeClass(constants_1.cssClasses.FOCUS);
    };
    /**
     * Sets the value of the slider
     */
    MDCSliderFoundation.prototype.setValue_ = function (value, shouldFireInput, force) {
        if (force === void 0) {
            force = false;
        }
        if (value === this.value_ && !force) {
            return;
        }
        var _a = this,
            min = _a.min_,
            max = _a.max_;
        var valueSetToBoundary = value === min || value === max;
        if (this.step_ && !valueSetToBoundary) {
            value = this.quantize_(value);
        }
        if (value < min) {
            value = min;
        } else if (value > max) {
            value = max;
        }
        value = value || 0; // coerce -0 to 0
        this.value_ = value;
        this.adapter_.setAttribute(constants_1.strings.ARIA_VALUENOW, String(this.value_));
        this.updateUIForCurrentValue_();
        if (shouldFireInput) {
            this.adapter_.notifyInput();
            if (this.isDiscrete_) {
                this.adapter_.setMarkerValue(value);
            }
        }
    };
    /**
     * Calculates the quantized value
     */
    MDCSliderFoundation.prototype.quantize_ = function (value) {
        var numSteps = Math.round(value / this.step_);
        return numSteps * this.step_;
    };
    MDCSliderFoundation.prototype.updateUIForCurrentValue_ = function () {
        var _this = this;
        var _a = this,
            max = _a.max_,
            min = _a.min_,
            value = _a.value_;
        var pctComplete = (value - min) / (max - min);
        var translatePx = pctComplete * this.rect_.width;
        if (this.adapter_.isRTL()) {
            translatePx = this.rect_.width - translatePx;
        }
        // Accessing `window` without a `typeof` check will throw on Node environments.
        var hasWindow = typeof window !== 'undefined';
        var transformProp = hasWindow ? util_1.getCorrectPropertyName(window, 'transform') : 'transform';
        var transitionendEvtName = hasWindow ? util_1.getCorrectEventName(window, 'transitionend') : 'transitionend';
        if (this.inTransit_) {
            var onTransitionEnd_1 = function onTransitionEnd_1() {
                _this.setInTransit_(false);
                _this.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd_1);
            };
            this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd_1);
        }
        requestAnimationFrame(function () {
            // NOTE(traviskaufman): It would be nice to use calc() here,
            // but IE cannot handle calcs in transforms correctly.
            // See: https://goo.gl/NC2itk
            // Also note that the -50% offset is used to center the slider thumb.
            _this.adapter_.setThumbContainerStyleProperty(transformProp, "translateX(" + translatePx + "px) translateX(-50%)");
            _this.adapter_.setTrackStyleProperty(transformProp, "scaleX(" + pctComplete + ")");
        });
    };
    /**
     * Toggles the active state of the slider
     */
    MDCSliderFoundation.prototype.setActive_ = function (active) {
        this.active_ = active;
        this.toggleClass_(constants_1.cssClasses.ACTIVE, this.active_);
    };
    /**
     * Toggles the inTransit state of the slider
     */
    MDCSliderFoundation.prototype.setInTransit_ = function (inTransit) {
        this.inTransit_ = inTransit;
        this.toggleClass_(constants_1.cssClasses.IN_TRANSIT, this.inTransit_);
    };
    /**
     * Conditionally adds or removes a class based on shouldBePresent
     */
    MDCSliderFoundation.prototype.toggleClass_ = function (className, shouldBePresent) {
        if (shouldBePresent) {
            this.adapter_.addClass(className);
        } else {
            this.adapter_.removeClass(className);
        }
    };
    return MDCSliderFoundation;
}(foundation_1.MDCFoundation);
exports.MDCSliderFoundation = MDCSliderFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility
// with MDC Web v0.44.0 and earlier.
exports.default = MDCSliderFoundation;

/***/ }),

/***/ "./packages/mdc-slider/index.ts":
/*!**************************************!*\
  !*** ./packages/mdc-slider/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-slider/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-slider/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-slider/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-snackbar/component.ts":
/*!********************************************!*\
  !*** ./packages/mdc-snackbar/component.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-snackbar/constants.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-snackbar/foundation.ts");
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-snackbar/util.ts"));
var SURFACE_SELECTOR = constants_1.strings.SURFACE_SELECTOR,
    LABEL_SELECTOR = constants_1.strings.LABEL_SELECTOR,
    ACTION_SELECTOR = constants_1.strings.ACTION_SELECTOR,
    DISMISS_SELECTOR = constants_1.strings.DISMISS_SELECTOR,
    OPENING_EVENT = constants_1.strings.OPENING_EVENT,
    OPENED_EVENT = constants_1.strings.OPENED_EVENT,
    CLOSING_EVENT = constants_1.strings.CLOSING_EVENT,
    CLOSED_EVENT = constants_1.strings.CLOSED_EVENT;
var MDCSnackbar = /** @class */function (_super) {
    __extends(MDCSnackbar, _super);
    function MDCSnackbar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSnackbar.attachTo = function (root) {
        return new MDCSnackbar(root);
    };
    MDCSnackbar.prototype.initialize = function (announcerFactory) {
        if (announcerFactory === void 0) {
            announcerFactory = function announcerFactory() {
                return util.announce;
            };
        }
        this.announce_ = announcerFactory();
    };
    MDCSnackbar.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.surfaceEl_ = this.root_.querySelector(SURFACE_SELECTOR);
        this.labelEl_ = this.root_.querySelector(LABEL_SELECTOR);
        this.actionEl_ = this.root_.querySelector(ACTION_SELECTOR);
        this.handleKeyDown_ = function (evt) {
            return _this.foundation_.handleKeyDown(evt);
        };
        this.handleSurfaceClick_ = function (evt) {
            var target = evt.target;
            if (_this.isActionButton_(target)) {
                _this.foundation_.handleActionButtonClick(evt);
            } else if (_this.isActionIcon_(target)) {
                _this.foundation_.handleActionIconClick(evt);
            }
        };
        this.registerKeyDownHandler_(this.handleKeyDown_);
        this.registerSurfaceClickHandler_(this.handleSurfaceClick_);
    };
    MDCSnackbar.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.deregisterKeyDownHandler_(this.handleKeyDown_);
        this.deregisterSurfaceClickHandler_(this.handleSurfaceClick_);
    };
    MDCSnackbar.prototype.open = function () {
        this.foundation_.open();
    };
    /**
     * @param reason Why the snackbar was closed. Value will be passed to CLOSING_EVENT and CLOSED_EVENT via the
     *     `event.detail.reason` property. Standard values are REASON_ACTION and REASON_DISMISS, but custom
     *     client-specific values may also be used if desired.
     */
    MDCSnackbar.prototype.close = function (reason) {
        if (reason === void 0) {
            reason = '';
        }
        this.foundation_.close(reason);
    };
    MDCSnackbar.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            announce: function announce() {
                return _this.announce_(_this.labelEl_);
            },
            notifyClosed: function notifyClosed(reason) {
                return _this.emit(CLOSED_EVENT, reason ? { reason: reason } : {});
            },
            notifyClosing: function notifyClosing(reason) {
                return _this.emit(CLOSING_EVENT, reason ? { reason: reason } : {});
            },
            notifyOpened: function notifyOpened() {
                return _this.emit(OPENED_EVENT, {});
            },
            notifyOpening: function notifyOpening() {
                return _this.emit(OPENING_EVENT, {});
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            }
        };
        return new foundation_1.MDCSnackbarFoundation(adapter);
    };
    Object.defineProperty(MDCSnackbar.prototype, "timeoutMs", {
        get: function get() {
            return this.foundation_.getTimeoutMs();
        },
        set: function set(timeoutMs) {
            this.foundation_.setTimeoutMs(timeoutMs);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSnackbar.prototype, "closeOnEscape", {
        get: function get() {
            return this.foundation_.getCloseOnEscape();
        },
        set: function set(closeOnEscape) {
            this.foundation_.setCloseOnEscape(closeOnEscape);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSnackbar.prototype, "isOpen", {
        get: function get() {
            return this.foundation_.isOpen();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSnackbar.prototype, "labelText", {
        get: function get() {
            // This property only returns null if the node is a document, DOCTYPE, or notation.
            // On Element nodes, it always returns a string.
            return this.labelEl_.textContent;
        },
        set: function set(labelText) {
            this.labelEl_.textContent = labelText;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSnackbar.prototype, "actionButtonText", {
        get: function get() {
            return this.actionEl_.textContent;
        },
        set: function set(actionButtonText) {
            this.actionEl_.textContent = actionButtonText;
        },
        enumerable: true,
        configurable: true
    });
    MDCSnackbar.prototype.registerKeyDownHandler_ = function (handler) {
        this.listen('keydown', handler);
    };
    MDCSnackbar.prototype.deregisterKeyDownHandler_ = function (handler) {
        this.unlisten('keydown', handler);
    };
    MDCSnackbar.prototype.registerSurfaceClickHandler_ = function (handler) {
        this.surfaceEl_.addEventListener('click', handler);
    };
    MDCSnackbar.prototype.deregisterSurfaceClickHandler_ = function (handler) {
        this.surfaceEl_.removeEventListener('click', handler);
    };
    MDCSnackbar.prototype.isActionButton_ = function (target) {
        return Boolean(ponyfill_1.closest(target, ACTION_SELECTOR));
    };
    MDCSnackbar.prototype.isActionIcon_ = function (target) {
        return Boolean(ponyfill_1.closest(target, DISMISS_SELECTOR));
    };
    return MDCSnackbar;
}(component_1.MDCComponent);
exports.MDCSnackbar = MDCSnackbar;

/***/ }),

/***/ "./packages/mdc-snackbar/constants.ts":
/*!********************************************!*\
  !*** ./packages/mdc-snackbar/constants.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    CLOSING: 'mdc-snackbar--closing',
    OPEN: 'mdc-snackbar--open',
    OPENING: 'mdc-snackbar--opening'
};
exports.cssClasses = cssClasses;
var strings = {
    ACTION_SELECTOR: '.mdc-snackbar__action',
    ARIA_LIVE_LABEL_TEXT_ATTR: 'data-mdc-snackbar-label-text',
    CLOSED_EVENT: 'MDCSnackbar:closed',
    CLOSING_EVENT: 'MDCSnackbar:closing',
    DISMISS_SELECTOR: '.mdc-snackbar__dismiss',
    LABEL_SELECTOR: '.mdc-snackbar__label',
    OPENED_EVENT: 'MDCSnackbar:opened',
    OPENING_EVENT: 'MDCSnackbar:opening',
    REASON_ACTION: 'action',
    REASON_DISMISS: 'dismiss',
    SURFACE_SELECTOR: '.mdc-snackbar__surface'
};
exports.strings = strings;
var numbers = {
    DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5000,
    INDETERMINATE: -1,
    MAX_AUTO_DISMISS_TIMEOUT_MS: 10000,
    MIN_AUTO_DISMISS_TIMEOUT_MS: 4000,
    // These variables need to be kept in sync with the values in _variables.scss.
    SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,
    SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
    /**
     * Number of milliseconds to wait between temporarily clearing the label text
     * in the DOM and subsequently restoring it. This is necessary to force IE 11
     * to pick up the `aria-live` content change and announce it to the user.
     */
    ARIA_LIVE_DELAY_MS: 1000
};
exports.numbers = numbers;

/***/ }),

/***/ "./packages/mdc-snackbar/foundation.ts":
/*!*********************************************!*\
  !*** ./packages/mdc-snackbar/foundation.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-snackbar/constants.ts");
var OPENING = constants_1.cssClasses.OPENING,
    OPEN = constants_1.cssClasses.OPEN,
    CLOSING = constants_1.cssClasses.CLOSING;
var REASON_ACTION = constants_1.strings.REASON_ACTION,
    REASON_DISMISS = constants_1.strings.REASON_DISMISS;
var MDCSnackbarFoundation = /** @class */function (_super) {
    __extends(MDCSnackbarFoundation, _super);
    function MDCSnackbarFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCSnackbarFoundation.defaultAdapter), adapter)) || this;
        _this.isOpen_ = false;
        _this.animationFrame_ = 0;
        _this.animationTimer_ = 0;
        _this.autoDismissTimer_ = 0;
        _this.autoDismissTimeoutMs_ = constants_1.numbers.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;
        _this.closeOnEscape_ = true;
        return _this;
    }
    Object.defineProperty(MDCSnackbarFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSnackbarFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSnackbarFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSnackbarFoundation, "defaultAdapter", {
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                announce: function announce() {
                    return undefined;
                },
                notifyClosed: function notifyClosed() {
                    return undefined;
                },
                notifyClosing: function notifyClosing() {
                    return undefined;
                },
                notifyOpened: function notifyOpened() {
                    return undefined;
                },
                notifyOpening: function notifyOpening() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCSnackbarFoundation.prototype.destroy = function () {
        this.clearAutoDismissTimer_();
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = 0;
        this.adapter_.removeClass(OPENING);
        this.adapter_.removeClass(OPEN);
        this.adapter_.removeClass(CLOSING);
    };
    MDCSnackbarFoundation.prototype.open = function () {
        var _this = this;
        this.clearAutoDismissTimer_();
        this.isOpen_ = true;
        this.adapter_.notifyOpening();
        this.adapter_.removeClass(CLOSING);
        this.adapter_.addClass(OPENING);
        this.adapter_.announce();
        // Wait a frame once display is no longer "none", to establish basis for animation
        this.runNextAnimationFrame_(function () {
            _this.adapter_.addClass(OPEN);
            _this.animationTimer_ = setTimeout(function () {
                var timeoutMs = _this.getTimeoutMs();
                _this.handleAnimationTimerEnd_();
                _this.adapter_.notifyOpened();
                if (timeoutMs !== constants_1.numbers.INDETERMINATE) {
                    _this.autoDismissTimer_ = setTimeout(function () {
                        _this.close(REASON_DISMISS);
                    }, timeoutMs);
                }
            }, constants_1.numbers.SNACKBAR_ANIMATION_OPEN_TIME_MS);
        });
    };
    /**
     * @param reason Why the snackbar was closed. Value will be passed to CLOSING_EVENT and CLOSED_EVENT via the
     *     `event.detail.reason` property. Standard values are REASON_ACTION and REASON_DISMISS, but custom
     *     client-specific values may also be used if desired.
     */
    MDCSnackbarFoundation.prototype.close = function (reason) {
        var _this = this;
        if (reason === void 0) {
            reason = '';
        }
        if (!this.isOpen_) {
            // Avoid redundant close calls (and events), e.g. repeated interactions as the snackbar is animating closed
            return;
        }
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        this.clearAutoDismissTimer_();
        this.isOpen_ = false;
        this.adapter_.notifyClosing(reason);
        this.adapter_.addClass(constants_1.cssClasses.CLOSING);
        this.adapter_.removeClass(constants_1.cssClasses.OPEN);
        this.adapter_.removeClass(constants_1.cssClasses.OPENING);
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = setTimeout(function () {
            _this.handleAnimationTimerEnd_();
            _this.adapter_.notifyClosed(reason);
        }, constants_1.numbers.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
    };
    MDCSnackbarFoundation.prototype.isOpen = function () {
        return this.isOpen_;
    };
    MDCSnackbarFoundation.prototype.getTimeoutMs = function () {
        return this.autoDismissTimeoutMs_;
    };
    MDCSnackbarFoundation.prototype.setTimeoutMs = function (timeoutMs) {
        // Use shorter variable names to make the code more readable
        var minValue = constants_1.numbers.MIN_AUTO_DISMISS_TIMEOUT_MS;
        var maxValue = constants_1.numbers.MAX_AUTO_DISMISS_TIMEOUT_MS;
        var indeterminateValue = constants_1.numbers.INDETERMINATE;
        if (timeoutMs === constants_1.numbers.INDETERMINATE || timeoutMs <= maxValue && timeoutMs >= minValue) {
            this.autoDismissTimeoutMs_ = timeoutMs;
        } else {
            throw new Error("\n        timeoutMs must be an integer in the range " + minValue + "\u2013" + maxValue + "\n        (or " + indeterminateValue + " to disable), but got '" + timeoutMs + "'");
        }
    };
    MDCSnackbarFoundation.prototype.getCloseOnEscape = function () {
        return this.closeOnEscape_;
    };
    MDCSnackbarFoundation.prototype.setCloseOnEscape = function (closeOnEscape) {
        this.closeOnEscape_ = closeOnEscape;
    };
    MDCSnackbarFoundation.prototype.handleKeyDown = function (evt) {
        var isEscapeKey = evt.key === 'Escape' || evt.keyCode === 27;
        if (isEscapeKey && this.getCloseOnEscape()) {
            this.close(REASON_DISMISS);
        }
    };
    MDCSnackbarFoundation.prototype.handleActionButtonClick = function (_evt) {
        this.close(REASON_ACTION);
    };
    MDCSnackbarFoundation.prototype.handleActionIconClick = function (_evt) {
        this.close(REASON_DISMISS);
    };
    MDCSnackbarFoundation.prototype.clearAutoDismissTimer_ = function () {
        clearTimeout(this.autoDismissTimer_);
        this.autoDismissTimer_ = 0;
    };
    MDCSnackbarFoundation.prototype.handleAnimationTimerEnd_ = function () {
        this.animationTimer_ = 0;
        this.adapter_.removeClass(constants_1.cssClasses.OPENING);
        this.adapter_.removeClass(constants_1.cssClasses.CLOSING);
    };
    /**
     * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
     */
    MDCSnackbarFoundation.prototype.runNextAnimationFrame_ = function (callback) {
        var _this = this;
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = requestAnimationFrame(function () {
            _this.animationFrame_ = 0;
            clearTimeout(_this.animationTimer_);
            _this.animationTimer_ = setTimeout(callback, 0);
        });
    };
    return MDCSnackbarFoundation;
}(foundation_1.MDCFoundation);
exports.MDCSnackbarFoundation = MDCSnackbarFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCSnackbarFoundation;

/***/ }),

/***/ "./packages/mdc-snackbar/index.ts":
/*!****************************************!*\
  !*** ./packages/mdc-snackbar/index.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-snackbar/util.ts"));
exports.util = util;
__export(__webpack_require__(/*! ./component */ "./packages/mdc-snackbar/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-snackbar/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-snackbar/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-snackbar/util.ts":
/*!***************************************!*\
  !*** ./packages/mdc-snackbar/util.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-snackbar/constants.ts");
var ARIA_LIVE_DELAY_MS = constants_1.numbers.ARIA_LIVE_DELAY_MS;
var ARIA_LIVE_LABEL_TEXT_ATTR = constants_1.strings.ARIA_LIVE_LABEL_TEXT_ATTR;
function announce(ariaEl, labelEl) {
    if (labelEl === void 0) {
        labelEl = ariaEl;
    }
    var priority = ariaEl.getAttribute('aria-live');
    // Trim text to ignore `&nbsp;` (see below).
    // textContent is only null if the node is a document, DOCTYPE, or notation.
    var labelText = labelEl.textContent.trim();
    if (!labelText || !priority) {
        return;
    }
    // Temporarily disable `aria-live` to prevent JAWS+Firefox from announcing the message twice.
    ariaEl.setAttribute('aria-live', 'off');
    // Temporarily clear `textContent` to force a DOM mutation event that will be detected by screen readers.
    // `aria-live` elements are only announced when the element's `textContent` *changes*, so snackbars
    // sent to the browser in the initial HTML response won't be read unless we clear the element's `textContent` first.
    // Similarly, displaying the same snackbar message twice in a row doesn't trigger a DOM mutation event,
    // so screen readers won't announce the second message unless we first clear `textContent`.
    //
    // We have to clear the label text two different ways to make it work in all browsers and screen readers:
    //
    //   1. `textContent = ''` is required for IE11 + JAWS
    //   2. `innerHTML = '&nbsp;'` is required for Chrome + JAWS and NVDA
    //
    // All other browser/screen reader combinations support both methods.
    //
    // The wrapper `<span>` visually hides the space character so that it doesn't cause jank when added/removed.
    // N.B.: Setting `position: absolute`, `opacity: 0`, or `height: 0` prevents Chrome from detecting the DOM change.
    //
    // This technique has been tested in:
    //
    //   * JAWS 2019:
    //       - Chrome 70
    //       - Firefox 60 (ESR)
    //       - IE 11
    //   * NVDA 2018:
    //       - Chrome 70
    //       - Firefox 60 (ESR)
    //       - IE 11
    //   * ChromeVox 53
    labelEl.textContent = '';
    labelEl.innerHTML = '<span style="display: inline-block; width: 0; height: 1px;">&nbsp;</span>';
    // Prevent visual jank by temporarily displaying the label text in the ::before pseudo-element.
    // CSS generated content is normally announced by screen readers
    // (except in IE 11; see https://tink.uk/accessibility-support-for-css-generated-content/);
    // however, `aria-live` is turned off, so this DOM update will be ignored by screen readers.
    labelEl.setAttribute(ARIA_LIVE_LABEL_TEXT_ATTR, labelText);
    setTimeout(function () {
        // Allow screen readers to announce changes to the DOM again.
        ariaEl.setAttribute('aria-live', priority);
        // Remove the message from the ::before pseudo-element.
        labelEl.removeAttribute(ARIA_LIVE_LABEL_TEXT_ATTR);
        // Restore the original label text, which will be announced by screen readers.
        labelEl.textContent = labelText;
    }, ARIA_LIVE_DELAY_MS);
}
exports.announce = announce;

/***/ }),

/***/ "./packages/mdc-switch/component.ts":
/*!******************************************!*\
  !*** ./packages/mdc-switch/component.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = this && this.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
    }return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var events_1 = __webpack_require__(/*! @material/dom/events */ "./packages/mdc-dom/events.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var component_2 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! @material/ripple/foundation */ "./packages/mdc-ripple/foundation.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-switch/foundation.ts");
var MDCSwitch = /** @class */function (_super) {
    __extends(MDCSwitch, _super);
    function MDCSwitch() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ripple_ = _this.createRipple_();
        return _this;
    }
    MDCSwitch.attachTo = function (root) {
        return new MDCSwitch(root);
    };
    MDCSwitch.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.ripple_.destroy();
        this.nativeControl_.removeEventListener('change', this.changeHandler_);
    };
    MDCSwitch.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.changeHandler_ = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = _this.foundation_).handleChange.apply(_a, __spread(args));
        };
        this.nativeControl_.addEventListener('change', this.changeHandler_);
        // Sometimes the checked state of the input element is saved in the history.
        // The switch styling should match the checked state of the input element.
        // Do an initial sync between the native control and the foundation.
        this.checked = this.checked;
    };
    MDCSwitch.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            setNativeControlChecked: function setNativeControlChecked(checked) {
                return _this.nativeControl_.checked = checked;
            },
            setNativeControlDisabled: function setNativeControlDisabled(disabled) {
                return _this.nativeControl_.disabled = disabled;
            },
            setNativeControlAttr: function setNativeControlAttr(attr, value) {
                return _this.nativeControl_.setAttribute(attr, value);
            }
        };
        return new foundation_2.MDCSwitchFoundation(adapter);
    };
    Object.defineProperty(MDCSwitch.prototype, "ripple", {
        get: function get() {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSwitch.prototype, "checked", {
        get: function get() {
            return this.nativeControl_.checked;
        },
        set: function set(checked) {
            this.foundation_.setChecked(checked);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSwitch.prototype, "disabled", {
        get: function get() {
            return this.nativeControl_.disabled;
        },
        set: function set(disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    MDCSwitch.prototype.createRipple_ = function () {
        var _this = this;
        var RIPPLE_SURFACE_SELECTOR = foundation_2.MDCSwitchFoundation.strings.RIPPLE_SURFACE_SELECTOR;
        var rippleSurface = this.root_.querySelector(RIPPLE_SURFACE_SELECTOR);
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = __assign(__assign({}, component_2.MDCRipple.createAdapter(this)), { addClass: function addClass(className) {
                return rippleSurface.classList.add(className);
            }, computeBoundingRect: function computeBoundingRect() {
                return rippleSurface.getBoundingClientRect();
            }, deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                _this.nativeControl_.removeEventListener(evtType, handler, events_1.applyPassive());
            }, isSurfaceActive: function isSurfaceActive() {
                return ponyfill_1.matches(_this.nativeControl_, ':active');
            }, isUnbounded: function isUnbounded() {
                return true;
            }, registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                _this.nativeControl_.addEventListener(evtType, handler, events_1.applyPassive());
            }, removeClass: function removeClass(className) {
                rippleSurface.classList.remove(className);
            }, updateCssVariable: function updateCssVariable(varName, value) {
                rippleSurface.style.setProperty(varName, value);
            } });
        return new component_2.MDCRipple(this.root_, new foundation_1.MDCRippleFoundation(adapter));
    };
    Object.defineProperty(MDCSwitch.prototype, "nativeControl_", {
        get: function get() {
            var NATIVE_CONTROL_SELECTOR = foundation_2.MDCSwitchFoundation.strings.NATIVE_CONTROL_SELECTOR;
            return this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
        },
        enumerable: true,
        configurable: true
    });
    return MDCSwitch;
}(component_1.MDCComponent);
exports.MDCSwitch = MDCSwitch;

/***/ }),

/***/ "./packages/mdc-switch/constants.ts":
/*!******************************************!*\
  !*** ./packages/mdc-switch/constants.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/** CSS classes used by the switch. */
var cssClasses = {
    /** Class used for a switch that is in the "checked" (on) position. */
    CHECKED: 'mdc-switch--checked',
    /** Class used for a switch that is disabled. */
    DISABLED: 'mdc-switch--disabled'
};
exports.cssClasses = cssClasses;
/** String constants used by the switch. */
var strings = {
    /** Aria attribute for checked or unchecked state of switch */
    ARIA_CHECKED_ATTR: 'aria-checked',
    /** A CSS selector used to locate the native HTML control for the switch.  */
    NATIVE_CONTROL_SELECTOR: '.mdc-switch__native-control',
    /** A CSS selector used to locate the ripple surface element for the switch. */
    RIPPLE_SURFACE_SELECTOR: '.mdc-switch__thumb-underlay'
};
exports.strings = strings;

/***/ }),

/***/ "./packages/mdc-switch/foundation.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-switch/foundation.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-switch/constants.ts");
var MDCSwitchFoundation = /** @class */function (_super) {
    __extends(MDCSwitchFoundation, _super);
    function MDCSwitchFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCSwitchFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCSwitchFoundation, "strings", {
        /** The string constants used by the switch. */
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSwitchFoundation, "cssClasses", {
        /** The CSS classes used by the switch. */
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSwitchFoundation, "defaultAdapter", {
        /** The default Adapter for the switch. */
        get: function get() {
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                setNativeControlChecked: function setNativeControlChecked() {
                    return undefined;
                },
                setNativeControlDisabled: function setNativeControlDisabled() {
                    return undefined;
                },
                setNativeControlAttr: function setNativeControlAttr() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    /** Sets the checked state of the switch. */
    MDCSwitchFoundation.prototype.setChecked = function (checked) {
        this.adapter_.setNativeControlChecked(checked);
        this.updateAriaChecked_(checked);
        this.updateCheckedStyling_(checked);
    };
    /** Sets the disabled state of the switch. */
    MDCSwitchFoundation.prototype.setDisabled = function (disabled) {
        this.adapter_.setNativeControlDisabled(disabled);
        if (disabled) {
            this.adapter_.addClass(constants_1.cssClasses.DISABLED);
        } else {
            this.adapter_.removeClass(constants_1.cssClasses.DISABLED);
        }
    };
    /** Handles the change event for the switch native control. */
    MDCSwitchFoundation.prototype.handleChange = function (evt) {
        var nativeControl = evt.target;
        this.updateAriaChecked_(nativeControl.checked);
        this.updateCheckedStyling_(nativeControl.checked);
    };
    /** Updates the styling of the switch based on its checked state. */
    MDCSwitchFoundation.prototype.updateCheckedStyling_ = function (checked) {
        if (checked) {
            this.adapter_.addClass(constants_1.cssClasses.CHECKED);
        } else {
            this.adapter_.removeClass(constants_1.cssClasses.CHECKED);
        }
    };
    MDCSwitchFoundation.prototype.updateAriaChecked_ = function (checked) {
        this.adapter_.setNativeControlAttr(constants_1.strings.ARIA_CHECKED_ATTR, "" + !!checked);
    };
    return MDCSwitchFoundation;
}(foundation_1.MDCFoundation);
exports.MDCSwitchFoundation = MDCSwitchFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCSwitchFoundation;

/***/ }),

/***/ "./packages/mdc-switch/index.ts":
/*!**************************************!*\
  !*** ./packages/mdc-switch/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-switch/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-switch/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-switch/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-tab-bar/component.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-tab-bar/component.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var component_2 = __webpack_require__(/*! @material/tab-scroller/component */ "./packages/mdc-tab-scroller/component.ts");
var component_3 = __webpack_require__(/*! @material/tab/component */ "./packages/mdc-tab/component.ts");
var foundation_1 = __webpack_require__(/*! @material/tab/foundation */ "./packages/mdc-tab/foundation.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-tab-bar/foundation.ts");
var strings = foundation_2.MDCTabBarFoundation.strings;
var tabIdCounter = 0;
var MDCTabBar = /** @class */function (_super) {
    __extends(MDCTabBar, _super);
    function MDCTabBar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabBar.attachTo = function (root) {
        return new MDCTabBar(root);
    };
    Object.defineProperty(MDCTabBar.prototype, "focusOnActivate", {
        set: function set(focusOnActivate) {
            this.tabList_.forEach(function (tab) {
                return tab.focusOnActivate = focusOnActivate;
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabBar.prototype, "useAutomaticActivation", {
        set: function set(useAutomaticActivation) {
            this.foundation_.setUseAutomaticActivation(useAutomaticActivation);
        },
        enumerable: true,
        configurable: true
    });
    MDCTabBar.prototype.initialize = function (tabFactory, tabScrollerFactory) {
        if (tabFactory === void 0) {
            tabFactory = function tabFactory(el) {
                return new component_3.MDCTab(el);
            };
        }
        if (tabScrollerFactory === void 0) {
            tabScrollerFactory = function tabScrollerFactory(el) {
                return new component_2.MDCTabScroller(el);
            };
        }
        this.tabList_ = this.instantiateTabs_(tabFactory);
        this.tabScroller_ = this.instantiateTabScroller_(tabScrollerFactory);
    };
    MDCTabBar.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleTabInteraction_ = function (evt) {
            return _this.foundation_.handleTabInteraction(evt);
        };
        this.handleKeyDown_ = function (evt) {
            return _this.foundation_.handleKeyDown(evt);
        };
        this.listen(foundation_1.MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
        this.listen('keydown', this.handleKeyDown_);
        for (var i = 0; i < this.tabList_.length; i++) {
            if (this.tabList_[i].active) {
                this.scrollIntoView(i);
                break;
            }
        }
    };
    MDCTabBar.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.unlisten(foundation_1.MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
        this.unlisten('keydown', this.handleKeyDown_);
        this.tabList_.forEach(function (tab) {
            return tab.destroy();
        });
        if (this.tabScroller_) {
            this.tabScroller_.destroy();
        }
    };
    MDCTabBar.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            scrollTo: function scrollTo(scrollX) {
                return _this.tabScroller_.scrollTo(scrollX);
            },
            incrementScroll: function incrementScroll(scrollXIncrement) {
                return _this.tabScroller_.incrementScroll(scrollXIncrement);
            },
            getScrollPosition: function getScrollPosition() {
                return _this.tabScroller_.getScrollPosition();
            },
            getScrollContentWidth: function getScrollContentWidth() {
                return _this.tabScroller_.getScrollContentWidth();
            },
            getOffsetWidth: function getOffsetWidth() {
                return _this.root_.offsetWidth;
            },
            isRTL: function isRTL() {
                return window.getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
            },
            setActiveTab: function setActiveTab(index) {
                return _this.foundation_.activateTab(index);
            },
            activateTabAtIndex: function activateTabAtIndex(index, clientRect) {
                return _this.tabList_[index].activate(clientRect);
            },
            deactivateTabAtIndex: function deactivateTabAtIndex(index) {
                return _this.tabList_[index].deactivate();
            },
            focusTabAtIndex: function focusTabAtIndex(index) {
                return _this.tabList_[index].focus();
            },
            getTabIndicatorClientRectAtIndex: function getTabIndicatorClientRectAtIndex(index) {
                return _this.tabList_[index].computeIndicatorClientRect();
            },
            getTabDimensionsAtIndex: function getTabDimensionsAtIndex(index) {
                return _this.tabList_[index].computeDimensions();
            },
            getPreviousActiveTabIndex: function getPreviousActiveTabIndex() {
                for (var i = 0; i < _this.tabList_.length; i++) {
                    if (_this.tabList_[i].active) {
                        return i;
                    }
                }
                return -1;
            },
            getFocusedTabIndex: function getFocusedTabIndex() {
                var tabElements = _this.getTabElements_();
                var activeElement = document.activeElement;
                return tabElements.indexOf(activeElement);
            },
            getIndexOfTabById: function getIndexOfTabById(id) {
                for (var i = 0; i < _this.tabList_.length; i++) {
                    if (_this.tabList_[i].id === id) {
                        return i;
                    }
                }
                return -1;
            },
            getTabListLength: function getTabListLength() {
                return _this.tabList_.length;
            },
            notifyTabActivated: function notifyTabActivated(index) {
                return _this.emit(strings.TAB_ACTIVATED_EVENT, { index: index }, true);
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_2.MDCTabBarFoundation(adapter);
    };
    /**
     * Activates the tab at the given index
     * @param index The index of the tab
     */
    MDCTabBar.prototype.activateTab = function (index) {
        this.foundation_.activateTab(index);
    };
    /**
     * Scrolls the tab at the given index into view
     * @param index THe index of the tab
     */
    MDCTabBar.prototype.scrollIntoView = function (index) {
        this.foundation_.scrollIntoView(index);
    };
    /**
     * Returns all the tab elements in a nice clean array
     */
    MDCTabBar.prototype.getTabElements_ = function () {
        return [].slice.call(this.root_.querySelectorAll(strings.TAB_SELECTOR));
    };
    /**
     * Instantiates tab components on all child tab elements
     */
    MDCTabBar.prototype.instantiateTabs_ = function (tabFactory) {
        return this.getTabElements_().map(function (el) {
            el.id = el.id || "mdc-tab-" + ++tabIdCounter;
            return tabFactory(el);
        });
    };
    /**
     * Instantiates tab scroller component on the child tab scroller element
     */
    MDCTabBar.prototype.instantiateTabScroller_ = function (tabScrollerFactory) {
        var tabScrollerElement = this.root_.querySelector(strings.TAB_SCROLLER_SELECTOR);
        if (tabScrollerElement) {
            return tabScrollerFactory(tabScrollerElement);
        }
        return null;
    };
    return MDCTabBar;
}(component_1.MDCComponent);
exports.MDCTabBar = MDCTabBar;

/***/ }),

/***/ "./packages/mdc-tab-bar/constants.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-tab-bar/constants.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var strings = {
    ARROW_LEFT_KEY: 'ArrowLeft',
    ARROW_RIGHT_KEY: 'ArrowRight',
    END_KEY: 'End',
    ENTER_KEY: 'Enter',
    HOME_KEY: 'Home',
    SPACE_KEY: 'Space',
    TAB_ACTIVATED_EVENT: 'MDCTabBar:activated',
    TAB_SCROLLER_SELECTOR: '.mdc-tab-scroller',
    TAB_SELECTOR: '.mdc-tab'
};
exports.strings = strings;
var numbers = {
    ARROW_LEFT_KEYCODE: 37,
    ARROW_RIGHT_KEYCODE: 39,
    END_KEYCODE: 35,
    ENTER_KEYCODE: 13,
    EXTRA_SCROLL_AMOUNT: 20,
    HOME_KEYCODE: 36,
    SPACE_KEYCODE: 32
};
exports.numbers = numbers;

/***/ }),

/***/ "./packages/mdc-tab-bar/foundation.ts":
/*!********************************************!*\
  !*** ./packages/mdc-tab-bar/foundation.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-tab-bar/constants.ts");
var ACCEPTABLE_KEYS = new Set();
// IE11 has no support for new Set with iterable so we need to initialize this by hand
ACCEPTABLE_KEYS.add(constants_1.strings.ARROW_LEFT_KEY);
ACCEPTABLE_KEYS.add(constants_1.strings.ARROW_RIGHT_KEY);
ACCEPTABLE_KEYS.add(constants_1.strings.END_KEY);
ACCEPTABLE_KEYS.add(constants_1.strings.HOME_KEY);
ACCEPTABLE_KEYS.add(constants_1.strings.ENTER_KEY);
ACCEPTABLE_KEYS.add(constants_1.strings.SPACE_KEY);
var KEYCODE_MAP = new Map();
// IE11 has no support for new Map with iterable so we need to initialize this by hand
KEYCODE_MAP.set(constants_1.numbers.ARROW_LEFT_KEYCODE, constants_1.strings.ARROW_LEFT_KEY);
KEYCODE_MAP.set(constants_1.numbers.ARROW_RIGHT_KEYCODE, constants_1.strings.ARROW_RIGHT_KEY);
KEYCODE_MAP.set(constants_1.numbers.END_KEYCODE, constants_1.strings.END_KEY);
KEYCODE_MAP.set(constants_1.numbers.HOME_KEYCODE, constants_1.strings.HOME_KEY);
KEYCODE_MAP.set(constants_1.numbers.ENTER_KEYCODE, constants_1.strings.ENTER_KEY);
KEYCODE_MAP.set(constants_1.numbers.SPACE_KEYCODE, constants_1.strings.SPACE_KEY);
var MDCTabBarFoundation = /** @class */function (_super) {
    __extends(MDCTabBarFoundation, _super);
    function MDCTabBarFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCTabBarFoundation.defaultAdapter), adapter)) || this;
        _this.useAutomaticActivation_ = false;
        return _this;
    }
    Object.defineProperty(MDCTabBarFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabBarFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabBarFoundation, "defaultAdapter", {
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                scrollTo: function scrollTo() {
                    return undefined;
                },
                incrementScroll: function incrementScroll() {
                    return undefined;
                },
                getScrollPosition: function getScrollPosition() {
                    return 0;
                },
                getScrollContentWidth: function getScrollContentWidth() {
                    return 0;
                },
                getOffsetWidth: function getOffsetWidth() {
                    return 0;
                },
                isRTL: function isRTL() {
                    return false;
                },
                setActiveTab: function setActiveTab() {
                    return undefined;
                },
                activateTabAtIndex: function activateTabAtIndex() {
                    return undefined;
                },
                deactivateTabAtIndex: function deactivateTabAtIndex() {
                    return undefined;
                },
                focusTabAtIndex: function focusTabAtIndex() {
                    return undefined;
                },
                getTabIndicatorClientRectAtIndex: function getTabIndicatorClientRectAtIndex() {
                    return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
                },
                getTabDimensionsAtIndex: function getTabDimensionsAtIndex() {
                    return { rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 };
                },
                getPreviousActiveTabIndex: function getPreviousActiveTabIndex() {
                    return -1;
                },
                getFocusedTabIndex: function getFocusedTabIndex() {
                    return -1;
                },
                getIndexOfTabById: function getIndexOfTabById() {
                    return -1;
                },
                getTabListLength: function getTabListLength() {
                    return 0;
                },
                notifyTabActivated: function notifyTabActivated() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Switches between automatic and manual activation modes.
     * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.
     */
    MDCTabBarFoundation.prototype.setUseAutomaticActivation = function (useAutomaticActivation) {
        this.useAutomaticActivation_ = useAutomaticActivation;
    };
    MDCTabBarFoundation.prototype.activateTab = function (index) {
        var previousActiveIndex = this.adapter_.getPreviousActiveTabIndex();
        if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
            return;
        }
        var previousClientRect;
        if (previousActiveIndex !== -1) {
            this.adapter_.deactivateTabAtIndex(previousActiveIndex);
            previousClientRect = this.adapter_.getTabIndicatorClientRectAtIndex(previousActiveIndex);
        }
        this.adapter_.activateTabAtIndex(index, previousClientRect);
        this.scrollIntoView(index);
        this.adapter_.notifyTabActivated(index);
    };
    MDCTabBarFoundation.prototype.handleKeyDown = function (evt) {
        // Get the key from the event
        var key = this.getKeyFromEvent_(evt);
        // Early exit if the event key isn't one of the keyboard navigation keys
        if (key === undefined) {
            return;
        }
        // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple
        if (!this.isActivationKey_(key)) {
            evt.preventDefault();
        }
        if (this.useAutomaticActivation_) {
            if (this.isActivationKey_(key)) {
                return;
            }
            var index = this.determineTargetFromKey_(this.adapter_.getPreviousActiveTabIndex(), key);
            this.adapter_.setActiveTab(index);
            this.scrollIntoView(index);
        } else {
            var focusedTabIndex = this.adapter_.getFocusedTabIndex();
            if (this.isActivationKey_(key)) {
                this.adapter_.setActiveTab(focusedTabIndex);
            } else {
                var index = this.determineTargetFromKey_(focusedTabIndex, key);
                this.adapter_.focusTabAtIndex(index);
                this.scrollIntoView(index);
            }
        }
    };
    /**
     * Handles the MDCTab:interacted event
     */
    MDCTabBarFoundation.prototype.handleTabInteraction = function (evt) {
        this.adapter_.setActiveTab(this.adapter_.getIndexOfTabById(evt.detail.tabId));
    };
    /**
     * Scrolls the tab at the given index into view
     * @param index The tab index to make visible
     */
    MDCTabBarFoundation.prototype.scrollIntoView = function (index) {
        // Early exit if the index is out of range
        if (!this.indexIsInRange_(index)) {
            return;
        }
        // Always scroll to 0 if scrolling to the 0th index
        if (index === 0) {
            return this.adapter_.scrollTo(0);
        }
        // Always scroll to the max value if scrolling to the Nth index
        // MDCTabScroller.scrollTo() will never scroll past the max possible value
        if (index === this.adapter_.getTabListLength() - 1) {
            return this.adapter_.scrollTo(this.adapter_.getScrollContentWidth());
        }
        if (this.isRTL_()) {
            return this.scrollIntoViewRTL_(index);
        }
        this.scrollIntoView_(index);
    };
    /**
     * Private method for determining the index of the destination tab based on what key was pressed
     * @param origin The original index from which to determine the destination
     * @param key The name of the key
     */
    MDCTabBarFoundation.prototype.determineTargetFromKey_ = function (origin, key) {
        var isRTL = this.isRTL_();
        var maxIndex = this.adapter_.getTabListLength() - 1;
        var shouldGoToEnd = key === constants_1.strings.END_KEY;
        var shouldDecrement = key === constants_1.strings.ARROW_LEFT_KEY && !isRTL || key === constants_1.strings.ARROW_RIGHT_KEY && isRTL;
        var shouldIncrement = key === constants_1.strings.ARROW_RIGHT_KEY && !isRTL || key === constants_1.strings.ARROW_LEFT_KEY && isRTL;
        var index = origin;
        if (shouldGoToEnd) {
            index = maxIndex;
        } else if (shouldDecrement) {
            index -= 1;
        } else if (shouldIncrement) {
            index += 1;
        } else {
            index = 0;
        }
        if (index < 0) {
            index = maxIndex;
        } else if (index > maxIndex) {
            index = 0;
        }
        return index;
    };
    /**
     * Calculates the scroll increment that will make the tab at the given index visible
     * @param index The index of the tab
     * @param nextIndex The index of the next tab
     * @param scrollPosition The current scroll position
     * @param barWidth The width of the Tab Bar
     */
    MDCTabBarFoundation.prototype.calculateScrollIncrement_ = function (index, nextIndex, scrollPosition, barWidth) {
        var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
        var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
        var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
        var leftIncrement = relativeContentRight - constants_1.numbers.EXTRA_SCROLL_AMOUNT;
        var rightIncrement = relativeContentLeft + constants_1.numbers.EXTRA_SCROLL_AMOUNT;
        if (nextIndex < index) {
            return Math.min(leftIncrement, 0);
        }
        return Math.max(rightIncrement, 0);
    };
    /**
     * Calculates the scroll increment that will make the tab at the given index visible in RTL
     * @param index The index of the tab
     * @param nextIndex The index of the next tab
     * @param scrollPosition The current scroll position
     * @param barWidth The width of the Tab Bar
     * @param scrollContentWidth The width of the scroll content
     */
    MDCTabBarFoundation.prototype.calculateScrollIncrementRTL_ = function (index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
        var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
        var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
        var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
        var leftIncrement = relativeContentRight + constants_1.numbers.EXTRA_SCROLL_AMOUNT;
        var rightIncrement = relativeContentLeft - constants_1.numbers.EXTRA_SCROLL_AMOUNT;
        if (nextIndex > index) {
            return Math.max(leftIncrement, 0);
        }
        return Math.min(rightIncrement, 0);
    };
    /**
     * Determines the index of the adjacent tab closest to either edge of the Tab Bar
     * @param index The index of the tab
     * @param tabDimensions The dimensions of the tab
     * @param scrollPosition The current scroll position
     * @param barWidth The width of the tab bar
     */
    MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdge_ = function (index, tabDimensions, scrollPosition, barWidth) {
        /**
         * Tabs are laid out in the Tab Scroller like this:
         *
         *    Scroll Position
         *    +---+
         *    |   |   Bar Width
         *    |   +-----------------------------------+
         *    |   |                                   |
         *    |   V                                   V
         *    |   +-----------------------------------+
         *    V   |             Tab Scroller          |
         *    +------------+--------------+-------------------+
         *    |    Tab     |      Tab     |        Tab        |
         *    +------------+--------------+-------------------+
         *        |                                   |
         *        +-----------------------------------+
         *
         * To determine the next adjacent index, we look at the Tab root left and
         * Tab root right, both relative to the scroll position. If the Tab root
         * left is less than 0, then we know it's out of view to the left. If the
         * Tab root right minus the bar width is greater than 0, we know the Tab is
         * out of view to the right. From there, we either increment or decrement
         * the index.
         */
        var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
        var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
        var relativeRootDelta = relativeRootLeft + relativeRootRight;
        var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
        var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;
        if (leftEdgeIsCloser) {
            return index - 1;
        }
        if (rightEdgeIsCloser) {
            return index + 1;
        }
        return -1;
    };
    /**
     * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL
     * @param index The index of the tab
     * @param tabDimensions The dimensions of the tab
     * @param scrollPosition The current scroll position
     * @param barWidth The width of the tab bar
     * @param scrollContentWidth The width of the scroller content
     */
    MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdgeRTL_ = function (index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
        var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
        var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
        var rootDelta = rootLeft + rootRight;
        var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
        var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;
        if (leftEdgeIsCloser) {
            return index + 1;
        }
        if (rightEdgeIsCloser) {
            return index - 1;
        }
        return -1;
    };
    /**
     * Returns the key associated with a keydown event
     * @param evt The keydown event
     */
    MDCTabBarFoundation.prototype.getKeyFromEvent_ = function (evt) {
        if (ACCEPTABLE_KEYS.has(evt.key)) {
            return evt.key;
        }
        return KEYCODE_MAP.get(evt.keyCode);
    };
    MDCTabBarFoundation.prototype.isActivationKey_ = function (key) {
        return key === constants_1.strings.SPACE_KEY || key === constants_1.strings.ENTER_KEY;
    };
    /**
     * Returns whether a given index is inclusively between the ends
     * @param index The index to test
     */
    MDCTabBarFoundation.prototype.indexIsInRange_ = function (index) {
        return index >= 0 && index < this.adapter_.getTabListLength();
    };
    /**
     * Returns the view's RTL property
     */
    MDCTabBarFoundation.prototype.isRTL_ = function () {
        return this.adapter_.isRTL();
    };
    /**
     * Scrolls the tab at the given index into view for left-to-right user agents.
     * @param index The index of the tab to scroll into view
     */
    MDCTabBarFoundation.prototype.scrollIntoView_ = function (index) {
        var scrollPosition = this.adapter_.getScrollPosition();
        var barWidth = this.adapter_.getOffsetWidth();
        var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
        var nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);
        if (!this.indexIsInRange_(nextIndex)) {
            return;
        }
        var scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
        this.adapter_.incrementScroll(scrollIncrement);
    };
    /**
     * Scrolls the tab at the given index into view in RTL
     * @param index The tab index to make visible
     */
    MDCTabBarFoundation.prototype.scrollIntoViewRTL_ = function (index) {
        var scrollPosition = this.adapter_.getScrollPosition();
        var barWidth = this.adapter_.getOffsetWidth();
        var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
        var scrollWidth = this.adapter_.getScrollContentWidth();
        var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);
        if (!this.indexIsInRange_(nextIndex)) {
            return;
        }
        var scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
        this.adapter_.incrementScroll(scrollIncrement);
    };
    return MDCTabBarFoundation;
}(foundation_1.MDCFoundation);
exports.MDCTabBarFoundation = MDCTabBarFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTabBarFoundation;

/***/ }),

/***/ "./packages/mdc-tab-bar/index.ts":
/*!***************************************!*\
  !*** ./packages/mdc-tab-bar/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-tab-bar/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-tab-bar/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-tab-bar/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-tab-indicator/component.ts":
/*!*************************************************!*\
  !*** ./packages/mdc-tab-indicator/component.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var fading_foundation_1 = __webpack_require__(/*! ./fading-foundation */ "./packages/mdc-tab-indicator/fading-foundation.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-tab-indicator/foundation.ts");
var sliding_foundation_1 = __webpack_require__(/*! ./sliding-foundation */ "./packages/mdc-tab-indicator/sliding-foundation.ts");
var MDCTabIndicator = /** @class */function (_super) {
    __extends(MDCTabIndicator, _super);
    function MDCTabIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabIndicator.attachTo = function (root) {
        return new MDCTabIndicator(root);
    };
    MDCTabIndicator.prototype.initialize = function () {
        this.content_ = this.root_.querySelector(foundation_1.MDCTabIndicatorFoundation.strings.CONTENT_SELECTOR);
    };
    MDCTabIndicator.prototype.computeContentClientRect = function () {
        return this.foundation_.computeContentClientRect();
    };
    MDCTabIndicator.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            computeContentClientRect: function computeContentClientRect() {
                return _this.content_.getBoundingClientRect();
            },
            setContentStyleProperty: function setContentStyleProperty(prop, value) {
                return _this.content_.style.setProperty(prop, value);
            }
        };
        // tslint:enable:object-literal-sort-keys
        if (this.root_.classList.contains(foundation_1.MDCTabIndicatorFoundation.cssClasses.FADE)) {
            return new fading_foundation_1.MDCFadingTabIndicatorFoundation(adapter);
        }
        // Default to the sliding indicator
        return new sliding_foundation_1.MDCSlidingTabIndicatorFoundation(adapter);
    };
    MDCTabIndicator.prototype.activate = function (previousIndicatorClientRect) {
        this.foundation_.activate(previousIndicatorClientRect);
    };
    MDCTabIndicator.prototype.deactivate = function () {
        this.foundation_.deactivate();
    };
    return MDCTabIndicator;
}(component_1.MDCComponent);
exports.MDCTabIndicator = MDCTabIndicator;

/***/ }),

/***/ "./packages/mdc-tab-indicator/constants.ts":
/*!*************************************************!*\
  !*** ./packages/mdc-tab-indicator/constants.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    ACTIVE: 'mdc-tab-indicator--active',
    FADE: 'mdc-tab-indicator--fade',
    NO_TRANSITION: 'mdc-tab-indicator--no-transition'
};
exports.cssClasses = cssClasses;
var strings = {
    CONTENT_SELECTOR: '.mdc-tab-indicator__content'
};
exports.strings = strings;

/***/ }),

/***/ "./packages/mdc-tab-indicator/fading-foundation.ts":
/*!*********************************************************!*\
  !*** ./packages/mdc-tab-indicator/fading-foundation.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-tab-indicator/foundation.ts");
/* istanbul ignore next: subclass is not a branch statement */
var MDCFadingTabIndicatorFoundation = /** @class */function (_super) {
    __extends(MDCFadingTabIndicatorFoundation, _super);
    function MDCFadingTabIndicatorFoundation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCFadingTabIndicatorFoundation.prototype.activate = function () {
        this.adapter_.addClass(foundation_1.MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    };
    MDCFadingTabIndicatorFoundation.prototype.deactivate = function () {
        this.adapter_.removeClass(foundation_1.MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    };
    return MDCFadingTabIndicatorFoundation;
}(foundation_1.MDCTabIndicatorFoundation);
exports.MDCFadingTabIndicatorFoundation = MDCFadingTabIndicatorFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCFadingTabIndicatorFoundation;

/***/ }),

/***/ "./packages/mdc-tab-indicator/foundation.ts":
/*!**************************************************!*\
  !*** ./packages/mdc-tab-indicator/foundation.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-tab-indicator/constants.ts");
var MDCTabIndicatorFoundation = /** @class */function (_super) {
    __extends(MDCTabIndicatorFoundation, _super);
    function MDCTabIndicatorFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCTabIndicatorFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCTabIndicatorFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabIndicatorFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabIndicatorFoundation, "defaultAdapter", {
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                computeContentClientRect: function computeContentClientRect() {
                    return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
                },
                setContentStyleProperty: function setContentStyleProperty() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTabIndicatorFoundation.prototype.computeContentClientRect = function () {
        return this.adapter_.computeContentClientRect();
    };
    return MDCTabIndicatorFoundation;
}(foundation_1.MDCFoundation);
exports.MDCTabIndicatorFoundation = MDCTabIndicatorFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTabIndicatorFoundation;

/***/ }),

/***/ "./packages/mdc-tab-indicator/index.ts":
/*!*********************************************!*\
  !*** ./packages/mdc-tab-indicator/index.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-tab-indicator/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-tab-indicator/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-tab-indicator/foundation.ts"));
__export(__webpack_require__(/*! ./fading-foundation */ "./packages/mdc-tab-indicator/fading-foundation.ts"));
__export(__webpack_require__(/*! ./sliding-foundation */ "./packages/mdc-tab-indicator/sliding-foundation.ts"));

/***/ }),

/***/ "./packages/mdc-tab-indicator/sliding-foundation.ts":
/*!**********************************************************!*\
  !*** ./packages/mdc-tab-indicator/sliding-foundation.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-tab-indicator/foundation.ts");
/* istanbul ignore next: subclass is not a branch statement */
var MDCSlidingTabIndicatorFoundation = /** @class */function (_super) {
    __extends(MDCSlidingTabIndicatorFoundation, _super);
    function MDCSlidingTabIndicatorFoundation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSlidingTabIndicatorFoundation.prototype.activate = function (previousIndicatorClientRect) {
        // Early exit if no indicator is present to handle cases where an indicator
        // may be activated without a prior indicator state
        if (!previousIndicatorClientRect) {
            this.adapter_.addClass(foundation_1.MDCTabIndicatorFoundation.cssClasses.ACTIVE);
            return;
        }
        // This animation uses the FLIP approach. You can read more about it at the link below:
        // https://aerotwist.com/blog/flip-your-animations/
        // Calculate the dimensions based on the dimensions of the previous indicator
        var currentClientRect = this.computeContentClientRect();
        var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
        var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
        this.adapter_.addClass(foundation_1.MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
        this.adapter_.setContentStyleProperty('transform', "translateX(" + xPosition + "px) scaleX(" + widthDelta + ")");
        // Force repaint before updating classes and transform to ensure the transform properly takes effect
        this.computeContentClientRect();
        this.adapter_.removeClass(foundation_1.MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
        this.adapter_.addClass(foundation_1.MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        this.adapter_.setContentStyleProperty('transform', '');
    };
    MDCSlidingTabIndicatorFoundation.prototype.deactivate = function () {
        this.adapter_.removeClass(foundation_1.MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    };
    return MDCSlidingTabIndicatorFoundation;
}(foundation_1.MDCTabIndicatorFoundation);
exports.MDCSlidingTabIndicatorFoundation = MDCSlidingTabIndicatorFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCSlidingTabIndicatorFoundation;

/***/ }),

/***/ "./packages/mdc-tab-scroller/component.ts":
/*!************************************************!*\
  !*** ./packages/mdc-tab-scroller/component.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var events_1 = __webpack_require__(/*! @material/dom/events */ "./packages/mdc-dom/events.ts");
var ponyfill_1 = __webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-tab-scroller/foundation.ts");
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-tab-scroller/util.ts"));
var MDCTabScroller = /** @class */function (_super) {
    __extends(MDCTabScroller, _super);
    function MDCTabScroller() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScroller.attachTo = function (root) {
        return new MDCTabScroller(root);
    };
    MDCTabScroller.prototype.initialize = function () {
        this.area_ = this.root_.querySelector(foundation_1.MDCTabScrollerFoundation.strings.AREA_SELECTOR);
        this.content_ = this.root_.querySelector(foundation_1.MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
    };
    MDCTabScroller.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleInteraction_ = function () {
            return _this.foundation_.handleInteraction();
        };
        this.handleTransitionEnd_ = function (evt) {
            return _this.foundation_.handleTransitionEnd(evt);
        };
        this.area_.addEventListener('wheel', this.handleInteraction_, events_1.applyPassive());
        this.area_.addEventListener('touchstart', this.handleInteraction_, events_1.applyPassive());
        this.area_.addEventListener('pointerdown', this.handleInteraction_, events_1.applyPassive());
        this.area_.addEventListener('mousedown', this.handleInteraction_, events_1.applyPassive());
        this.area_.addEventListener('keydown', this.handleInteraction_, events_1.applyPassive());
        this.content_.addEventListener('transitionend', this.handleTransitionEnd_);
    };
    MDCTabScroller.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.area_.removeEventListener('wheel', this.handleInteraction_, events_1.applyPassive());
        this.area_.removeEventListener('touchstart', this.handleInteraction_, events_1.applyPassive());
        this.area_.removeEventListener('pointerdown', this.handleInteraction_, events_1.applyPassive());
        this.area_.removeEventListener('mousedown', this.handleInteraction_, events_1.applyPassive());
        this.area_.removeEventListener('keydown', this.handleInteraction_, events_1.applyPassive());
        this.content_.removeEventListener('transitionend', this.handleTransitionEnd_);
    };
    MDCTabScroller.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            eventTargetMatchesSelector: function eventTargetMatchesSelector(evtTarget, selector) {
                return ponyfill_1.matches(evtTarget, selector);
            },
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            addScrollAreaClass: function addScrollAreaClass(className) {
                return _this.area_.classList.add(className);
            },
            setScrollAreaStyleProperty: function setScrollAreaStyleProperty(prop, value) {
                return _this.area_.style.setProperty(prop, value);
            },
            setScrollContentStyleProperty: function setScrollContentStyleProperty(prop, value) {
                return _this.content_.style.setProperty(prop, value);
            },
            getScrollContentStyleValue: function getScrollContentStyleValue(propName) {
                return window.getComputedStyle(_this.content_).getPropertyValue(propName);
            },
            setScrollAreaScrollLeft: function setScrollAreaScrollLeft(scrollX) {
                return _this.area_.scrollLeft = scrollX;
            },
            getScrollAreaScrollLeft: function getScrollAreaScrollLeft() {
                return _this.area_.scrollLeft;
            },
            getScrollContentOffsetWidth: function getScrollContentOffsetWidth() {
                return _this.content_.offsetWidth;
            },
            getScrollAreaOffsetWidth: function getScrollAreaOffsetWidth() {
                return _this.area_.offsetWidth;
            },
            computeScrollAreaClientRect: function computeScrollAreaClientRect() {
                return _this.area_.getBoundingClientRect();
            },
            computeScrollContentClientRect: function computeScrollContentClientRect() {
                return _this.content_.getBoundingClientRect();
            },
            computeHorizontalScrollbarHeight: function computeHorizontalScrollbarHeight() {
                return util.computeHorizontalScrollbarHeight(document);
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_1.MDCTabScrollerFoundation(adapter);
    };
    /**
     * Returns the current visual scroll position
     */
    MDCTabScroller.prototype.getScrollPosition = function () {
        return this.foundation_.getScrollPosition();
    };
    /**
     * Returns the width of the scroll content
     */
    MDCTabScroller.prototype.getScrollContentWidth = function () {
        return this.content_.offsetWidth;
    };
    /**
     * Increments the scroll value by the given amount
     * @param scrollXIncrement The pixel value by which to increment the scroll value
     */
    MDCTabScroller.prototype.incrementScroll = function (scrollXIncrement) {
        this.foundation_.incrementScroll(scrollXIncrement);
    };
    /**
     * Scrolls to the given pixel position
     * @param scrollX The pixel value to scroll to
     */
    MDCTabScroller.prototype.scrollTo = function (scrollX) {
        this.foundation_.scrollTo(scrollX);
    };
    return MDCTabScroller;
}(component_1.MDCComponent);
exports.MDCTabScroller = MDCTabScroller;

/***/ }),

/***/ "./packages/mdc-tab-scroller/constants.ts":
/*!************************************************!*\
  !*** ./packages/mdc-tab-scroller/constants.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    ANIMATING: 'mdc-tab-scroller--animating',
    SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll',
    SCROLL_TEST: 'mdc-tab-scroller__test'
};
exports.cssClasses = cssClasses;
var strings = {
    AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
    CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content'
};
exports.strings = strings;

/***/ }),

/***/ "./packages/mdc-tab-scroller/foundation.ts":
/*!*************************************************!*\
  !*** ./packages/mdc-tab-scroller/foundation.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-tab-scroller/constants.ts");
var rtl_default_scroller_1 = __webpack_require__(/*! ./rtl-default-scroller */ "./packages/mdc-tab-scroller/rtl-default-scroller.ts");
var rtl_negative_scroller_1 = __webpack_require__(/*! ./rtl-negative-scroller */ "./packages/mdc-tab-scroller/rtl-negative-scroller.ts");
var rtl_reverse_scroller_1 = __webpack_require__(/*! ./rtl-reverse-scroller */ "./packages/mdc-tab-scroller/rtl-reverse-scroller.ts");
var MDCTabScrollerFoundation = /** @class */function (_super) {
    __extends(MDCTabScrollerFoundation, _super);
    function MDCTabScrollerFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCTabScrollerFoundation.defaultAdapter), adapter)) || this;
        /**
         * Controls whether we should handle the transitionend and interaction events during the animation.
         */
        _this.isAnimating_ = false;
        return _this;
    }
    Object.defineProperty(MDCTabScrollerFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabScrollerFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabScrollerFoundation, "defaultAdapter", {
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                eventTargetMatchesSelector: function eventTargetMatchesSelector() {
                    return false;
                },
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                addScrollAreaClass: function addScrollAreaClass() {
                    return undefined;
                },
                setScrollAreaStyleProperty: function setScrollAreaStyleProperty() {
                    return undefined;
                },
                setScrollContentStyleProperty: function setScrollContentStyleProperty() {
                    return undefined;
                },
                getScrollContentStyleValue: function getScrollContentStyleValue() {
                    return '';
                },
                setScrollAreaScrollLeft: function setScrollAreaScrollLeft() {
                    return undefined;
                },
                getScrollAreaScrollLeft: function getScrollAreaScrollLeft() {
                    return 0;
                },
                getScrollContentOffsetWidth: function getScrollContentOffsetWidth() {
                    return 0;
                },
                getScrollAreaOffsetWidth: function getScrollAreaOffsetWidth() {
                    return 0;
                },
                computeScrollAreaClientRect: function computeScrollAreaClientRect() {
                    return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
                },
                computeScrollContentClientRect: function computeScrollContentClientRect() {
                    return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
                },
                computeHorizontalScrollbarHeight: function computeHorizontalScrollbarHeight() {
                    return 0;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTabScrollerFoundation.prototype.init = function () {
        // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
        // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
        var horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
        this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
        this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
    };
    /**
     * Computes the current visual scroll position
     */
    MDCTabScrollerFoundation.prototype.getScrollPosition = function () {
        if (this.isRTL_()) {
            return this.computeCurrentScrollPositionRTL_();
        }
        var currentTranslateX = this.calculateCurrentTranslateX_();
        var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
        return scrollLeft - currentTranslateX;
    };
    /**
     * Handles interaction events that occur during transition
     */
    MDCTabScrollerFoundation.prototype.handleInteraction = function () {
        // Early exit if we aren't animating
        if (!this.isAnimating_) {
            return;
        }
        // Prevent other event listeners from handling this event
        this.stopScrollAnimation_();
    };
    /**
     * Handles the transitionend event
     */
    MDCTabScrollerFoundation.prototype.handleTransitionEnd = function (evt) {
        // Early exit if we aren't animating or the event was triggered by a different element.
        var evtTarget = evt.target;
        if (!this.isAnimating_ || !this.adapter_.eventTargetMatchesSelector(evtTarget, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
            return;
        }
        this.isAnimating_ = false;
        this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
    };
    /**
     * Increment the scroll value by the scrollXIncrement using animation.
     * @param scrollXIncrement The value by which to increment the scroll position
     */
    MDCTabScrollerFoundation.prototype.incrementScroll = function (scrollXIncrement) {
        // Early exit for non-operational increment values
        if (scrollXIncrement === 0) {
            return;
        }
        this.animate_(this.getIncrementScrollOperation_(scrollXIncrement));
    };
    /**
     * Increment the scroll value by the scrollXIncrement without animation.
     * @param scrollXIncrement The value by which to increment the scroll position
     */
    MDCTabScrollerFoundation.prototype.incrementScrollImmediate = function (scrollXIncrement) {
        // Early exit for non-operational increment values
        if (scrollXIncrement === 0) {
            return;
        }
        var operation = this.getIncrementScrollOperation_(scrollXIncrement);
        if (operation.scrollDelta === 0) {
            return;
        }
        this.stopScrollAnimation_();
        this.adapter_.setScrollAreaScrollLeft(operation.finalScrollPosition);
    };
    /**
     * Scrolls to the given scrollX value
     */
    MDCTabScrollerFoundation.prototype.scrollTo = function (scrollX) {
        if (this.isRTL_()) {
            return this.scrollToRTL_(scrollX);
        }
        this.scrollTo_(scrollX);
    };
    /**
     * @return Browser-specific {@link MDCTabScrollerRTL} instance.
     */
    MDCTabScrollerFoundation.prototype.getRTLScroller = function () {
        if (!this.rtlScrollerInstance_) {
            this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
        }
        return this.rtlScrollerInstance_;
    };
    /**
     * @return translateX value from a CSS matrix transform function string.
     */
    MDCTabScrollerFoundation.prototype.calculateCurrentTranslateX_ = function () {
        var transformValue = this.adapter_.getScrollContentStyleValue('transform');
        // Early exit if no transform is present
        if (transformValue === 'none') {
            return 0;
        }
        // The transform value comes back as a matrix transformation in the form
        // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
        // we're going to grab all the parenthesized values, strip out tx, and
        // parse it.
        var match = /\((.+?)\)/.exec(transformValue);
        if (!match) {
            return 0;
        }
        var matrixParams = match[1];
        // tslint:disable-next-line:ban-ts-ignore "Unused vars" should be a linter warning, not a compiler error.
        // @ts-ignore These unused variables should retain their semantic names for clarity.
        var _a = __read(matrixParams.split(','), 6),
            a = _a[0],
            b = _a[1],
            c = _a[2],
            d = _a[3],
            tx = _a[4],
            ty = _a[5];
        return parseFloat(tx); // tslint:disable-line:ban
    };
    /**
     * Calculates a safe scroll value that is > 0 and < the max scroll value
     * @param scrollX The distance to scroll
     */
    MDCTabScrollerFoundation.prototype.clampScrollValue_ = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.min(Math.max(edges.left, scrollX), edges.right);
    };
    MDCTabScrollerFoundation.prototype.computeCurrentScrollPositionRTL_ = function () {
        var translateX = this.calculateCurrentTranslateX_();
        return this.getRTLScroller().getScrollPositionRTL(translateX);
    };
    MDCTabScrollerFoundation.prototype.calculateScrollEdges_ = function () {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return {
            left: 0,
            right: contentWidth - rootWidth
        };
    };
    /**
     * Internal scroll method
     * @param scrollX The new scroll position
     */
    MDCTabScrollerFoundation.prototype.scrollTo_ = function (scrollX) {
        var currentScrollX = this.getScrollPosition();
        var safeScrollX = this.clampScrollValue_(scrollX);
        var scrollDelta = safeScrollX - currentScrollX;
        this.animate_({
            finalScrollPosition: safeScrollX,
            scrollDelta: scrollDelta
        });
    };
    /**
     * Internal RTL scroll method
     * @param scrollX The new scroll position
     */
    MDCTabScrollerFoundation.prototype.scrollToRTL_ = function (scrollX) {
        var animation = this.getRTLScroller().scrollToRTL(scrollX);
        this.animate_(animation);
    };
    /**
     * Internal method to compute the increment scroll operation values.
     * @param scrollX The desired scroll position increment
     * @return MDCTabScrollerAnimation with the sanitized values for performing the scroll operation.
     */
    MDCTabScrollerFoundation.prototype.getIncrementScrollOperation_ = function (scrollX) {
        if (this.isRTL_()) {
            return this.getRTLScroller().incrementScrollRTL(scrollX);
        }
        var currentScrollX = this.getScrollPosition();
        var targetScrollX = scrollX + currentScrollX;
        var safeScrollX = this.clampScrollValue_(targetScrollX);
        var scrollDelta = safeScrollX - currentScrollX;
        return {
            finalScrollPosition: safeScrollX,
            scrollDelta: scrollDelta
        };
    };
    /**
     * Animates the tab scrolling
     * @param animation The animation to apply
     */
    MDCTabScrollerFoundation.prototype.animate_ = function (animation) {
        var _this = this;
        // Early exit if translateX is 0, which means there's no animation to perform
        if (animation.scrollDelta === 0) {
            return;
        }
        this.stopScrollAnimation_();
        // This animation uses the FLIP approach.
        // Read more here: https://aerotwist.com/blog/flip-your-animations/
        this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
        this.adapter_.setScrollContentStyleProperty('transform', "translateX(" + animation.scrollDelta + "px)");
        // Force repaint
        this.adapter_.computeScrollAreaClientRect();
        requestAnimationFrame(function () {
            _this.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
            _this.adapter_.setScrollContentStyleProperty('transform', 'none');
        });
        this.isAnimating_ = true;
    };
    /**
     * Stops scroll animation
     */
    MDCTabScrollerFoundation.prototype.stopScrollAnimation_ = function () {
        this.isAnimating_ = false;
        var currentScrollPosition = this.getAnimatingScrollPosition_();
        this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
        this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
        this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
    };
    /**
     * Gets the current scroll position during animation
     */
    MDCTabScrollerFoundation.prototype.getAnimatingScrollPosition_ = function () {
        var currentTranslateX = this.calculateCurrentTranslateX_();
        var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
        if (this.isRTL_()) {
            return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
        }
        return scrollLeft - currentTranslateX;
    };
    /**
     * Determines the RTL Scroller to use
     */
    MDCTabScrollerFoundation.prototype.rtlScrollerFactory_ = function () {
        // Browsers have three different implementations of scrollLeft in RTL mode,
        // dependent on the browser. The behavior is based off the max LTR
        // scrollLeft value and 0.
        //
        // * Default scrolling in RTL *
        //    - Left-most value: 0
        //    - Right-most value: Max LTR scrollLeft value
        //
        // * Negative scrolling in RTL *
        //    - Left-most value: Negated max LTR scrollLeft value
        //    - Right-most value: 0
        //
        // * Reverse scrolling in RTL *
        //    - Left-most value: Max LTR scrollLeft value
        //    - Right-most value: 0
        //
        // We use those principles below to determine which RTL scrollLeft
        // behavior is implemented in the current browser.
        var initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
        var newScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        // If the newScrollLeft value is negative,then we know that the browser has
        // implemented negative RTL scrolling, since all other implementations have
        // only positive values.
        if (newScrollLeft < 0) {
            // Undo the scrollLeft test check
            this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
            return new rtl_negative_scroller_1.MDCTabScrollerRTLNegative(this.adapter_);
        }
        var rootClientRect = this.adapter_.computeScrollAreaClientRect();
        var contentClientRect = this.adapter_.computeScrollContentClientRect();
        var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right);
        // Undo the scrollLeft test check
        this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
        // By calculating the clientRect of the root element and the clientRect of
        // the content element, we can determine how much the scroll value changed
        // when we performed the scrollLeft subtraction above.
        if (rightEdgeDelta === newScrollLeft) {
            return new rtl_reverse_scroller_1.MDCTabScrollerRTLReverse(this.adapter_);
        }
        return new rtl_default_scroller_1.MDCTabScrollerRTLDefault(this.adapter_);
    };
    MDCTabScrollerFoundation.prototype.isRTL_ = function () {
        return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
    };
    return MDCTabScrollerFoundation;
}(foundation_1.MDCFoundation);
exports.MDCTabScrollerFoundation = MDCTabScrollerFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTabScrollerFoundation;

/***/ }),

/***/ "./packages/mdc-tab-scroller/index.ts":
/*!********************************************!*\
  !*** ./packages/mdc-tab-scroller/index.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = __importStar(__webpack_require__(/*! ./util */ "./packages/mdc-tab-scroller/util.ts"));
exports.util = util;
__export(__webpack_require__(/*! ./component */ "./packages/mdc-tab-scroller/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-tab-scroller/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-tab-scroller/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-tab-scroller/rtl-default-scroller.ts":
/*!***********************************************************!*\
  !*** ./packages/mdc-tab-scroller/rtl-default-scroller.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var rtl_scroller_1 = __webpack_require__(/*! ./rtl-scroller */ "./packages/mdc-tab-scroller/rtl-scroller.ts");
var MDCTabScrollerRTLDefault = /** @class */function (_super) {
    __extends(MDCTabScrollerRTLDefault, _super);
    function MDCTabScrollerRTLDefault() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScrollerRTLDefault.prototype.getScrollPositionRTL = function () {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var right = this.calculateScrollEdges_().right;
        // Scroll values on most browsers are ints instead of floats so we round
        return Math.round(right - currentScrollLeft);
    };
    MDCTabScrollerRTLDefault.prototype.scrollToRTL = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft
        };
    };
    MDCTabScrollerRTLDefault.prototype.incrementScrollRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft
        };
    };
    MDCTabScrollerRTLDefault.prototype.getAnimatingScrollPosition = function (scrollX) {
        return scrollX;
    };
    MDCTabScrollerRTLDefault.prototype.calculateScrollEdges_ = function () {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return {
            left: 0,
            right: contentWidth - rootWidth
        };
    };
    MDCTabScrollerRTLDefault.prototype.clampScrollValue_ = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.min(Math.max(edges.left, scrollX), edges.right);
    };
    return MDCTabScrollerRTLDefault;
}(rtl_scroller_1.MDCTabScrollerRTL);
exports.MDCTabScrollerRTLDefault = MDCTabScrollerRTLDefault;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTabScrollerRTLDefault;

/***/ }),

/***/ "./packages/mdc-tab-scroller/rtl-negative-scroller.ts":
/*!************************************************************!*\
  !*** ./packages/mdc-tab-scroller/rtl-negative-scroller.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var rtl_scroller_1 = __webpack_require__(/*! ./rtl-scroller */ "./packages/mdc-tab-scroller/rtl-scroller.ts");
var MDCTabScrollerRTLNegative = /** @class */function (_super) {
    __extends(MDCTabScrollerRTLNegative, _super);
    function MDCTabScrollerRTLNegative() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScrollerRTLNegative.prototype.getScrollPositionRTL = function (translateX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        return Math.round(translateX - currentScrollLeft);
    };
    MDCTabScrollerRTLNegative.prototype.scrollToRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(-scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft
        };
    };
    MDCTabScrollerRTLNegative.prototype.incrementScrollRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft
        };
    };
    MDCTabScrollerRTLNegative.prototype.getAnimatingScrollPosition = function (scrollX, translateX) {
        return scrollX - translateX;
    };
    MDCTabScrollerRTLNegative.prototype.calculateScrollEdges_ = function () {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return {
            left: rootWidth - contentWidth,
            right: 0
        };
    };
    MDCTabScrollerRTLNegative.prototype.clampScrollValue_ = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.max(Math.min(edges.right, scrollX), edges.left);
    };
    return MDCTabScrollerRTLNegative;
}(rtl_scroller_1.MDCTabScrollerRTL);
exports.MDCTabScrollerRTLNegative = MDCTabScrollerRTLNegative;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTabScrollerRTLNegative;

/***/ }),

/***/ "./packages/mdc-tab-scroller/rtl-reverse-scroller.ts":
/*!***********************************************************!*\
  !*** ./packages/mdc-tab-scroller/rtl-reverse-scroller.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var rtl_scroller_1 = __webpack_require__(/*! ./rtl-scroller */ "./packages/mdc-tab-scroller/rtl-scroller.ts");
var MDCTabScrollerRTLReverse = /** @class */function (_super) {
    __extends(MDCTabScrollerRTLReverse, _super);
    function MDCTabScrollerRTLReverse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScrollerRTLReverse.prototype.getScrollPositionRTL = function (translateX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        // Scroll values on most browsers are ints instead of floats so we round
        return Math.round(currentScrollLeft - translateX);
    };
    MDCTabScrollerRTLReverse.prototype.scrollToRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: currentScrollLeft - clampedScrollLeft
        };
    };
    MDCTabScrollerRTLReverse.prototype.incrementScrollRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: currentScrollLeft - clampedScrollLeft
        };
    };
    MDCTabScrollerRTLReverse.prototype.getAnimatingScrollPosition = function (scrollX, translateX) {
        return scrollX + translateX;
    };
    MDCTabScrollerRTLReverse.prototype.calculateScrollEdges_ = function () {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return {
            left: contentWidth - rootWidth,
            right: 0
        };
    };
    MDCTabScrollerRTLReverse.prototype.clampScrollValue_ = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.min(Math.max(edges.right, scrollX), edges.left);
    };
    return MDCTabScrollerRTLReverse;
}(rtl_scroller_1.MDCTabScrollerRTL);
exports.MDCTabScrollerRTLReverse = MDCTabScrollerRTLReverse;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTabScrollerRTLReverse;

/***/ }),

/***/ "./packages/mdc-tab-scroller/rtl-scroller.ts":
/*!***************************************************!*\
  !*** ./packages/mdc-tab-scroller/rtl-scroller.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var MDCTabScrollerRTL = /** @class */function () {
    function MDCTabScrollerRTL(adapter) {
        this.adapter_ = adapter;
    }
    return MDCTabScrollerRTL;
}();
exports.MDCTabScrollerRTL = MDCTabScrollerRTL;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTabScrollerRTL;

/***/ }),

/***/ "./packages/mdc-tab-scroller/util.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-tab-scroller/util.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-tab-scroller/constants.ts");
/**
 * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
 */
var horizontalScrollbarHeight_;
/**
 * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
 * May return 0 (e.g. on OS X browsers under default configuration).
 */
function computeHorizontalScrollbarHeight(documentObj, shouldCacheResult) {
  if (shouldCacheResult === void 0) {
    shouldCacheResult = true;
  }
  if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== 'undefined') {
    return horizontalScrollbarHeight_;
  }
  var el = documentObj.createElement('div');
  el.classList.add(constants_1.cssClasses.SCROLL_TEST);
  documentObj.body.appendChild(el);
  var horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
  documentObj.body.removeChild(el);
  if (shouldCacheResult) {
    horizontalScrollbarHeight_ = horizontalScrollbarHeight;
  }
  return horizontalScrollbarHeight;
}
exports.computeHorizontalScrollbarHeight = computeHorizontalScrollbarHeight;

/***/ }),

/***/ "./packages/mdc-tab/component.ts":
/*!***************************************!*\
  !*** ./packages/mdc-tab/component.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var component_2 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! @material/ripple/foundation */ "./packages/mdc-ripple/foundation.ts");
var component_3 = __webpack_require__(/*! @material/tab-indicator/component */ "./packages/mdc-tab-indicator/component.ts");
var foundation_2 = __webpack_require__(/*! ./foundation */ "./packages/mdc-tab/foundation.ts");
var MDCTab = /** @class */function (_super) {
    __extends(MDCTab, _super);
    function MDCTab() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTab.attachTo = function (root) {
        return new MDCTab(root);
    };
    MDCTab.prototype.initialize = function (rippleFactory, tabIndicatorFactory) {
        if (rippleFactory === void 0) {
            rippleFactory = function rippleFactory(el, foundation) {
                return new component_2.MDCRipple(el, foundation);
            };
        }
        if (tabIndicatorFactory === void 0) {
            tabIndicatorFactory = function tabIndicatorFactory(el) {
                return new component_3.MDCTabIndicator(el);
            };
        }
        this.id = this.root_.id;
        var rippleSurface = this.root_.querySelector(foundation_2.MDCTabFoundation.strings.RIPPLE_SELECTOR);
        var rippleAdapter = __assign(__assign({}, component_2.MDCRipple.createAdapter(this)), { addClass: function addClass(className) {
                return rippleSurface.classList.add(className);
            }, removeClass: function removeClass(className) {
                return rippleSurface.classList.remove(className);
            }, updateCssVariable: function updateCssVariable(varName, value) {
                return rippleSurface.style.setProperty(varName, value);
            } });
        var rippleFoundation = new foundation_1.MDCRippleFoundation(rippleAdapter);
        this.ripple_ = rippleFactory(this.root_, rippleFoundation);
        var tabIndicatorElement = this.root_.querySelector(foundation_2.MDCTabFoundation.strings.TAB_INDICATOR_SELECTOR);
        this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
        this.content_ = this.root_.querySelector(foundation_2.MDCTabFoundation.strings.CONTENT_SELECTOR);
    };
    MDCTab.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleClick_ = function () {
            return _this.foundation_.handleClick();
        };
        this.listen('click', this.handleClick_);
    };
    MDCTab.prototype.destroy = function () {
        this.unlisten('click', this.handleClick_);
        this.ripple_.destroy();
        _super.prototype.destroy.call(this);
    };
    MDCTab.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            setAttr: function setAttr(attr, value) {
                return _this.root_.setAttribute(attr, value);
            },
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            activateIndicator: function activateIndicator(previousIndicatorClientRect) {
                return _this.tabIndicator_.activate(previousIndicatorClientRect);
            },
            deactivateIndicator: function deactivateIndicator() {
                return _this.tabIndicator_.deactivate();
            },
            notifyInteracted: function notifyInteracted() {
                return _this.emit(foundation_2.MDCTabFoundation.strings.INTERACTED_EVENT, { tabId: _this.id }, true /* bubble */);
            },
            getOffsetLeft: function getOffsetLeft() {
                return _this.root_.offsetLeft;
            },
            getOffsetWidth: function getOffsetWidth() {
                return _this.root_.offsetWidth;
            },
            getContentOffsetLeft: function getContentOffsetLeft() {
                return _this.content_.offsetLeft;
            },
            getContentOffsetWidth: function getContentOffsetWidth() {
                return _this.content_.offsetWidth;
            },
            focus: function focus() {
                return _this.root_.focus();
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_2.MDCTabFoundation(adapter);
    };
    Object.defineProperty(MDCTab.prototype, "active", {
        /**
         * Getter for the active state of the tab
         */
        get: function get() {
            return this.foundation_.isActive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTab.prototype, "focusOnActivate", {
        set: function set(focusOnActivate) {
            this.foundation_.setFocusOnActivate(focusOnActivate);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Activates the tab
     */
    MDCTab.prototype.activate = function (computeIndicatorClientRect) {
        this.foundation_.activate(computeIndicatorClientRect);
    };
    /**
     * Deactivates the tab
     */
    MDCTab.prototype.deactivate = function () {
        this.foundation_.deactivate();
    };
    /**
     * Returns the indicator's client rect
     */
    MDCTab.prototype.computeIndicatorClientRect = function () {
        return this.tabIndicator_.computeContentClientRect();
    };
    MDCTab.prototype.computeDimensions = function () {
        return this.foundation_.computeDimensions();
    };
    /**
     * Focuses the tab
     */
    MDCTab.prototype.focus = function () {
        this.root_.focus();
    };
    return MDCTab;
}(component_1.MDCComponent);
exports.MDCTab = MDCTab;

/***/ }),

/***/ "./packages/mdc-tab/constants.ts":
/*!***************************************!*\
  !*** ./packages/mdc-tab/constants.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    ACTIVE: 'mdc-tab--active'
};
exports.cssClasses = cssClasses;
var strings = {
    ARIA_SELECTED: 'aria-selected',
    CONTENT_SELECTOR: '.mdc-tab__content',
    INTERACTED_EVENT: 'MDCTab:interacted',
    RIPPLE_SELECTOR: '.mdc-tab__ripple',
    TABINDEX: 'tabIndex',
    TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator'
};
exports.strings = strings;

/***/ }),

/***/ "./packages/mdc-tab/foundation.ts":
/*!****************************************!*\
  !*** ./packages/mdc-tab/foundation.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-tab/constants.ts");
var MDCTabFoundation = /** @class */function (_super) {
    __extends(MDCTabFoundation, _super);
    function MDCTabFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCTabFoundation.defaultAdapter), adapter)) || this;
        _this.focusOnActivate_ = true;
        return _this;
    }
    Object.defineProperty(MDCTabFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabFoundation, "defaultAdapter", {
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return false;
                },
                setAttr: function setAttr() {
                    return undefined;
                },
                activateIndicator: function activateIndicator() {
                    return undefined;
                },
                deactivateIndicator: function deactivateIndicator() {
                    return undefined;
                },
                notifyInteracted: function notifyInteracted() {
                    return undefined;
                },
                getOffsetLeft: function getOffsetLeft() {
                    return 0;
                },
                getOffsetWidth: function getOffsetWidth() {
                    return 0;
                },
                getContentOffsetLeft: function getContentOffsetLeft() {
                    return 0;
                },
                getContentOffsetWidth: function getContentOffsetWidth() {
                    return 0;
                },
                focus: function focus() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTabFoundation.prototype.handleClick = function () {
        // It's up to the parent component to keep track of the active Tab and
        // ensure we don't activate a Tab that's already active.
        this.adapter_.notifyInteracted();
    };
    MDCTabFoundation.prototype.isActive = function () {
        return this.adapter_.hasClass(constants_1.cssClasses.ACTIVE);
    };
    /**
     * Sets whether the tab should focus itself when activated
     */
    MDCTabFoundation.prototype.setFocusOnActivate = function (focusOnActivate) {
        this.focusOnActivate_ = focusOnActivate;
    };
    /**
     * Activates the Tab
     */
    MDCTabFoundation.prototype.activate = function (previousIndicatorClientRect) {
        this.adapter_.addClass(constants_1.cssClasses.ACTIVE);
        this.adapter_.setAttr(constants_1.strings.ARIA_SELECTED, 'true');
        this.adapter_.setAttr(constants_1.strings.TABINDEX, '0');
        this.adapter_.activateIndicator(previousIndicatorClientRect);
        if (this.focusOnActivate_) {
            this.adapter_.focus();
        }
    };
    /**
     * Deactivates the Tab
     */
    MDCTabFoundation.prototype.deactivate = function () {
        // Early exit
        if (!this.isActive()) {
            return;
        }
        this.adapter_.removeClass(constants_1.cssClasses.ACTIVE);
        this.adapter_.setAttr(constants_1.strings.ARIA_SELECTED, 'false');
        this.adapter_.setAttr(constants_1.strings.TABINDEX, '-1');
        this.adapter_.deactivateIndicator();
    };
    /**
     * Returns the dimensions of the Tab
     */
    MDCTabFoundation.prototype.computeDimensions = function () {
        var rootWidth = this.adapter_.getOffsetWidth();
        var rootLeft = this.adapter_.getOffsetLeft();
        var contentWidth = this.adapter_.getContentOffsetWidth();
        var contentLeft = this.adapter_.getContentOffsetLeft();
        return {
            contentLeft: rootLeft + contentLeft,
            contentRight: rootLeft + contentLeft + contentWidth,
            rootLeft: rootLeft,
            rootRight: rootLeft + rootWidth
        };
    };
    return MDCTabFoundation;
}(foundation_1.MDCFoundation);
exports.MDCTabFoundation = MDCTabFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTabFoundation;

/***/ }),

/***/ "./packages/mdc-tab/index.ts":
/*!***********************************!*\
  !*** ./packages/mdc-tab/index.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-tab/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-tab/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-tab/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-textfield/character-counter/component.ts":
/*!***************************************************************!*\
  !*** ./packages/mdc-textfield/character-counter/component.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-textfield/character-counter/foundation.ts");
var MDCTextFieldCharacterCounter = /** @class */function (_super) {
    __extends(MDCTextFieldCharacterCounter, _super);
    function MDCTextFieldCharacterCounter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTextFieldCharacterCounter.attachTo = function (root) {
        return new MDCTextFieldCharacterCounter(root);
    };
    Object.defineProperty(MDCTextFieldCharacterCounter.prototype, "foundation", {
        get: function get() {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldCharacterCounter.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            setContent: function setContent(content) {
                _this.root_.textContent = content;
            }
        };
        return new foundation_1.MDCTextFieldCharacterCounterFoundation(adapter);
    };
    return MDCTextFieldCharacterCounter;
}(component_1.MDCComponent);
exports.MDCTextFieldCharacterCounter = MDCTextFieldCharacterCounter;

/***/ }),

/***/ "./packages/mdc-textfield/character-counter/constants.ts":
/*!***************************************************************!*\
  !*** ./packages/mdc-textfield/character-counter/constants.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    ROOT: 'mdc-text-field-character-counter'
};
exports.cssClasses = cssClasses;
var strings = {
    ROOT_SELECTOR: "." + cssClasses.ROOT
};
exports.strings = strings;

/***/ }),

/***/ "./packages/mdc-textfield/character-counter/foundation.ts":
/*!****************************************************************!*\
  !*** ./packages/mdc-textfield/character-counter/foundation.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-textfield/character-counter/constants.ts");
var MDCTextFieldCharacterCounterFoundation = /** @class */function (_super) {
    __extends(MDCTextFieldCharacterCounterFoundation, _super);
    function MDCTextFieldCharacterCounterFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCTextFieldCharacterCounterFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTextFieldCharacterCounterAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            return {
                setContent: function setContent() {
                    return undefined;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldCharacterCounterFoundation.prototype.setCounterValue = function (currentLength, maxLength) {
        currentLength = Math.min(currentLength, maxLength);
        this.adapter_.setContent(currentLength + " / " + maxLength);
    };
    return MDCTextFieldCharacterCounterFoundation;
}(foundation_1.MDCFoundation);
exports.MDCTextFieldCharacterCounterFoundation = MDCTextFieldCharacterCounterFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTextFieldCharacterCounterFoundation;

/***/ }),

/***/ "./packages/mdc-textfield/character-counter/index.ts":
/*!***********************************************************!*\
  !*** ./packages/mdc-textfield/character-counter/index.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-textfield/character-counter/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-textfield/character-counter/foundation.ts"));
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-textfield/character-counter/constants.ts");
exports.characterCountCssClasses = constants_1.cssClasses;
exports.characterCountStrings = constants_1.strings;

/***/ }),

/***/ "./packages/mdc-textfield/component.ts":
/*!*********************************************!*\
  !*** ./packages/mdc-textfield/component.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var events_1 = __webpack_require__(/*! @material/dom/events */ "./packages/mdc-dom/events.ts");
var ponyfill = __importStar(__webpack_require__(/*! @material/dom/ponyfill */ "./packages/mdc-dom/ponyfill.ts"));
var component_2 = __webpack_require__(/*! @material/floating-label/component */ "./packages/mdc-floating-label/component.ts");
var component_3 = __webpack_require__(/*! @material/line-ripple/component */ "./packages/mdc-line-ripple/component.ts");
var component_4 = __webpack_require__(/*! @material/notched-outline/component */ "./packages/mdc-notched-outline/component.ts");
var component_5 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var foundation_1 = __webpack_require__(/*! @material/ripple/foundation */ "./packages/mdc-ripple/foundation.ts");
var component_6 = __webpack_require__(/*! ./character-counter/component */ "./packages/mdc-textfield/character-counter/component.ts");
var foundation_2 = __webpack_require__(/*! ./character-counter/foundation */ "./packages/mdc-textfield/character-counter/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-textfield/constants.ts");
var foundation_3 = __webpack_require__(/*! ./foundation */ "./packages/mdc-textfield/foundation.ts");
var component_7 = __webpack_require__(/*! ./helper-text/component */ "./packages/mdc-textfield/helper-text/component.ts");
var foundation_4 = __webpack_require__(/*! ./helper-text/foundation */ "./packages/mdc-textfield/helper-text/foundation.ts");
var component_8 = __webpack_require__(/*! ./icon/component */ "./packages/mdc-textfield/icon/component.ts");
var MDCTextField = /** @class */function (_super) {
    __extends(MDCTextField, _super);
    function MDCTextField() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTextField.attachTo = function (root) {
        return new MDCTextField(root);
    };
    MDCTextField.prototype.initialize = function (rippleFactory, lineRippleFactory, helperTextFactory, characterCounterFactory, iconFactory, labelFactory, outlineFactory) {
        if (rippleFactory === void 0) {
            rippleFactory = function rippleFactory(el, foundation) {
                return new component_5.MDCRipple(el, foundation);
            };
        }
        if (lineRippleFactory === void 0) {
            lineRippleFactory = function lineRippleFactory(el) {
                return new component_3.MDCLineRipple(el);
            };
        }
        if (helperTextFactory === void 0) {
            helperTextFactory = function helperTextFactory(el) {
                return new component_7.MDCTextFieldHelperText(el);
            };
        }
        if (characterCounterFactory === void 0) {
            characterCounterFactory = function characterCounterFactory(el) {
                return new component_6.MDCTextFieldCharacterCounter(el);
            };
        }
        if (iconFactory === void 0) {
            iconFactory = function iconFactory(el) {
                return new component_8.MDCTextFieldIcon(el);
            };
        }
        if (labelFactory === void 0) {
            labelFactory = function labelFactory(el) {
                return new component_2.MDCFloatingLabel(el);
            };
        }
        if (outlineFactory === void 0) {
            outlineFactory = function outlineFactory(el) {
                return new component_4.MDCNotchedOutline(el);
            };
        }
        this.input_ = this.root_.querySelector(constants_1.strings.INPUT_SELECTOR);
        var labelElement = this.root_.querySelector(constants_1.strings.LABEL_SELECTOR);
        this.label_ = labelElement ? labelFactory(labelElement) : null;
        var lineRippleElement = this.root_.querySelector(constants_1.strings.LINE_RIPPLE_SELECTOR);
        this.lineRipple_ = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
        var outlineElement = this.root_.querySelector(constants_1.strings.OUTLINE_SELECTOR);
        this.outline_ = outlineElement ? outlineFactory(outlineElement) : null;
        // Helper text
        var helperTextStrings = foundation_4.MDCTextFieldHelperTextFoundation.strings;
        var nextElementSibling = this.root_.nextElementSibling;
        var hasHelperLine = nextElementSibling && nextElementSibling.classList.contains(constants_1.cssClasses.HELPER_LINE);
        var helperTextEl = hasHelperLine && nextElementSibling && nextElementSibling.querySelector(helperTextStrings.ROOT_SELECTOR);
        this.helperText_ = helperTextEl ? helperTextFactory(helperTextEl) : null;
        // Character counter
        var characterCounterStrings = foundation_2.MDCTextFieldCharacterCounterFoundation.strings;
        var characterCounterEl = this.root_.querySelector(characterCounterStrings.ROOT_SELECTOR);
        // If character counter is not found in root element search in sibling element.
        if (!characterCounterEl && hasHelperLine && nextElementSibling) {
            characterCounterEl = nextElementSibling.querySelector(characterCounterStrings.ROOT_SELECTOR);
        }
        this.characterCounter_ = characterCounterEl ? characterCounterFactory(characterCounterEl) : null;
        // Leading icon
        var leadingIconEl = this.root_.querySelector(constants_1.strings.LEADING_ICON_SELECTOR);
        this.leadingIcon_ = leadingIconEl ? iconFactory(leadingIconEl) : null;
        // Trailing icon
        var trailingIconEl = this.root_.querySelector(constants_1.strings.TRAILING_ICON_SELECTOR);
        this.trailingIcon_ = trailingIconEl ? iconFactory(trailingIconEl) : null;
        // Prefix and Suffix
        this.prefix_ = this.root_.querySelector(constants_1.strings.PREFIX_SELECTOR);
        this.suffix_ = this.root_.querySelector(constants_1.strings.SUFFIX_SELECTOR);
        this.ripple = this.createRipple_(rippleFactory);
    };
    MDCTextField.prototype.destroy = function () {
        if (this.ripple) {
            this.ripple.destroy();
        }
        if (this.lineRipple_) {
            this.lineRipple_.destroy();
        }
        if (this.helperText_) {
            this.helperText_.destroy();
        }
        if (this.characterCounter_) {
            this.characterCounter_.destroy();
        }
        if (this.leadingIcon_) {
            this.leadingIcon_.destroy();
        }
        if (this.trailingIcon_) {
            this.trailingIcon_.destroy();
        }
        if (this.label_) {
            this.label_.destroy();
        }
        if (this.outline_) {
            this.outline_.destroy();
        }
        _super.prototype.destroy.call(this);
    };
    /**
     * Initializes the Text Field's internal state based on the environment's
     * state.
     */
    MDCTextField.prototype.initialSyncWithDOM = function () {
        this.disabled = this.input_.disabled;
    };
    Object.defineProperty(MDCTextField.prototype, "value", {
        get: function get() {
            return this.foundation_.getValue();
        },
        /**
         * @param value The value to set on the input.
         */
        set: function set(value) {
            this.foundation_.setValue(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "disabled", {
        get: function get() {
            return this.foundation_.isDisabled();
        },
        /**
         * @param disabled Sets the Text Field disabled or enabled.
         */
        set: function set(disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "valid", {
        get: function get() {
            return this.foundation_.isValid();
        },
        /**
         * @param valid Sets the Text Field valid or invalid.
         */
        set: function set(valid) {
            this.foundation_.setValid(valid);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "required", {
        get: function get() {
            return this.input_.required;
        },
        /**
         * @param required Sets the Text Field to required.
         */
        set: function set(required) {
            this.input_.required = required;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "pattern", {
        get: function get() {
            return this.input_.pattern;
        },
        /**
         * @param pattern Sets the input element's validation pattern.
         */
        set: function set(pattern) {
            this.input_.pattern = pattern;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "minLength", {
        get: function get() {
            return this.input_.minLength;
        },
        /**
         * @param minLength Sets the input element's minLength.
         */
        set: function set(minLength) {
            this.input_.minLength = minLength;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "maxLength", {
        get: function get() {
            return this.input_.maxLength;
        },
        /**
         * @param maxLength Sets the input element's maxLength.
         */
        set: function set(maxLength) {
            // Chrome throws exception if maxLength is set to a value less than zero
            if (maxLength < 0) {
                this.input_.removeAttribute('maxLength');
            } else {
                this.input_.maxLength = maxLength;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "min", {
        get: function get() {
            return this.input_.min;
        },
        /**
         * @param min Sets the input element's min.
         */
        set: function set(min) {
            this.input_.min = min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "max", {
        get: function get() {
            return this.input_.max;
        },
        /**
         * @param max Sets the input element's max.
         */
        set: function set(max) {
            this.input_.max = max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "step", {
        get: function get() {
            return this.input_.step;
        },
        /**
         * @param step Sets the input element's step.
         */
        set: function set(step) {
            this.input_.step = step;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "helperTextContent", {
        /**
         * Sets the helper text element content.
         */
        set: function set(content) {
            this.foundation_.setHelperTextContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "leadingIconAriaLabel", {
        /**
         * Sets the aria label of the leading icon.
         */
        set: function set(label) {
            this.foundation_.setLeadingIconAriaLabel(label);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "leadingIconContent", {
        /**
         * Sets the text content of the leading icon.
         */
        set: function set(content) {
            this.foundation_.setLeadingIconContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "trailingIconAriaLabel", {
        /**
         * Sets the aria label of the trailing icon.
         */
        set: function set(label) {
            this.foundation_.setTrailingIconAriaLabel(label);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "trailingIconContent", {
        /**
         * Sets the text content of the trailing icon.
         */
        set: function set(content) {
            this.foundation_.setTrailingIconContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "useNativeValidation", {
        /**
         * Enables or disables the use of native validation. Use this for custom validation.
         * @param useNativeValidation Set this to false to ignore native input validation.
         */
        set: function set(useNativeValidation) {
            this.foundation_.setUseNativeValidation(useNativeValidation);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "prefixText", {
        /**
         * Gets the text content of the prefix, or null if it does not exist.
         */
        get: function get() {
            return this.prefix_ ? this.prefix_.textContent : null;
        },
        /**
         * Sets the text content of the prefix, if it exists.
         */
        set: function set(prefixText) {
            if (this.prefix_) {
                this.prefix_.textContent = prefixText;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "suffixText", {
        /**
         * Gets the text content of the suffix, or null if it does not exist.
         */
        get: function get() {
            return this.suffix_ ? this.suffix_.textContent : null;
        },
        /**
         * Sets the text content of the suffix, if it exists.
         */
        set: function set(suffixText) {
            if (this.suffix_) {
                this.suffix_.textContent = suffixText;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Focuses the input element.
     */
    MDCTextField.prototype.focus = function () {
        this.input_.focus();
    };
    /**
     * Recomputes the outline SVG path for the outline element.
     */
    MDCTextField.prototype.layout = function () {
        var openNotch = this.foundation_.shouldFloat;
        this.foundation_.notchOutline(openNotch);
    };
    MDCTextField.prototype.getDefaultFoundation = function () {
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = __assign(__assign(__assign(__assign(__assign({}, this.getRootAdapterMethods_()), this.getInputAdapterMethods_()), this.getLabelAdapterMethods_()), this.getLineRippleAdapterMethods_()), this.getOutlineAdapterMethods_());
        // tslint:enable:object-literal-sort-keys
        return new foundation_3.MDCTextFieldFoundation(adapter, this.getFoundationMap_());
    };
    MDCTextField.prototype.getRootAdapterMethods_ = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
                return _this.listen(evtType, handler);
            },
            deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
                return _this.unlisten(evtType, handler);
            },
            registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {
                var getAttributesList = function getAttributesList(mutationsList) {
                    return mutationsList.map(function (mutation) {
                        return mutation.attributeName;
                    }).filter(function (attributeName) {
                        return attributeName;
                    });
                };
                var observer = new MutationObserver(function (mutationsList) {
                    return handler(getAttributesList(mutationsList));
                });
                var config = { attributes: true };
                observer.observe(_this.input_, config);
                return observer;
            },
            deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {
                return observer.disconnect();
            }
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCTextField.prototype.getInputAdapterMethods_ = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            getNativeInput: function getNativeInput() {
                return _this.input_;
            },
            isFocused: function isFocused() {
                return document.activeElement === _this.input_;
            },
            registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
                return _this.input_.addEventListener(evtType, handler, events_1.applyPassive());
            },
            deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
                return _this.input_.removeEventListener(evtType, handler, events_1.applyPassive());
            }
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCTextField.prototype.getLabelAdapterMethods_ = function () {
        var _this = this;
        return {
            floatLabel: function floatLabel(shouldFloat) {
                return _this.label_ && _this.label_.float(shouldFloat);
            },
            getLabelWidth: function getLabelWidth() {
                return _this.label_ ? _this.label_.getWidth() : 0;
            },
            hasLabel: function hasLabel() {
                return Boolean(_this.label_);
            },
            shakeLabel: function shakeLabel(shouldShake) {
                return _this.label_ && _this.label_.shake(shouldShake);
            }
        };
    };
    MDCTextField.prototype.getLineRippleAdapterMethods_ = function () {
        var _this = this;
        return {
            activateLineRipple: function activateLineRipple() {
                if (_this.lineRipple_) {
                    _this.lineRipple_.activate();
                }
            },
            deactivateLineRipple: function deactivateLineRipple() {
                if (_this.lineRipple_) {
                    _this.lineRipple_.deactivate();
                }
            },
            setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
                if (_this.lineRipple_) {
                    _this.lineRipple_.setRippleCenter(normalizedX);
                }
            }
        };
    };
    MDCTextField.prototype.getOutlineAdapterMethods_ = function () {
        var _this = this;
        return {
            closeOutline: function closeOutline() {
                return _this.outline_ && _this.outline_.closeNotch();
            },
            hasOutline: function hasOutline() {
                return Boolean(_this.outline_);
            },
            notchOutline: function notchOutline(labelWidth) {
                return _this.outline_ && _this.outline_.notch(labelWidth);
            }
        };
    };
    /**
     * @return A map of all subcomponents to subfoundations.
     */
    MDCTextField.prototype.getFoundationMap_ = function () {
        return {
            characterCounter: this.characterCounter_ ? this.characterCounter_.foundation : undefined,
            helperText: this.helperText_ ? this.helperText_.foundation : undefined,
            leadingIcon: this.leadingIcon_ ? this.leadingIcon_.foundation : undefined,
            trailingIcon: this.trailingIcon_ ? this.trailingIcon_.foundation : undefined
        };
    };
    MDCTextField.prototype.createRipple_ = function (rippleFactory) {
        var _this = this;
        var isTextArea = this.root_.classList.contains(constants_1.cssClasses.TEXTAREA);
        var isOutlined = this.root_.classList.contains(constants_1.cssClasses.OUTLINED);
        if (isTextArea || isOutlined) {
            return null;
        }
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = __assign(__assign({}, component_5.MDCRipple.createAdapter(this)), { isSurfaceActive: function isSurfaceActive() {
                return ponyfill.matches(_this.input_, ':active');
            }, registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                return _this.input_.addEventListener(evtType, handler, events_1.applyPassive());
            }, deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                return _this.input_.removeEventListener(evtType, handler, events_1.applyPassive());
            } });
        // tslint:enable:object-literal-sort-keys
        return rippleFactory(this.root_, new foundation_1.MDCRippleFoundation(adapter));
    };
    return MDCTextField;
}(component_1.MDCComponent);
exports.MDCTextField = MDCTextField;

/***/ }),

/***/ "./packages/mdc-textfield/constants.ts":
/*!*********************************************!*\
  !*** ./packages/mdc-textfield/constants.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var strings = {
    ARIA_CONTROLS: 'aria-controls',
    INPUT_SELECTOR: '.mdc-text-field__input',
    LABEL_SELECTOR: '.mdc-floating-label',
    LEADING_ICON_SELECTOR: '.mdc-text-field__icon--leading',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    PREFIX_SELECTOR: '.mdc-text-field__affix--prefix',
    SUFFIX_SELECTOR: '.mdc-text-field__affix--suffix',
    TRAILING_ICON_SELECTOR: '.mdc-text-field__icon--trailing'
};
exports.strings = strings;
var cssClasses = {
    DISABLED: 'mdc-text-field--disabled',
    FOCUSED: 'mdc-text-field--focused',
    FULLWIDTH: 'mdc-text-field--fullwidth',
    HELPER_LINE: 'mdc-text-field-helper-line',
    INVALID: 'mdc-text-field--invalid',
    LABEL_FLOATING: 'mdc-text-field--label-floating',
    NO_LABEL: 'mdc-text-field--no-label',
    OUTLINED: 'mdc-text-field--outlined',
    ROOT: 'mdc-text-field',
    TEXTAREA: 'mdc-text-field--textarea',
    WITH_LEADING_ICON: 'mdc-text-field--with-leading-icon',
    WITH_TRAILING_ICON: 'mdc-text-field--with-trailing-icon'
};
exports.cssClasses = cssClasses;
var numbers = {
    LABEL_SCALE: 0.75
};
exports.numbers = numbers;
/**
 * Whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
 * under the "Validation-related attributes" section.
 */
var VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength'];
exports.VALIDATION_ATTR_WHITELIST = VALIDATION_ATTR_WHITELIST;
/**
 * Label should always float for these types as they show some UI even if value is empty.
 */
var ALWAYS_FLOAT_TYPES = ['color', 'date', 'datetime-local', 'month', 'range', 'time', 'week'];
exports.ALWAYS_FLOAT_TYPES = ALWAYS_FLOAT_TYPES;

/***/ }),

/***/ "./packages/mdc-textfield/foundation.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-textfield/foundation.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-textfield/constants.ts");
var POINTERDOWN_EVENTS = ['mousedown', 'touchstart'];
var INTERACTION_EVENTS = ['click', 'keydown'];
var MDCTextFieldFoundation = /** @class */function (_super) {
    __extends(MDCTextFieldFoundation, _super);
    /**
     * @param adapter
     * @param foundationMap Map from subcomponent names to their subfoundations.
     */
    function MDCTextFieldFoundation(adapter, foundationMap) {
        if (foundationMap === void 0) {
            foundationMap = {};
        }
        var _this = _super.call(this, __assign(__assign({}, MDCTextFieldFoundation.defaultAdapter), adapter)) || this;
        _this.isFocused_ = false;
        _this.receivedUserInput_ = false;
        _this.isValid_ = true;
        _this.useNativeValidation_ = true;
        _this.helperText_ = foundationMap.helperText;
        _this.characterCounter_ = foundationMap.characterCounter;
        _this.leadingIcon_ = foundationMap.leadingIcon;
        _this.trailingIcon_ = foundationMap.trailingIcon;
        _this.inputFocusHandler_ = function () {
            return _this.activateFocus();
        };
        _this.inputBlurHandler_ = function () {
            return _this.deactivateFocus();
        };
        _this.inputInputHandler_ = function () {
            return _this.handleInput();
        };
        _this.setPointerXOffset_ = function (evt) {
            return _this.setTransformOrigin(evt);
        };
        _this.textFieldInteractionHandler_ = function () {
            return _this.handleTextFieldInteraction();
        };
        _this.validationAttributeChangeHandler_ = function (attributesList) {
            return _this.handleValidationAttributeChange(attributesList);
        };
        return _this;
    }
    Object.defineProperty(MDCTextFieldFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldAlwaysFloat_", {
        get: function get() {
            var type = this.getNativeInput_().type;
            return constants_1.ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldFloat", {
        get: function get() {
            return this.shouldAlwaysFloat_ || this.isFocused_ || !!this.getValue() || this.isBadInput_();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldShake", {
        get: function get() {
            return !this.isFocused_ && !this.isValid() && !!this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTextFieldAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return true;
                },
                registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {
                    return undefined;
                },
                deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {
                    return undefined;
                },
                registerInputInteractionHandler: function registerInputInteractionHandler() {
                    return undefined;
                },
                deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {
                    return undefined;
                },
                registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {
                    return new MutationObserver(function () {
                        return undefined;
                    });
                },
                deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {
                    return undefined;
                },
                getNativeInput: function getNativeInput() {
                    return null;
                },
                isFocused: function isFocused() {
                    return false;
                },
                activateLineRipple: function activateLineRipple() {
                    return undefined;
                },
                deactivateLineRipple: function deactivateLineRipple() {
                    return undefined;
                },
                setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {
                    return undefined;
                },
                shakeLabel: function shakeLabel() {
                    return undefined;
                },
                floatLabel: function floatLabel() {
                    return undefined;
                },
                hasLabel: function hasLabel() {
                    return false;
                },
                getLabelWidth: function getLabelWidth() {
                    return 0;
                },
                hasOutline: function hasOutline() {
                    return false;
                },
                notchOutline: function notchOutline() {
                    return undefined;
                },
                closeOutline: function closeOutline() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldFoundation.prototype.init = function () {
        var _this = this;
        if (this.adapter_.isFocused()) {
            this.inputFocusHandler_();
        } else if (this.adapter_.hasLabel() && this.shouldFloat) {
            this.notchOutline(true);
            this.adapter_.floatLabel(true);
            this.styleFloating_(true);
        }
        this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
        POINTERDOWN_EVENTS.forEach(function (evtType) {
            _this.adapter_.registerInputInteractionHandler(evtType, _this.setPointerXOffset_);
        });
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.adapter_.registerTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
        });
        this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
        this.setCharacterCounter_(this.getValue().length);
    };
    MDCTextFieldFoundation.prototype.destroy = function () {
        var _this = this;
        this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
        POINTERDOWN_EVENTS.forEach(function (evtType) {
            _this.adapter_.deregisterInputInteractionHandler(evtType, _this.setPointerXOffset_);
        });
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.adapter_.deregisterTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
        });
        this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
    };
    /**
     * Handles user interactions with the Text Field.
     */
    MDCTextFieldFoundation.prototype.handleTextFieldInteraction = function () {
        var nativeInput = this.adapter_.getNativeInput();
        if (nativeInput && nativeInput.disabled) {
            return;
        }
        this.receivedUserInput_ = true;
    };
    /**
     * Handles validation attribute changes
     */
    MDCTextFieldFoundation.prototype.handleValidationAttributeChange = function (attributesList) {
        var _this = this;
        attributesList.some(function (attributeName) {
            if (constants_1.VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
                _this.styleValidity_(true);
                return true;
            }
            return false;
        });
        if (attributesList.indexOf('maxlength') > -1) {
            this.setCharacterCounter_(this.getValue().length);
        }
    };
    /**
     * Opens/closes the notched outline.
     */
    MDCTextFieldFoundation.prototype.notchOutline = function (openNotch) {
        if (!this.adapter_.hasOutline()) {
            return;
        }
        if (openNotch) {
            var labelWidth = this.adapter_.getLabelWidth() * constants_1.numbers.LABEL_SCALE;
            this.adapter_.notchOutline(labelWidth);
        } else {
            this.adapter_.closeOutline();
        }
    };
    /**
     * Activates the text field focus state.
     */
    MDCTextFieldFoundation.prototype.activateFocus = function () {
        this.isFocused_ = true;
        this.styleFocused_(this.isFocused_);
        this.adapter_.activateLineRipple();
        if (this.adapter_.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter_.floatLabel(this.shouldFloat);
            this.styleFloating_(this.shouldFloat);
            this.adapter_.shakeLabel(this.shouldShake);
        }
        if (this.helperText_) {
            this.helperText_.showToScreenReader();
        }
    };
    /**
     * Sets the line ripple's transform origin, so that the line ripple activate
     * animation will animate out from the user's click location.
     */
    MDCTextFieldFoundation.prototype.setTransformOrigin = function (evt) {
        var touches = evt.touches;
        var targetEvent = touches ? touches[0] : evt;
        var targetClientRect = targetEvent.target.getBoundingClientRect();
        var normalizedX = targetEvent.clientX - targetClientRect.left;
        this.adapter_.setLineRippleTransformOrigin(normalizedX);
    };
    /**
     * Handles input change of text input and text area.
     */
    MDCTextFieldFoundation.prototype.handleInput = function () {
        this.autoCompleteFocus();
        this.setCharacterCounter_(this.getValue().length);
    };
    /**
     * Activates the Text Field's focus state in cases when the input value
     * changes without user input (e.g. programmatically).
     */
    MDCTextFieldFoundation.prototype.autoCompleteFocus = function () {
        if (!this.receivedUserInput_) {
            this.activateFocus();
        }
    };
    /**
     * Deactivates the Text Field's focus state.
     */
    MDCTextFieldFoundation.prototype.deactivateFocus = function () {
        this.isFocused_ = false;
        this.adapter_.deactivateLineRipple();
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        this.styleFocused_(this.isFocused_);
        if (this.adapter_.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter_.floatLabel(this.shouldFloat);
            this.styleFloating_(this.shouldFloat);
            this.adapter_.shakeLabel(this.shouldShake);
        }
        if (!this.shouldFloat) {
            this.receivedUserInput_ = false;
        }
    };
    MDCTextFieldFoundation.prototype.getValue = function () {
        return this.getNativeInput_().value;
    };
    /**
     * @param value The value to set on the input Element.
     */
    MDCTextFieldFoundation.prototype.setValue = function (value) {
        // Prevent Safari from moving the caret to the end of the input when the value has not changed.
        if (this.getValue() !== value) {
            this.getNativeInput_().value = value;
        }
        this.setCharacterCounter_(value.length);
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter_.floatLabel(this.shouldFloat);
            this.styleFloating_(this.shouldFloat);
            this.adapter_.shakeLabel(this.shouldShake);
        }
    };
    /**
     * @return The custom validity state, if set; otherwise, the result of a native validity check.
     */
    MDCTextFieldFoundation.prototype.isValid = function () {
        return this.useNativeValidation_ ? this.isNativeInputValid_() : this.isValid_;
    };
    /**
     * @param isValid Sets the custom validity state of the Text Field.
     */
    MDCTextFieldFoundation.prototype.setValid = function (isValid) {
        this.isValid_ = isValid;
        this.styleValidity_(isValid);
        var shouldShake = !isValid && !this.isFocused_ && !!this.getValue();
        if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(shouldShake);
        }
    };
    /**
     * Enables or disables the use of native validation. Use this for custom validation.
     * @param useNativeValidation Set this to false to ignore native input validation.
     */
    MDCTextFieldFoundation.prototype.setUseNativeValidation = function (useNativeValidation) {
        this.useNativeValidation_ = useNativeValidation;
    };
    MDCTextFieldFoundation.prototype.isDisabled = function () {
        return this.getNativeInput_().disabled;
    };
    /**
     * @param disabled Sets the text-field disabled or enabled.
     */
    MDCTextFieldFoundation.prototype.setDisabled = function (disabled) {
        this.getNativeInput_().disabled = disabled;
        this.styleDisabled_(disabled);
    };
    /**
     * @param content Sets the content of the helper text.
     */
    MDCTextFieldFoundation.prototype.setHelperTextContent = function (content) {
        if (this.helperText_) {
            this.helperText_.setContent(content);
        }
    };
    /**
     * Sets the aria label of the leading icon.
     */
    MDCTextFieldFoundation.prototype.setLeadingIconAriaLabel = function (label) {
        if (this.leadingIcon_) {
            this.leadingIcon_.setAriaLabel(label);
        }
    };
    /**
     * Sets the text content of the leading icon.
     */
    MDCTextFieldFoundation.prototype.setLeadingIconContent = function (content) {
        if (this.leadingIcon_) {
            this.leadingIcon_.setContent(content);
        }
    };
    /**
     * Sets the aria label of the trailing icon.
     */
    MDCTextFieldFoundation.prototype.setTrailingIconAriaLabel = function (label) {
        if (this.trailingIcon_) {
            this.trailingIcon_.setAriaLabel(label);
        }
    };
    /**
     * Sets the text content of the trailing icon.
     */
    MDCTextFieldFoundation.prototype.setTrailingIconContent = function (content) {
        if (this.trailingIcon_) {
            this.trailingIcon_.setContent(content);
        }
    };
    /**
     * Sets character counter values that shows characters used and the total character limit.
     */
    MDCTextFieldFoundation.prototype.setCharacterCounter_ = function (currentLength) {
        if (!this.characterCounter_) {
            return;
        }
        var maxLength = this.getNativeInput_().maxLength;
        if (maxLength === -1) {
            throw new Error('MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.');
        }
        this.characterCounter_.setCounterValue(currentLength, maxLength);
    };
    /**
     * @return True if the Text Field input fails in converting the user-supplied value.
     */
    MDCTextFieldFoundation.prototype.isBadInput_ = function () {
        // The badInput property is not supported in IE 11 .
        return this.getNativeInput_().validity.badInput || false;
    };
    /**
     * @return The result of native validity checking (ValidityState.valid).
     */
    MDCTextFieldFoundation.prototype.isNativeInputValid_ = function () {
        return this.getNativeInput_().validity.valid;
    };
    /**
     * Styles the component based on the validity state.
     */
    MDCTextFieldFoundation.prototype.styleValidity_ = function (isValid) {
        var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;
        if (isValid) {
            this.adapter_.removeClass(INVALID);
        } else {
            this.adapter_.addClass(INVALID);
        }
        if (this.helperText_) {
            this.helperText_.setValidity(isValid);
        }
    };
    /**
     * Styles the component based on the focused state.
     */
    MDCTextFieldFoundation.prototype.styleFocused_ = function (isFocused) {
        var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;
        if (isFocused) {
            this.adapter_.addClass(FOCUSED);
        } else {
            this.adapter_.removeClass(FOCUSED);
        }
    };
    /**
     * Styles the component based on the disabled state.
     */
    MDCTextFieldFoundation.prototype.styleDisabled_ = function (isDisabled) {
        var _a = MDCTextFieldFoundation.cssClasses,
            DISABLED = _a.DISABLED,
            INVALID = _a.INVALID;
        if (isDisabled) {
            this.adapter_.addClass(DISABLED);
            this.adapter_.removeClass(INVALID);
        } else {
            this.adapter_.removeClass(DISABLED);
        }
        if (this.leadingIcon_) {
            this.leadingIcon_.setDisabled(isDisabled);
        }
        if (this.trailingIcon_) {
            this.trailingIcon_.setDisabled(isDisabled);
        }
    };
    /**
     * Styles the component based on the label floating state.
     */
    MDCTextFieldFoundation.prototype.styleFloating_ = function (isFloating) {
        var LABEL_FLOATING = MDCTextFieldFoundation.cssClasses.LABEL_FLOATING;
        if (isFloating) {
            this.adapter_.addClass(LABEL_FLOATING);
        } else {
            this.adapter_.removeClass(LABEL_FLOATING);
        }
    };
    /**
     * @return The native text input element from the host environment, or an object with the same shape for unit tests.
     */
    MDCTextFieldFoundation.prototype.getNativeInput_ = function () {
        // this.adapter_ may be undefined in foundation unit tests. This happens when testdouble is creating a mock object
        // and invokes the shouldShake/shouldFloat getters (which in turn call getValue(), which calls this method) before
        // init() has been called from the MDCTextField constructor. To work around that issue, we return a dummy object.
        var nativeInput = this.adapter_ ? this.adapter_.getNativeInput() : null;
        return nativeInput || {
            disabled: false,
            maxLength: -1,
            type: 'input',
            validity: {
                badInput: false,
                valid: true
            },
            value: ''
        };
    };
    return MDCTextFieldFoundation;
}(foundation_1.MDCFoundation);
exports.MDCTextFieldFoundation = MDCTextFieldFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTextFieldFoundation;

/***/ }),

/***/ "./packages/mdc-textfield/helper-text/component.ts":
/*!*********************************************************!*\
  !*** ./packages/mdc-textfield/helper-text/component.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-textfield/helper-text/foundation.ts");
var MDCTextFieldHelperText = /** @class */function (_super) {
    __extends(MDCTextFieldHelperText, _super);
    function MDCTextFieldHelperText() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTextFieldHelperText.attachTo = function (root) {
        return new MDCTextFieldHelperText(root);
    };
    Object.defineProperty(MDCTextFieldHelperText.prototype, "foundation", {
        get: function get() {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldHelperText.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            setAttr: function setAttr(attr, value) {
                return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
                return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
                _this.root_.textContent = content;
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_1.MDCTextFieldHelperTextFoundation(adapter);
    };
    return MDCTextFieldHelperText;
}(component_1.MDCComponent);
exports.MDCTextFieldHelperText = MDCTextFieldHelperText;

/***/ }),

/***/ "./packages/mdc-textfield/helper-text/constants.ts":
/*!*********************************************************!*\
  !*** ./packages/mdc-textfield/helper-text/constants.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg',
    ROOT: 'mdc-text-field-helper-text'
};
exports.cssClasses = cssClasses;
var strings = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role',
    ROOT_SELECTOR: "." + cssClasses.ROOT
};
exports.strings = strings;

/***/ }),

/***/ "./packages/mdc-textfield/helper-text/foundation.ts":
/*!**********************************************************!*\
  !*** ./packages/mdc-textfield/helper-text/foundation.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-textfield/helper-text/constants.ts");
var MDCTextFieldHelperTextFoundation = /** @class */function (_super) {
    __extends(MDCTextFieldHelperTextFoundation, _super);
    function MDCTextFieldHelperTextFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCTextFieldHelperTextFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCTextFieldHelperTextFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldHelperTextFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldHelperTextFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTextFieldHelperTextAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return false;
                },
                setAttr: function setAttr() {
                    return undefined;
                },
                removeAttr: function removeAttr() {
                    return undefined;
                },
                setContent: function setContent() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the content of the helper text field.
     */
    MDCTextFieldHelperTextFoundation.prototype.setContent = function (content) {
        this.adapter_.setContent(content);
    };
    /**
     * @param isPersistent Sets the persistency of the helper text.
     */
    MDCTextFieldHelperTextFoundation.prototype.setPersistent = function (isPersistent) {
        if (isPersistent) {
            this.adapter_.addClass(constants_1.cssClasses.HELPER_TEXT_PERSISTENT);
        } else {
            this.adapter_.removeClass(constants_1.cssClasses.HELPER_TEXT_PERSISTENT);
        }
    };
    /**
     * @param isValidation True to make the helper text act as an error validation message.
     */
    MDCTextFieldHelperTextFoundation.prototype.setValidation = function (isValidation) {
        if (isValidation) {
            this.adapter_.addClass(constants_1.cssClasses.HELPER_TEXT_VALIDATION_MSG);
        } else {
            this.adapter_.removeClass(constants_1.cssClasses.HELPER_TEXT_VALIDATION_MSG);
        }
    };
    /**
     * Makes the helper text visible to the screen reader.
     */
    MDCTextFieldHelperTextFoundation.prototype.showToScreenReader = function () {
        this.adapter_.removeAttr(constants_1.strings.ARIA_HIDDEN);
    };
    /**
     * Sets the validity of the helper text based on the input validity.
     */
    MDCTextFieldHelperTextFoundation.prototype.setValidity = function (inputIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(constants_1.cssClasses.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(constants_1.cssClasses.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;
        if (validationMsgNeedsDisplay) {
            this.adapter_.setAttr(constants_1.strings.ROLE, 'alert');
        } else {
            this.adapter_.removeAttr(constants_1.strings.ROLE);
        }
        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
            this.hide_();
        }
    };
    /**
     * Hides the help text from screen readers.
     */
    MDCTextFieldHelperTextFoundation.prototype.hide_ = function () {
        this.adapter_.setAttr(constants_1.strings.ARIA_HIDDEN, 'true');
    };
    return MDCTextFieldHelperTextFoundation;
}(foundation_1.MDCFoundation);
exports.MDCTextFieldHelperTextFoundation = MDCTextFieldHelperTextFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTextFieldHelperTextFoundation;

/***/ }),

/***/ "./packages/mdc-textfield/helper-text/index.ts":
/*!*****************************************************!*\
  !*** ./packages/mdc-textfield/helper-text/index.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-textfield/helper-text/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-textfield/helper-text/foundation.ts"));
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-textfield/helper-text/constants.ts");
exports.helperTextCssClasses = constants_1.cssClasses;
exports.helperTextStrings = constants_1.strings;

/***/ }),

/***/ "./packages/mdc-textfield/icon/component.ts":
/*!**************************************************!*\
  !*** ./packages/mdc-textfield/icon/component.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var foundation_1 = __webpack_require__(/*! ./foundation */ "./packages/mdc-textfield/icon/foundation.ts");
var MDCTextFieldIcon = /** @class */function (_super) {
    __extends(MDCTextFieldIcon, _super);
    function MDCTextFieldIcon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTextFieldIcon.attachTo = function (root) {
        return new MDCTextFieldIcon(root);
    };
    Object.defineProperty(MDCTextFieldIcon.prototype, "foundation", {
        get: function get() {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldIcon.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            getAttr: function getAttr(attr) {
                return _this.root_.getAttribute(attr);
            },
            setAttr: function setAttr(attr, value) {
                return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
                return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
                _this.root_.textContent = content;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
                return _this.listen(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
                return _this.unlisten(evtType, handler);
            },
            notifyIconAction: function notifyIconAction() {
                return _this.emit(foundation_1.MDCTextFieldIconFoundation.strings.ICON_EVENT, {} /* evtData */, true /* shouldBubble */);
            }
        };
        // tslint:enable:object-literal-sort-keys
        return new foundation_1.MDCTextFieldIconFoundation(adapter);
    };
    return MDCTextFieldIcon;
}(component_1.MDCComponent);
exports.MDCTextFieldIcon = MDCTextFieldIcon;

/***/ }),

/***/ "./packages/mdc-textfield/icon/constants.ts":
/*!**************************************************!*\
  !*** ./packages/mdc-textfield/icon/constants.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var strings = {
    ICON_EVENT: 'MDCTextField:icon',
    ICON_ROLE: 'button'
};
exports.strings = strings;
var cssClasses = {
    ROOT: 'mdc-text-field__icon'
};
exports.cssClasses = cssClasses;

/***/ }),

/***/ "./packages/mdc-textfield/icon/foundation.ts":
/*!***************************************************!*\
  !*** ./packages/mdc-textfield/icon/foundation.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-textfield/icon/constants.ts");
var INTERACTION_EVENTS = ['click', 'keydown'];
var MDCTextFieldIconFoundation = /** @class */function (_super) {
    __extends(MDCTextFieldIconFoundation, _super);
    function MDCTextFieldIconFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCTextFieldIconFoundation.defaultAdapter), adapter)) || this;
        _this.savedTabIndex_ = null;
        _this.interactionHandler_ = function (evt) {
            return _this.handleInteraction(evt);
        };
        return _this;
    }
    Object.defineProperty(MDCTextFieldIconFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldIconFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldIconFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTextFieldIconAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                getAttr: function getAttr() {
                    return null;
                },
                setAttr: function setAttr() {
                    return undefined;
                },
                removeAttr: function removeAttr() {
                    return undefined;
                },
                setContent: function setContent() {
                    return undefined;
                },
                registerInteractionHandler: function registerInteractionHandler() {
                    return undefined;
                },
                deregisterInteractionHandler: function deregisterInteractionHandler() {
                    return undefined;
                },
                notifyIconAction: function notifyIconAction() {
                    return undefined;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldIconFoundation.prototype.init = function () {
        var _this = this;
        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.adapter_.registerInteractionHandler(evtType, _this.interactionHandler_);
        });
    };
    MDCTextFieldIconFoundation.prototype.destroy = function () {
        var _this = this;
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.adapter_.deregisterInteractionHandler(evtType, _this.interactionHandler_);
        });
    };
    MDCTextFieldIconFoundation.prototype.setDisabled = function (disabled) {
        if (!this.savedTabIndex_) {
            return;
        }
        if (disabled) {
            this.adapter_.setAttr('tabindex', '-1');
            this.adapter_.removeAttr('role');
        } else {
            this.adapter_.setAttr('tabindex', this.savedTabIndex_);
            this.adapter_.setAttr('role', constants_1.strings.ICON_ROLE);
        }
    };
    MDCTextFieldIconFoundation.prototype.setAriaLabel = function (label) {
        this.adapter_.setAttr('aria-label', label);
    };
    MDCTextFieldIconFoundation.prototype.setContent = function (content) {
        this.adapter_.setContent(content);
    };
    MDCTextFieldIconFoundation.prototype.handleInteraction = function (evt) {
        var isEnterKey = evt.key === 'Enter' || evt.keyCode === 13;
        if (evt.type === 'click' || isEnterKey) {
            evt.preventDefault(); // stop click from causing host label to focus
            // input
            this.adapter_.notifyIconAction();
        }
    };
    return MDCTextFieldIconFoundation;
}(foundation_1.MDCFoundation);
exports.MDCTextFieldIconFoundation = MDCTextFieldIconFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTextFieldIconFoundation;

/***/ }),

/***/ "./packages/mdc-textfield/icon/index.ts":
/*!**********************************************!*\
  !*** ./packages/mdc-textfield/icon/index.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-textfield/icon/component.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-textfield/icon/foundation.ts"));
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-textfield/icon/constants.ts");
exports.iconCssClasses = constants_1.cssClasses;
exports.iconStrings = constants_1.strings;

/***/ }),

/***/ "./packages/mdc-textfield/index.ts":
/*!*****************************************!*\
  !*** ./packages/mdc-textfield/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-textfield/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-textfield/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-textfield/foundation.ts"));
__export(__webpack_require__(/*! ./character-counter/index */ "./packages/mdc-textfield/character-counter/index.ts"));
__export(__webpack_require__(/*! ./helper-text/index */ "./packages/mdc-textfield/helper-text/index.ts"));
__export(__webpack_require__(/*! ./icon/index */ "./packages/mdc-textfield/icon/index.ts"));

/***/ }),

/***/ "./packages/mdc-top-app-bar/component.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-top-app-bar/component.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(/*! @material/base/component */ "./packages/mdc-base/component.ts");
var component_2 = __webpack_require__(/*! @material/ripple/component */ "./packages/mdc-ripple/component.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-top-app-bar/constants.ts");
var foundation_1 = __webpack_require__(/*! ./fixed/foundation */ "./packages/mdc-top-app-bar/fixed/foundation.ts");
var foundation_2 = __webpack_require__(/*! ./short/foundation */ "./packages/mdc-top-app-bar/short/foundation.ts");
var foundation_3 = __webpack_require__(/*! ./standard/foundation */ "./packages/mdc-top-app-bar/standard/foundation.ts");
var MDCTopAppBar = /** @class */function (_super) {
    __extends(MDCTopAppBar, _super);
    function MDCTopAppBar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTopAppBar.attachTo = function (root) {
        return new MDCTopAppBar(root);
    };
    MDCTopAppBar.prototype.initialize = function (rippleFactory) {
        if (rippleFactory === void 0) {
            rippleFactory = function rippleFactory(el) {
                return component_2.MDCRipple.attachTo(el);
            };
        }
        this.navIcon_ = this.root_.querySelector(constants_1.strings.NAVIGATION_ICON_SELECTOR);
        // Get all icons in the toolbar and instantiate the ripples
        var icons = [].slice.call(this.root_.querySelectorAll(constants_1.strings.ACTION_ITEM_SELECTOR));
        if (this.navIcon_) {
            icons.push(this.navIcon_);
        }
        this.iconRipples_ = icons.map(function (icon) {
            var ripple = rippleFactory(icon);
            ripple.unbounded = true;
            return ripple;
        });
        this.scrollTarget_ = window;
    };
    MDCTopAppBar.prototype.initialSyncWithDOM = function () {
        this.handleNavigationClick_ = this.foundation_.handleNavigationClick.bind(this.foundation_);
        this.handleWindowResize_ = this.foundation_.handleWindowResize.bind(this.foundation_);
        this.handleTargetScroll_ = this.foundation_.handleTargetScroll.bind(this.foundation_);
        this.scrollTarget_.addEventListener('scroll', this.handleTargetScroll_);
        if (this.navIcon_) {
            this.navIcon_.addEventListener('click', this.handleNavigationClick_);
        }
        var isFixed = this.root_.classList.contains(constants_1.cssClasses.FIXED_CLASS);
        var isShort = this.root_.classList.contains(constants_1.cssClasses.SHORT_CLASS);
        if (!isShort && !isFixed) {
            window.addEventListener('resize', this.handleWindowResize_);
        }
    };
    MDCTopAppBar.prototype.destroy = function () {
        this.iconRipples_.forEach(function (iconRipple) {
            return iconRipple.destroy();
        });
        this.scrollTarget_.removeEventListener('scroll', this.handleTargetScroll_);
        if (this.navIcon_) {
            this.navIcon_.removeEventListener('click', this.handleNavigationClick_);
        }
        var isFixed = this.root_.classList.contains(constants_1.cssClasses.FIXED_CLASS);
        var isShort = this.root_.classList.contains(constants_1.cssClasses.SHORT_CLASS);
        if (!isShort && !isFixed) {
            window.removeEventListener('resize', this.handleWindowResize_);
        }
        _super.prototype.destroy.call(this);
    };
    MDCTopAppBar.prototype.setScrollTarget = function (target) {
        // Remove scroll handler from the previous scroll target
        this.scrollTarget_.removeEventListener('scroll', this.handleTargetScroll_);
        this.scrollTarget_ = target;
        // Initialize scroll handler on the new scroll target
        this.handleTargetScroll_ = this.foundation_.handleTargetScroll.bind(this.foundation_);
        this.scrollTarget_.addEventListener('scroll', this.handleTargetScroll_);
    };
    MDCTopAppBar.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            hasClass: function hasClass(className) {
                return _this.root_.classList.contains(className);
            },
            addClass: function addClass(className) {
                return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
                return _this.root_.classList.remove(className);
            },
            setStyle: function setStyle(property, value) {
                return _this.root_.style.setProperty(property, value);
            },
            getTopAppBarHeight: function getTopAppBarHeight() {
                return _this.root_.clientHeight;
            },
            notifyNavigationIconClicked: function notifyNavigationIconClicked() {
                return _this.emit(constants_1.strings.NAVIGATION_EVENT, {});
            },
            getViewportScrollY: function getViewportScrollY() {
                var win = _this.scrollTarget_;
                var el = _this.scrollTarget_;
                return win.pageYOffset !== undefined ? win.pageYOffset : el.scrollTop;
            },
            getTotalActionItems: function getTotalActionItems() {
                return _this.root_.querySelectorAll(constants_1.strings.ACTION_ITEM_SELECTOR).length;
            }
        };
        // tslint:enable:object-literal-sort-keys
        var foundation;
        if (this.root_.classList.contains(constants_1.cssClasses.SHORT_CLASS)) {
            foundation = new foundation_2.MDCShortTopAppBarFoundation(adapter);
        } else if (this.root_.classList.contains(constants_1.cssClasses.FIXED_CLASS)) {
            foundation = new foundation_1.MDCFixedTopAppBarFoundation(adapter);
        } else {
            foundation = new foundation_3.MDCTopAppBarFoundation(adapter);
        }
        return foundation;
    };
    return MDCTopAppBar;
}(component_1.MDCComponent);
exports.MDCTopAppBar = MDCTopAppBar;

/***/ }),

/***/ "./packages/mdc-top-app-bar/constants.ts":
/*!***********************************************!*\
  !*** ./packages/mdc-top-app-bar/constants.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Object.defineProperty(exports, "__esModule", { value: true });
var cssClasses = {
    FIXED_CLASS: 'mdc-top-app-bar--fixed',
    FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
    SHORT_CLASS: 'mdc-top-app-bar--short',
    SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed',
    SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item'
};
exports.cssClasses = cssClasses;
var numbers = {
    DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
    MAX_TOP_APP_BAR_HEIGHT: 128
};
exports.numbers = numbers;
var strings = {
    ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
    NAVIGATION_EVENT: 'MDCTopAppBar:nav',
    NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
    ROOT_SELECTOR: '.mdc-top-app-bar',
    TITLE_SELECTOR: '.mdc-top-app-bar__title'
};
exports.strings = strings;

/***/ }),

/***/ "./packages/mdc-top-app-bar/fixed/foundation.ts":
/*!******************************************************!*\
  !*** ./packages/mdc-top-app-bar/fixed/foundation.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(/*! ../constants */ "./packages/mdc-top-app-bar/constants.ts");
var foundation_1 = __webpack_require__(/*! ../standard/foundation */ "./packages/mdc-top-app-bar/standard/foundation.ts");
var MDCFixedTopAppBarFoundation = /** @class */function (_super) {
    __extends(MDCFixedTopAppBarFoundation, _super);
    function MDCFixedTopAppBarFoundation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * State variable for the previous scroll iteration top app bar state
         */
        _this.wasScrolled_ = false;
        return _this;
    }
    /**
     * Scroll handler for applying/removing the modifier class on the fixed top app bar.
     * @override
     */
    MDCFixedTopAppBarFoundation.prototype.handleTargetScroll = function () {
        var currentScroll = this.adapter_.getViewportScrollY();
        if (currentScroll <= 0) {
            if (this.wasScrolled_) {
                this.adapter_.removeClass(constants_1.cssClasses.FIXED_SCROLLED_CLASS);
                this.wasScrolled_ = false;
            }
        } else {
            if (!this.wasScrolled_) {
                this.adapter_.addClass(constants_1.cssClasses.FIXED_SCROLLED_CLASS);
                this.wasScrolled_ = true;
            }
        }
    };
    return MDCFixedTopAppBarFoundation;
}(foundation_1.MDCTopAppBarFoundation);
exports.MDCFixedTopAppBarFoundation = MDCFixedTopAppBarFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCFixedTopAppBarFoundation;

/***/ }),

/***/ "./packages/mdc-top-app-bar/foundation.ts":
/*!************************************************!*\
  !*** ./packages/mdc-top-app-bar/foundation.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var foundation_1 = __webpack_require__(/*! @material/base/foundation */ "./packages/mdc-base/foundation.ts");
var constants_1 = __webpack_require__(/*! ./constants */ "./packages/mdc-top-app-bar/constants.ts");
var MDCTopAppBarBaseFoundation = /** @class */function (_super) {
    __extends(MDCTopAppBarBaseFoundation, _super);
    /* istanbul ignore next: optional argument is not a branch statement */
    function MDCTopAppBarBaseFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCTopAppBarBaseFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCTopAppBarBaseFoundation, "strings", {
        get: function get() {
            return constants_1.strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTopAppBarBaseFoundation, "cssClasses", {
        get: function get() {
            return constants_1.cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTopAppBarBaseFoundation, "numbers", {
        get: function get() {
            return constants_1.numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTopAppBarBaseFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTopAppBarAdapter} for typing information on parameters and return types.
         */
        get: function get() {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function addClass() {
                    return undefined;
                },
                removeClass: function removeClass() {
                    return undefined;
                },
                hasClass: function hasClass() {
                    return false;
                },
                setStyle: function setStyle() {
                    return undefined;
                },
                getTopAppBarHeight: function getTopAppBarHeight() {
                    return 0;
                },
                notifyNavigationIconClicked: function notifyNavigationIconClicked() {
                    return undefined;
                },
                getViewportScrollY: function getViewportScrollY() {
                    return 0;
                },
                getTotalActionItems: function getTotalActionItems() {
                    return 0;
                }
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /** Other variants of TopAppBar foundation overrides this method */
    MDCTopAppBarBaseFoundation.prototype.handleTargetScroll = function () {}; // tslint:disable-line:no-empty
    /** Other variants of TopAppBar foundation overrides this method */
    MDCTopAppBarBaseFoundation.prototype.handleWindowResize = function () {}; // tslint:disable-line:no-empty
    MDCTopAppBarBaseFoundation.prototype.handleNavigationClick = function () {
        this.adapter_.notifyNavigationIconClicked();
    };
    return MDCTopAppBarBaseFoundation;
}(foundation_1.MDCFoundation);
exports.MDCTopAppBarBaseFoundation = MDCTopAppBarBaseFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTopAppBarBaseFoundation;

/***/ }),

/***/ "./packages/mdc-top-app-bar/index.ts":
/*!*******************************************!*\
  !*** ./packages/mdc-top-app-bar/index.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./packages/mdc-top-app-bar/component.ts"));
__export(__webpack_require__(/*! ./constants */ "./packages/mdc-top-app-bar/constants.ts"));
__export(__webpack_require__(/*! ./foundation */ "./packages/mdc-top-app-bar/foundation.ts"));
__export(__webpack_require__(/*! ./fixed/foundation */ "./packages/mdc-top-app-bar/fixed/foundation.ts"));
__export(__webpack_require__(/*! ./short/foundation */ "./packages/mdc-top-app-bar/short/foundation.ts"));
__export(__webpack_require__(/*! ./standard/foundation */ "./packages/mdc-top-app-bar/standard/foundation.ts"));

/***/ }),

/***/ "./packages/mdc-top-app-bar/short/foundation.ts":
/*!******************************************************!*\
  !*** ./packages/mdc-top-app-bar/short/foundation.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(/*! ../constants */ "./packages/mdc-top-app-bar/constants.ts");
var foundation_1 = __webpack_require__(/*! ../foundation */ "./packages/mdc-top-app-bar/foundation.ts");
var MDCShortTopAppBarFoundation = /** @class */function (_super) {
    __extends(MDCShortTopAppBarFoundation, _super);
    /* istanbul ignore next: optional argument is not a branch statement */
    function MDCShortTopAppBarFoundation(adapter) {
        var _this = _super.call(this, adapter) || this;
        _this.isCollapsed_ = false;
        _this.isAlwaysCollapsed_ = false;
        return _this;
    }
    Object.defineProperty(MDCShortTopAppBarFoundation.prototype, "isCollapsed", {
        // Public visibility for backward compatibility.
        get: function get() {
            return this.isCollapsed_;
        },
        enumerable: true,
        configurable: true
    });
    MDCShortTopAppBarFoundation.prototype.init = function () {
        _super.prototype.init.call(this);
        if (this.adapter_.getTotalActionItems() > 0) {
            this.adapter_.addClass(constants_1.cssClasses.SHORT_HAS_ACTION_ITEM_CLASS);
        }
        // If initialized with SHORT_COLLAPSED_CLASS, the bar should always be collapsed
        this.setAlwaysCollapsed(this.adapter_.hasClass(constants_1.cssClasses.SHORT_COLLAPSED_CLASS));
    };
    /**
     * Set if the short top app bar should always be collapsed.
     *
     * @param value When `true`, bar will always be collapsed. When `false`, bar may collapse or expand based on scroll.
     */
    MDCShortTopAppBarFoundation.prototype.setAlwaysCollapsed = function (value) {
        this.isAlwaysCollapsed_ = !!value;
        if (this.isAlwaysCollapsed_) {
            this.collapse_();
        } else {
            // let maybeCollapseBar_ determine if the bar should be collapsed
            this.maybeCollapseBar_();
        }
    };
    MDCShortTopAppBarFoundation.prototype.getAlwaysCollapsed = function () {
        return this.isAlwaysCollapsed_;
    };
    /**
     * Scroll handler for applying/removing the collapsed modifier class on the short top app bar.
     * @override
     */
    MDCShortTopAppBarFoundation.prototype.handleTargetScroll = function () {
        this.maybeCollapseBar_();
    };
    MDCShortTopAppBarFoundation.prototype.maybeCollapseBar_ = function () {
        if (this.isAlwaysCollapsed_) {
            return;
        }
        var currentScroll = this.adapter_.getViewportScrollY();
        if (currentScroll <= 0) {
            if (this.isCollapsed_) {
                this.uncollapse_();
            }
        } else {
            if (!this.isCollapsed_) {
                this.collapse_();
            }
        }
    };
    MDCShortTopAppBarFoundation.prototype.uncollapse_ = function () {
        this.adapter_.removeClass(constants_1.cssClasses.SHORT_COLLAPSED_CLASS);
        this.isCollapsed_ = false;
    };
    MDCShortTopAppBarFoundation.prototype.collapse_ = function () {
        this.adapter_.addClass(constants_1.cssClasses.SHORT_COLLAPSED_CLASS);
        this.isCollapsed_ = true;
    };
    return MDCShortTopAppBarFoundation;
}(foundation_1.MDCTopAppBarBaseFoundation);
exports.MDCShortTopAppBarFoundation = MDCShortTopAppBarFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCShortTopAppBarFoundation;

/***/ }),

/***/ "./packages/mdc-top-app-bar/standard/foundation.ts":
/*!*********************************************************!*\
  !*** ./packages/mdc-top-app-bar/standard/foundation.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(/*! ../constants */ "./packages/mdc-top-app-bar/constants.ts");
var foundation_1 = __webpack_require__(/*! ../foundation */ "./packages/mdc-top-app-bar/foundation.ts");
var INITIAL_VALUE = 0;
var MDCTopAppBarFoundation = /** @class */function (_super) {
    __extends(MDCTopAppBarFoundation, _super);
    /* istanbul ignore next: optional argument is not a branch statement */
    function MDCTopAppBarFoundation(adapter) {
        var _this = _super.call(this, adapter) || this;
        /**
         * Indicates if the top app bar was docked in the previous scroll handler iteration.
         */
        _this.wasDocked_ = true;
        /**
         * Indicates if the top app bar is docked in the fully shown position.
         */
        _this.isDockedShowing_ = true;
        /**
         * Variable for current scroll position of the top app bar
         */
        _this.currentAppBarOffsetTop_ = 0;
        /**
         * Used to prevent the top app bar from being scrolled out of view during resize events
         */
        _this.isCurrentlyBeingResized_ = false;
        /**
         * The timeout that's used to throttle the resize events
         */
        _this.resizeThrottleId_ = INITIAL_VALUE;
        /**
         * The timeout that's used to debounce toggling the isCurrentlyBeingResized_ variable after a resize
         */
        _this.resizeDebounceId_ = INITIAL_VALUE;
        _this.lastScrollPosition_ = _this.adapter_.getViewportScrollY();
        _this.topAppBarHeight_ = _this.adapter_.getTopAppBarHeight();
        return _this;
    }
    MDCTopAppBarFoundation.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.adapter_.setStyle('top', '');
    };
    /**
     * Scroll handler for the default scroll behavior of the top app bar.
     * @override
     */
    MDCTopAppBarFoundation.prototype.handleTargetScroll = function () {
        var currentScrollPosition = Math.max(this.adapter_.getViewportScrollY(), 0);
        var diff = currentScrollPosition - this.lastScrollPosition_;
        this.lastScrollPosition_ = currentScrollPosition;
        // If the window is being resized the lastScrollPosition_ needs to be updated but the
        // current scroll of the top app bar should stay in the same position.
        if (!this.isCurrentlyBeingResized_) {
            this.currentAppBarOffsetTop_ -= diff;
            if (this.currentAppBarOffsetTop_ > 0) {
                this.currentAppBarOffsetTop_ = 0;
            } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
                this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
            }
            this.moveTopAppBar_();
        }
    };
    /**
     * Top app bar resize handler that throttle/debounce functions that execute updates.
     * @override
     */
    MDCTopAppBarFoundation.prototype.handleWindowResize = function () {
        var _this = this;
        // Throttle resize events 10 p/s
        if (!this.resizeThrottleId_) {
            this.resizeThrottleId_ = setTimeout(function () {
                _this.resizeThrottleId_ = INITIAL_VALUE;
                _this.throttledResizeHandler_();
            }, constants_1.numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
        }
        this.isCurrentlyBeingResized_ = true;
        if (this.resizeDebounceId_) {
            clearTimeout(this.resizeDebounceId_);
        }
        this.resizeDebounceId_ = setTimeout(function () {
            _this.handleTargetScroll();
            _this.isCurrentlyBeingResized_ = false;
            _this.resizeDebounceId_ = INITIAL_VALUE;
        }, constants_1.numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
    };
    /**
     * Function to determine if the DOM needs to update.
     */
    MDCTopAppBarFoundation.prototype.checkForUpdate_ = function () {
        var offscreenBoundaryTop = -this.topAppBarHeight_;
        var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
        var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
        var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen;
        // If it's partially showing, it can't be docked.
        if (partiallyShowing) {
            this.wasDocked_ = false;
        } else {
            // Not previously docked and not partially showing, it's now docked.
            if (!this.wasDocked_) {
                this.wasDocked_ = true;
                return true;
            } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
                this.isDockedShowing_ = hasAnyPixelsOnscreen;
                return true;
            }
        }
        return partiallyShowing;
    };
    /**
     * Function to move the top app bar if needed.
     */
    MDCTopAppBarFoundation.prototype.moveTopAppBar_ = function () {
        if (this.checkForUpdate_()) {
            // Once the top app bar is fully hidden we use the max potential top app bar height as our offset
            // so the top app bar doesn't show if the window resizes and the new height > the old height.
            var offset = this.currentAppBarOffsetTop_;
            if (Math.abs(offset) >= this.topAppBarHeight_) {
                offset = -constants_1.numbers.MAX_TOP_APP_BAR_HEIGHT;
            }
            this.adapter_.setStyle('top', offset + 'px');
        }
    };
    /**
     * Throttled function that updates the top app bar scrolled values if the
     * top app bar height changes.
     */
    MDCTopAppBarFoundation.prototype.throttledResizeHandler_ = function () {
        var currentHeight = this.adapter_.getTopAppBarHeight();
        if (this.topAppBarHeight_ !== currentHeight) {
            this.wasDocked_ = false;
            // Since the top app bar has a different height depending on the screen width, this
            // will ensure that the top app bar remains in the correct location if
            // completely hidden and a resize makes the top app bar a different height.
            this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
            this.topAppBarHeight_ = currentHeight;
        }
        this.handleTargetScroll();
    };
    return MDCTopAppBarFoundation;
}(foundation_1.MDCTopAppBarBaseFoundation);
exports.MDCTopAppBarFoundation = MDCTopAppBarFoundation;
// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
exports.default = MDCTopAppBarFoundation;

/***/ })

/******/ });
});
//# sourceMappingURL=material-components-web.js.map
/*! jQuery v3.5.0 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.5.0",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",B=new RegExp(M+"+","g"),$=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace($,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||v.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||v.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||v.push(".#.+[+~]"),e.querySelectorAll("\\\f"),v.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(B," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace($,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split("").sort(D).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function D(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(D(this,e||[],!1))},not:function(e){return this.pushStack(D(this,e||[],!0))},is:function(e){return!!D(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var j,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||j,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,j=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t=Object.create(null),V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",y.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^key/,we=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Te=/^([^.]*)(?:\.(.+)|)/;function Ce(){return!0}function Ee(){return!1}function Se(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function ke(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)ke(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Ee;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Ae(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,Ce)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=Te.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click",Ce),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ce:Ee,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Ee,isPropagationStopped:Ee,isImmediatePropagationStopped:Ee,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ce,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ce,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ce,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&be.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&we.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(e,t){S.event.special[e]={setup:function(){return Ae(this,e,Se),!1},trigger:function(){return Ae(this,e),!0},delegateType:t}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return ke(this,e,t,n,r)},one:function(e,t,n,r){return ke(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Ee),this.each(function(){S.event.remove(this,e,n,t)})}});var Ne=/<script|<style|<link/i,De=/checked\s*(?:[^=]|=\s*.checked.)/i,je=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function qe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function Le(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function He(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Oe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function Pe(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&De.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Pe(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,"script"),Le)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,He),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(je,""),u,l))}return n}function Re(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Oe(o[r],a[r]);else Oe(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Re(this,e,!0)},remove:function(e){return Re(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Pe(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qe(this,e).appendChild(e)})},prepend:function(){return Pe(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=qe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ne.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Pe(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Me=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Ie=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},We=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Fe=new RegExp(ne.join("|"),"i");function Be(e,t,n){var r,i,o,a,s=e.style;return(n=n||Ie(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Me.test(a)&&Fe.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function $e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px",t.style.height="1px",n.style.height="9px",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=3<parseInt(r.height),re.removeChild(e)),a}}))}();var _e=["Webkit","Moz","ms"],ze=E.createElement("div").style,Ue={};function Xe(e){var t=S.cssProps[e]||Ue[e];return t||(e in ze?e:Ue[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=_e.length;while(n--)if((e=_e[n]+t)in ze)return e}(e)||e)}var Ve=/^(none|table(?!-c[ea]).+)/,Ge=/^--/,Ye={position:"absolute",visibility:"hidden",display:"block"},Qe={letterSpacing:"0",fontWeight:"400"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Ke(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Ie(e),i=(!y.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=Be(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Me.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?"border":"content"),o,r,a)+"px"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Ge.test(t),l=e.style;if(u||(t=Xe(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Ge.test(t)||(t=Xe(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),"normal"===i&&t in Qe&&(i=Qe[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ve.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):We(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Ie(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=$e(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,"marginLeft"))||e.getBoundingClientRect().left-We(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Ie(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Xe(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=/^(?:toggle|show|hide)$/,at=/queueHooks$/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Y.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ct(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt("show"),slideUp:lt("hide"),slideToggle:lt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement("input"),it=E.createElement("select").appendChild(E.createElement("option")),rt.type="checkbox",y.checkOn=""!==rt.value,y.optSelected=it.selected,(rt=E.createElement("input")).value="t",rt.type="radio",y.radioValue="t"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=/^(?:input|select|textarea|button)$/i,gt=/^(?:a|area)$/i;function vt(e){return(e.match(P)||[]).join(" ")}function yt(e){return e.getAttribute&&e.getAttribute("class")||""}function mt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,yt(this)))});if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,yt(this)))});if(!arguments.length)return this.attr("class","");if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,yt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=mt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=yt(this))&&Y.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Y.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+vt(yt(n))+" ").indexOf(t))return!0;return!1}});var xt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(xt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:vt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var bt=/^(?:focusinfocus|focusoutblur)$/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=/\?/;S.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||S.error("Invalid XML: "+e),t};var St=/\[\]$/,kt=/\r?\n/g,At=/^(?:submit|button|image|reset|file)$/i,Nt=/^(?:input|select|textarea|keygen)/i;function Dt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):Dt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)Dt(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)Dt(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}});var jt=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=E.createElement("a");function Ft(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Bt(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function $t(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?$t($t(e,S.ajaxSettings),t):$t(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Tt.href)+"").replace(Pt,Tt.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(P)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Wt.protocol+"//"+Wt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Bt(Rt,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Ot.test(v.type),f=v.url.replace(qt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(jt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(Et.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Lt,"$1"),o=(Et.test(f)?"&":"?")+"_="+Ct.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+It+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Bt(Mt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray("script",v.dataTypes)&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();y.cors=!!zt&&"withCredentials"in zt,y.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(y.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Xt.pop()||S.expando+"_"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Vt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,"$1"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Ut=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=vt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):("number"==typeof f.top&&(f.top+="px"),"number"==typeof f.left&&(f.left+="px"),c.css(f))}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=$e(y.pixelPosition,function(e,t){if(t)return t=Be(e,n),Me.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Gt,"")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});

/* axios v0.19.2 | (c) 2020 by Matt Zabriskie */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.axios=t():e.axios=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,t),o.loaded=!0,o.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){e.exports=n(1)},function(e,t,n){"use strict";function r(e){var t=new s(e),n=i(s.prototype.request,t);return o.extend(n,s.prototype,t),o.extend(n,t),n}var o=n(2),i=n(3),s=n(4),a=n(22),u=n(10),c=r(u);c.Axios=s,c.create=function(e){return r(a(c.defaults,e))},c.Cancel=n(23),c.CancelToken=n(24),c.isCancel=n(9),c.all=function(e){return Promise.all(e)},c.spread=n(25),e.exports=c,e.exports.default=c},function(e,t,n){"use strict";function r(e){return"[object Array]"===j.call(e)}function o(e){return"undefined"==typeof e}function i(e){return null!==e&&!o(e)&&null!==e.constructor&&!o(e.constructor)&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}function s(e){return"[object ArrayBuffer]"===j.call(e)}function a(e){return"undefined"!=typeof FormData&&e instanceof FormData}function u(e){var t;return t="undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&e.buffer instanceof ArrayBuffer}function c(e){return"string"==typeof e}function f(e){return"number"==typeof e}function p(e){return null!==e&&"object"==typeof e}function d(e){return"[object Date]"===j.call(e)}function l(e){return"[object File]"===j.call(e)}function h(e){return"[object Blob]"===j.call(e)}function m(e){return"[object Function]"===j.call(e)}function y(e){return p(e)&&m(e.pipe)}function g(e){return"undefined"!=typeof URLSearchParams&&e instanceof URLSearchParams}function v(e){return e.replace(/^\s*/,"").replace(/\s*$/,"")}function x(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)}function w(e,t){if(null!==e&&"undefined"!=typeof e)if("object"!=typeof e&&(e=[e]),r(e))for(var n=0,o=e.length;n<o;n++)t.call(null,e[n],n,e);else for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.call(null,e[i],i,e)}function b(){function e(e,n){"object"==typeof t[n]&&"object"==typeof e?t[n]=b(t[n],e):t[n]=e}for(var t={},n=0,r=arguments.length;n<r;n++)w(arguments[n],e);return t}function E(){function e(e,n){"object"==typeof t[n]&&"object"==typeof e?t[n]=E(t[n],e):"object"==typeof e?t[n]=E({},e):t[n]=e}for(var t={},n=0,r=arguments.length;n<r;n++)w(arguments[n],e);return t}function S(e,t,n){return w(t,function(t,r){n&&"function"==typeof t?e[r]=C(t,n):e[r]=t}),e}var C=n(3),j=Object.prototype.toString;e.exports={isArray:r,isArrayBuffer:s,isBuffer:i,isFormData:a,isArrayBufferView:u,isString:c,isNumber:f,isObject:p,isUndefined:o,isDate:d,isFile:l,isBlob:h,isFunction:m,isStream:y,isURLSearchParams:g,isStandardBrowserEnv:x,forEach:w,merge:b,deepMerge:E,extend:S,trim:v}},function(e,t){"use strict";e.exports=function(e,t){return function(){for(var n=new Array(arguments.length),r=0;r<n.length;r++)n[r]=arguments[r];return e.apply(t,n)}}},function(e,t,n){"use strict";function r(e){this.defaults=e,this.interceptors={request:new s,response:new s}}var o=n(2),i=n(5),s=n(6),a=n(7),u=n(22);r.prototype.request=function(e){"string"==typeof e?(e=arguments[1]||{},e.url=arguments[0]):e=e||{},e=u(this.defaults,e),e.method?e.method=e.method.toLowerCase():this.defaults.method?e.method=this.defaults.method.toLowerCase():e.method="get";var t=[a,void 0],n=Promise.resolve(e);for(this.interceptors.request.forEach(function(e){t.unshift(e.fulfilled,e.rejected)}),this.interceptors.response.forEach(function(e){t.push(e.fulfilled,e.rejected)});t.length;)n=n.then(t.shift(),t.shift());return n},r.prototype.getUri=function(e){return e=u(this.defaults,e),i(e.url,e.params,e.paramsSerializer).replace(/^\?/,"")},o.forEach(["delete","get","head","options"],function(e){r.prototype[e]=function(t,n){return this.request(o.merge(n||{},{method:e,url:t}))}}),o.forEach(["post","put","patch"],function(e){r.prototype[e]=function(t,n,r){return this.request(o.merge(r||{},{method:e,url:t,data:n}))}}),e.exports=r},function(e,t,n){"use strict";function r(e){return encodeURIComponent(e).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}var o=n(2);e.exports=function(e,t,n){if(!t)return e;var i;if(n)i=n(t);else if(o.isURLSearchParams(t))i=t.toString();else{var s=[];o.forEach(t,function(e,t){null!==e&&"undefined"!=typeof e&&(o.isArray(e)?t+="[]":e=[e],o.forEach(e,function(e){o.isDate(e)?e=e.toISOString():o.isObject(e)&&(e=JSON.stringify(e)),s.push(r(t)+"="+r(e))}))}),i=s.join("&")}if(i){var a=e.indexOf("#");a!==-1&&(e=e.slice(0,a)),e+=(e.indexOf("?")===-1?"?":"&")+i}return e}},function(e,t,n){"use strict";function r(){this.handlers=[]}var o=n(2);r.prototype.use=function(e,t){return this.handlers.push({fulfilled:e,rejected:t}),this.handlers.length-1},r.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null)},r.prototype.forEach=function(e){o.forEach(this.handlers,function(t){null!==t&&e(t)})},e.exports=r},function(e,t,n){"use strict";function r(e){e.cancelToken&&e.cancelToken.throwIfRequested()}var o=n(2),i=n(8),s=n(9),a=n(10);e.exports=function(e){r(e),e.headers=e.headers||{},e.data=i(e.data,e.headers,e.transformRequest),e.headers=o.merge(e.headers.common||{},e.headers[e.method]||{},e.headers),o.forEach(["delete","get","head","post","put","patch","common"],function(t){delete e.headers[t]});var t=e.adapter||a.adapter;return t(e).then(function(t){return r(e),t.data=i(t.data,t.headers,e.transformResponse),t},function(t){return s(t)||(r(e),t&&t.response&&(t.response.data=i(t.response.data,t.response.headers,e.transformResponse))),Promise.reject(t)})}},function(e,t,n){"use strict";var r=n(2);e.exports=function(e,t,n){return r.forEach(n,function(n){e=n(e,t)}),e}},function(e,t){"use strict";e.exports=function(e){return!(!e||!e.__CANCEL__)}},function(e,t,n){"use strict";function r(e,t){!i.isUndefined(e)&&i.isUndefined(e["Content-Type"])&&(e["Content-Type"]=t)}function o(){var e;return"undefined"!=typeof XMLHttpRequest?e=n(12):"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process)&&(e=n(12)),e}var i=n(2),s=n(11),a={"Content-Type":"application/x-www-form-urlencoded"},u={adapter:o(),transformRequest:[function(e,t){return s(t,"Accept"),s(t,"Content-Type"),i.isFormData(e)||i.isArrayBuffer(e)||i.isBuffer(e)||i.isStream(e)||i.isFile(e)||i.isBlob(e)?e:i.isArrayBufferView(e)?e.buffer:i.isURLSearchParams(e)?(r(t,"application/x-www-form-urlencoded;charset=utf-8"),e.toString()):i.isObject(e)?(r(t,"application/json;charset=utf-8"),JSON.stringify(e)):e}],transformResponse:[function(e){if("string"==typeof e)try{e=JSON.parse(e)}catch(e){}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,validateStatus:function(e){return e>=200&&e<300}};u.headers={common:{Accept:"application/json, text/plain, */*"}},i.forEach(["delete","get","head"],function(e){u.headers[e]={}}),i.forEach(["post","put","patch"],function(e){u.headers[e]=i.merge(a)}),e.exports=u},function(e,t,n){"use strict";var r=n(2);e.exports=function(e,t){r.forEach(e,function(n,r){r!==t&&r.toUpperCase()===t.toUpperCase()&&(e[t]=n,delete e[r])})}},function(e,t,n){"use strict";var r=n(2),o=n(13),i=n(5),s=n(16),a=n(19),u=n(20),c=n(14);e.exports=function(e){return new Promise(function(t,f){var p=e.data,d=e.headers;r.isFormData(p)&&delete d["Content-Type"];var l=new XMLHttpRequest;if(e.auth){var h=e.auth.username||"",m=e.auth.password||"";d.Authorization="Basic "+btoa(h+":"+m)}var y=s(e.baseURL,e.url);if(l.open(e.method.toUpperCase(),i(y,e.params,e.paramsSerializer),!0),l.timeout=e.timeout,l.onreadystatechange=function(){if(l&&4===l.readyState&&(0!==l.status||l.responseURL&&0===l.responseURL.indexOf("file:"))){var n="getAllResponseHeaders"in l?a(l.getAllResponseHeaders()):null,r=e.responseType&&"text"!==e.responseType?l.response:l.responseText,i={data:r,status:l.status,statusText:l.statusText,headers:n,config:e,request:l};o(t,f,i),l=null}},l.onabort=function(){l&&(f(c("Request aborted",e,"ECONNABORTED",l)),l=null)},l.onerror=function(){f(c("Network Error",e,null,l)),l=null},l.ontimeout=function(){var t="timeout of "+e.timeout+"ms exceeded";e.timeoutErrorMessage&&(t=e.timeoutErrorMessage),f(c(t,e,"ECONNABORTED",l)),l=null},r.isStandardBrowserEnv()){var g=n(21),v=(e.withCredentials||u(y))&&e.xsrfCookieName?g.read(e.xsrfCookieName):void 0;v&&(d[e.xsrfHeaderName]=v)}if("setRequestHeader"in l&&r.forEach(d,function(e,t){"undefined"==typeof p&&"content-type"===t.toLowerCase()?delete d[t]:l.setRequestHeader(t,e)}),r.isUndefined(e.withCredentials)||(l.withCredentials=!!e.withCredentials),e.responseType)try{l.responseType=e.responseType}catch(t){if("json"!==e.responseType)throw t}"function"==typeof e.onDownloadProgress&&l.addEventListener("progress",e.onDownloadProgress),"function"==typeof e.onUploadProgress&&l.upload&&l.upload.addEventListener("progress",e.onUploadProgress),e.cancelToken&&e.cancelToken.promise.then(function(e){l&&(l.abort(),f(e),l=null)}),void 0===p&&(p=null),l.send(p)})}},function(e,t,n){"use strict";var r=n(14);e.exports=function(e,t,n){var o=n.config.validateStatus;!o||o(n.status)?e(n):t(r("Request failed with status code "+n.status,n.config,null,n.request,n))}},function(e,t,n){"use strict";var r=n(15);e.exports=function(e,t,n,o,i){var s=new Error(e);return r(s,t,n,o,i)}},function(e,t){"use strict";e.exports=function(e,t,n,r,o){return e.config=t,n&&(e.code=n),e.request=r,e.response=o,e.isAxiosError=!0,e.toJSON=function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code}},e}},function(e,t,n){"use strict";var r=n(17),o=n(18);e.exports=function(e,t){return e&&!r(t)?o(e,t):t}},function(e,t){"use strict";e.exports=function(e){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e)}},function(e,t){"use strict";e.exports=function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}},function(e,t,n){"use strict";var r=n(2),o=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];e.exports=function(e){var t,n,i,s={};return e?(r.forEach(e.split("\n"),function(e){if(i=e.indexOf(":"),t=r.trim(e.substr(0,i)).toLowerCase(),n=r.trim(e.substr(i+1)),t){if(s[t]&&o.indexOf(t)>=0)return;"set-cookie"===t?s[t]=(s[t]?s[t]:[]).concat([n]):s[t]=s[t]?s[t]+", "+n:n}}),s):s}},function(e,t,n){"use strict";var r=n(2);e.exports=r.isStandardBrowserEnv()?function(){function e(e){var t=e;return n&&(o.setAttribute("href",t),t=o.href),o.setAttribute("href",t),{href:o.href,protocol:o.protocol?o.protocol.replace(/:$/,""):"",host:o.host,search:o.search?o.search.replace(/^\?/,""):"",hash:o.hash?o.hash.replace(/^#/,""):"",hostname:o.hostname,port:o.port,pathname:"/"===o.pathname.charAt(0)?o.pathname:"/"+o.pathname}}var t,n=/(msie|trident)/i.test(navigator.userAgent),o=document.createElement("a");return t=e(window.location.href),function(n){var o=r.isString(n)?e(n):n;return o.protocol===t.protocol&&o.host===t.host}}():function(){return function(){return!0}}()},function(e,t,n){"use strict";var r=n(2);e.exports=r.isStandardBrowserEnv()?function(){return{write:function(e,t,n,o,i,s){var a=[];a.push(e+"="+encodeURIComponent(t)),r.isNumber(n)&&a.push("expires="+new Date(n).toGMTString()),r.isString(o)&&a.push("path="+o),r.isString(i)&&a.push("domain="+i),s===!0&&a.push("secure"),document.cookie=a.join("; ")},read:function(e){var t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}()},function(e,t,n){"use strict";var r=n(2);e.exports=function(e,t){t=t||{};var n={},o=["url","method","params","data"],i=["headers","auth","proxy"],s=["baseURL","url","transformRequest","transformResponse","paramsSerializer","timeout","withCredentials","adapter","responseType","xsrfCookieName","xsrfHeaderName","onUploadProgress","onDownloadProgress","maxContentLength","validateStatus","maxRedirects","httpAgent","httpsAgent","cancelToken","socketPath"];r.forEach(o,function(e){"undefined"!=typeof t[e]&&(n[e]=t[e])}),r.forEach(i,function(o){r.isObject(t[o])?n[o]=r.deepMerge(e[o],t[o]):"undefined"!=typeof t[o]?n[o]=t[o]:r.isObject(e[o])?n[o]=r.deepMerge(e[o]):"undefined"!=typeof e[o]&&(n[o]=e[o])}),r.forEach(s,function(r){"undefined"!=typeof t[r]?n[r]=t[r]:"undefined"!=typeof e[r]&&(n[r]=e[r])});var a=o.concat(i).concat(s),u=Object.keys(t).filter(function(e){return a.indexOf(e)===-1});return r.forEach(u,function(r){"undefined"!=typeof t[r]?n[r]=t[r]:"undefined"!=typeof e[r]&&(n[r]=e[r])}),n}},function(e,t){"use strict";function n(e){this.message=e}n.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},n.prototype.__CANCEL__=!0,e.exports=n},function(e,t,n){"use strict";function r(e){if("function"!=typeof e)throw new TypeError("executor must be a function.");var t;this.promise=new Promise(function(e){t=e});var n=this;e(function(e){n.reason||(n.reason=new o(e),t(n.reason))})}var o=n(23);r.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},r.source=function(){var e,t=new r(function(t){e=t});return{token:t,cancel:e}},e.exports=r},function(e,t){"use strict";e.exports=function(e){return function(t){return e.apply(null,t)}}}])});
//# sourceMappingURL=axios.min.map

// source ./UMD.js
(function(factory){
	
	var _name = 'ruta',
		_global = typeof window === 'undefined' ? global : window,
		_module = {
			exports: {}
		};

	factory(_module, _module.exports, _global);

	if (typeof define === 'function' && define.amd) {
        define([], function () {
        	return _module.exports;
        });
        return;
    } 
    if (typeof module === 'object' && module.exports) {
    	module.exports = _module.exports;
    	return;
    }

	if (_name) {
		_global[_name] = _module.exports;
	}

}(function(module, exports, global){
	var _src_api_utils = {};
var _src_emit_Hash = {};
var _src_emit_History = {};
var _src_emit_ILocationSource = {};
var _src_emit_Lifycycle = {};
var _src_emit_LocationEmitter = {};
var _src_emit_Memory = {};
var _src_emit_Stack = {};
var _src_globals = {};
var _src_mask_attr_anchor_dynamic = {};
var _src_options = {};
var _src_route_Route = {};
var _src_route_RouteCollection = {};
var _src_route_match = {};
var _src_route_route_utils = {};
var _src_ruta = {};
var _src_utils_log = {};
var _src_utils_navigation = {};
var _src_utils_obj = {};
var _src_utils_parts = {};
var _src_utils_path = {};
var _src_utils_query = {};
var _src_utils_rgx = {};

// source ./ModuleSimplified.js
var _src_utils_log;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function log_error() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    console.error.apply(console, ['Ruta'].concat(args));
}
exports.log_error = log_error;
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_log) && isObject(module.exports)) {
		Object.assign(_src_utils_log, module.exports);
		return;
	}
	_src_utils_log = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_query;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = _src_utils_log;
function query_deserialize(query, delimiter) {
    if (delimiter == null)
        delimiter = '&';
    var obj = {}, parts = query.split(delimiter), i = 0, imax = parts.length, x, val;
    for (; i < imax; i++) {
        x = parts[i].split('=');
        val = x[1] == null
            ? ''
            : decode(x[1]);
        obj_setProperty(obj, x[0], val);
    }
    return obj;
}
exports.query_deserialize = query_deserialize;
;
function query_serialize(params, delimiter) {
    if (delimiter == null)
        delimiter = '&';
    var query = '', key, val;
    for (key in params) {
        val = params[key];
        if (val == null)
            continue;
        // serialize as flag
        if (typeof val === 'boolean')
            val = null;
        query = query + (query ? delimiter : '') + key;
        if (val /* unstrict */)
            query += '=' + encode(val);
    }
    return query;
}
exports.query_serialize = query_serialize;
;
// = private
function obj_setProperty(obj, property, value) {
    var chain = property.split('.'), imax = chain.length, i = -1, key;
    while (++i < imax - 1) {
        key = chain[i];
        if (obj[key] == null)
            obj[key] = {};
        obj = obj[key];
    }
    obj[chain[i]] = value;
}
function decode(str) {
    try {
        return decodeURIComponent(str);
    }
    catch (error) {
        log_1.log_error('decode:URI malformed');
        return '';
    }
}
function encode(str) {
    try {
        return encodeURIComponent(str);
    }
    catch (error) {
        log_1.log_error('encode:URI malformed');
        return '';
    }
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_query) && isObject(module.exports)) {
		Object.assign(_src_utils_query, module.exports);
		return;
	}
	_src_utils_query = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_parts;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var query_1 = _src_utils_query;
var path_1 = _src_utils_path;
/**
 *	'/foo/bar?a=b' =>
 *	{ path: ['foo', 'bar'], query: { a: 'b' } }
 */
function parts_serialize(parts) {
    var path = path_1.path_join(parts.path);
    if (parts.query == null)
        return path;
    return path
        + '?'
        + query_1.query_serialize(parts.query, '&');
}
exports.parts_serialize = parts_serialize;
;
function parts_deserialize(url) {
    var query = url.indexOf('?'), path = query === -1
        ? url
        : url.substring(0, query);
    return {
        path: path_1.path_split(path),
        query: query === -1
            ? null
            : query_1.query_deserialize(url.substring(query + 1), '&')
    };
}
exports.parts_deserialize = parts_deserialize;
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_parts) && isObject(module.exports)) {
		Object.assign(_src_utils_parts, module.exports);
		return;
	}
	_src_utils_parts = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_path;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var query_1 = _src_utils_query;
var parts_1 = _src_utils_parts;
function path_normalize(str) {
    var length = str.length;
    var i = 0;
    for (; i < length; i++) {
        if (str[i] === '/') {
            continue;
        }
        break;
    }
    var j = length - 1;
    for (; j > i; j--) {
        if (str[j] === '/') {
            continue;
        }
        break;
    }
    return str.substring(i, j + 1);
}
exports.path_normalize = path_normalize;
;
function path_split(path) {
    path = path_normalize(path);
    return path === ''
        ? []
        : path.split('/');
}
exports.path_split = path_split;
;
function path_join(pathParts) {
    return '/' + pathParts.join('/');
}
exports.path_join = path_join;
;
function path_fromCLI(commands) {
    if (typeof commands === 'string') {
        commands = cli_split(commands);
    }
    var parts = cli_parseArguments(commands);
    return parts_1.parts_serialize(parts);
}
exports.path_fromCLI = path_fromCLI;
;
function path_getQuery(path) {
    var i = path.indexOf('?');
    if (i === -1) {
        return {};
    }
    var query = path.substring(i + 1);
    return query_1.query_deserialize(query, '&');
}
exports.path_getQuery = path_getQuery;
;
function path_setQuery(path, mix) {
    var query = typeof mix !== 'string'
        ? query_1.query_serialize(mix, '&')
        : mix;
    var i = path.indexOf('?');
    if (i !== -1) {
        path = path.substring(0, i);
    }
    return path + '?' + query;
}
exports.path_setQuery = path_setQuery;
;
// == private
function cli_split(string) {
    var args = string.trim().split(/\s+/);
    var imax = args.length, i = -1, c, arg;
    while (++i < imax) {
        arg = args[i];
        if (arg.length === 0)
            continue;
        c = arg[0];
        if (c !== '"' && c !== "'")
            continue;
        var start = i;
        for (; i < imax; i++) {
            arg = args[i];
            if (arg[arg.length - 1] === c) {
                var str = args
                    .splice(start, i - start + 1)
                    .join(' ')
                    .slice(1, -1);
                args.splice(start, 0, str);
                imax = args.length;
                break;
            }
        }
    }
    return args;
}
function cli_parseArguments(argv) {
    var imax = argv.length, i = 0, params = {}, args = [], key, val, x;
    for (; i < imax; i++) {
        x = argv[i];
        if (x[0] === '-') {
            key = x.replace(/^[\-]+/, '');
            if (i < imax - 1 && argv[i + 1][0] !== '-') {
                val = argv[i + 1];
                i++;
            }
            else {
                val = true;
            }
            params[key] = val;
            continue;
        }
        args.push(x);
    }
    return {
        path: args,
        query: params
    };
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_path) && isObject(module.exports)) {
		Object.assign(_src_utils_path, module.exports);
		return;
	}
	_src_utils_path = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_rgx;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = _src_utils_log;
function rgx_fromString(str, flags) {
    return new RegExp(str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), flags);
}
exports.rgx_fromString = rgx_fromString;
;
/**
 *  Url part should be completely matched, so add ^...$ and create RegExp
 */
function rgx_aliasMatcher(str) {
    if (str[0] === '^')
        return new RegExp(str);
    var groups = str.split('|');
    for (var i = 0, imax = groups.length; i < imax; i++) {
        groups[i] = '^' + groups[i] + '$';
    }
    return new RegExp(groups.join('|'));
}
exports.rgx_aliasMatcher = rgx_aliasMatcher;
;
/**
 * :debugger(d|debug) => { alias: 'debugger', matcher: RegExp }
 */
function rgx_parsePartWithRegExpAlias(str) {
    var pStart = str.indexOf('('), pEnd = str.lastIndexOf(')');
    if (pStart === -1 || pEnd === -1) {
        log_1.log_error('Expected alias part with regexp', str);
        return null;
    }
    var rgx = str.substring(pStart + 1, pEnd);
    return {
        alias: str.substring(1, pStart),
        matcher: rgx_aliasMatcher(rgx)
    };
}
exports.rgx_parsePartWithRegExpAlias = rgx_parsePartWithRegExpAlias;
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_rgx) && isObject(module.exports)) {
		Object.assign(_src_utils_rgx, module.exports);
		return;
	}
	_src_utils_rgx = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_route_route_utils;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = _src_utils_log;
var path_1 = _src_utils_path;
var query_1 = _src_utils_query;
var rgx_1 = _src_utils_rgx;
function route_parseDefinition(route, definition) {
    var c = definition.charCodeAt(0);
    switch (c) {
        case 33:
            // !
            route.strict = true;
            definition = definition.substring(1);
            break;
        case 94:
            // ^
            route.strict = false;
            definition = definition.substring(1);
            break;
        case 40:
            // (
            var start = 1, end = definition.length - 1;
            if (definition.charCodeAt(definition.length - 1) !== 41) {
                // )
                log_1.log_error('parser - expect group closing');
                end++;
            }
            route.match = new RegExp(definition.substring(start, end));
            return;
    }
    var parts = definition.split('/'), search, searchIndex, i = 0, imax = parts.length, x, c0, index, c1;
    var last = parts[imax - 1];
    searchIndex = last.indexOf('?');
    if (searchIndex > (imax === 1 ? -1 : 0)) {
        // `?` cannt be at `0` position, when has url definition contains `path`
        search = last.substring(searchIndex + 1);
        parts[imax - 1] = last.substring(0, searchIndex);
    }
    var matcher = '', alias = null, strictCount = 0;
    var gettingMatcher = true, isOptional, isAlias, rgx;
    var array = route.path = [];
    for (; i < imax; i++) {
        x = parts[i];
        if (x === '')
            continue;
        c0 = x.charCodeAt(0);
        c1 = x.charCodeAt(1);
        isOptional = c0 === 63; /* ? */
        isAlias = (isOptional ? c1 : c0) === 58; /* : */
        index = 0;
        if (isOptional)
            index++;
        if (isAlias)
            index++;
        if (index !== 0)
            x = x.substring(index);
        // if DEBUG
        if (!isOptional && !gettingMatcher)
            log_1.log_error('Strict part found after optional', definition);
        // endif
        if (x === '*') {
            array.push({
                matcher: new AnyMatcher()
            });
            continue;
        }
        if (isOptional)
            gettingMatcher = false;
        var bracketIndex = x.indexOf('(');
        if (isAlias && bracketIndex !== -1) {
            var end = x.length - 1;
            if (x[end] !== ')')
                end += 1;
            rgx = new RegExp(rgx_1.rgx_aliasMatcher(x.substring(bracketIndex + 1, end)));
            x = x.substring(0, bracketIndex);
        }
        if (!isOptional && !isAlias) {
            array.push(x);
            continue;
        }
        if (isAlias) {
            array.push({
                alias: x,
                matcher: rgx,
                optional: isOptional
            });
            continue;
        }
        if (isOptional) {
            array.push({
                matcher: new StrMatcher(x),
                optional: isOptional
            });
        }
    }
    if (search) {
        var query = route.query = {};
        parts = search.split('&');
        i = -1;
        imax = parts.length;
        var key, value, str, eqIndex;
        while (++i < imax) {
            str = parts[i];
            eqIndex = str.indexOf('=');
            if (eqIndex === -1) {
                query[str] = ''; // <empty string>
                continue;
            }
            key = str.substring(0, eqIndex);
            value = str.substring(eqIndex + 1);
            if (value.charCodeAt(0) === 40) {
                // (
                value = new RegExp(rgx_1.rgx_aliasMatcher(value));
            }
            query[key] = value;
        }
        if (route.path.length === 0) {
            route.strict = false;
        }
    }
}
exports.route_parseDefinition = route_parseDefinition;
;
/**
 * path should be already matched by the route
 */
function route_parsePath(route, path) {
    var queryIndex = path.indexOf('?'), query = queryIndex === -1
        ? null
        : path.substring(queryIndex + 1), current = {
        path: path,
        params: query == null
            ? {}
            : query_1.query_deserialize(query, '&')
    };
    if (route.query) {
        // ensura aliased queries, like ?:debugger(d|debug)
        for (var key in route.query) {
            if (key[0] === '?')
                key = key.substring(1);
            if (key[0] === ':') {
                var alias = rgx_1.rgx_parsePartWithRegExpAlias(key), name = alias.alias;
                current.params[name] = getAliasedValue(current.params, alias.matcher);
            }
        }
    }
    if (queryIndex !== -1) {
        path = path.substring(0, queryIndex);
    }
    if (route.path != null) {
        var pathArr = path_1.path_split(path), routePath = route.path, routeLength = routePath.length, imax = pathArr.length, i = 0, part, x;
        for (; i < imax; i++) {
            part = pathArr[i];
            x = i < routeLength ? routePath[i] : null;
            if (x) {
                if (typeof x === 'string')
                    continue;
                if (x.alias) {
                    current.params[x.alias] = part;
                    continue;
                }
            }
        }
    }
    return current;
}
exports.route_parsePath = route_parsePath;
;
// = private
function getAliasedValue(obj, matcher) {
    for (var key in obj) {
        if (matcher.test(key))
            return obj[key];
    }
}
var Matcher = (function () {
    function Matcher(str) {
        this.str = str;
    }
    return Matcher;
}());
var StrMatcher = (function (_super) {
    __extends(StrMatcher, _super);
    function StrMatcher() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StrMatcher.prototype.test = function (x) {
        return x === this.str;
    };
    return StrMatcher;
}(Matcher));
;
var AnyMatcher = (function (_super) {
    __extends(AnyMatcher, _super);
    function AnyMatcher() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnyMatcher.prototype.test = function (x) {
        return true;
    };
    return AnyMatcher;
}(Matcher));
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_route_route_utils) && isObject(module.exports)) {
		Object.assign(_src_route_route_utils, module.exports);
		return;
	}
	_src_route_route_utils = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_options;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
/**
 * define if routes like '/path' are strict by default,
 * or set explicit '!/path' - strict, '^/path' - not strict
 *
 * Strict means - like in regex start-end /^$/
 **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    isStrict: true
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_options) && isObject(module.exports)) {
		Object.assign(_src_options, module.exports);
		return;
	}
	_src_options = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_route_Route;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var route_utils_1 = _src_route_route_utils;
var options_1 = _src_options;
var Route = (function () {
    function Route(definition, value) {
        if (value === void 0) { value = null; }
        this.definition = definition;
        this.value = value;
        this.strict = options_1.default.isStrict;
        var def = definition;
        if (def.charCodeAt(0) === 36 /*$ method prefix, e.g.: $get path*/) {
            var i = def.indexOf(' ');
            this.method = def.substring(1, i).toUpperCase();
            def = def.substring(i + 1);
        }
        route_utils_1.route_parseDefinition(this, def);
    }
    return Route;
}());
exports.default = Route;
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_route_Route) && isObject(module.exports)) {
		Object.assign(_src_route_Route, module.exports);
		return;
	}
	_src_route_Route = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_route_match;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var parts_1 = _src_utils_parts;
var rgx_1 = _src_utils_rgx;
var route_utils_1 = _src_route_route_utils;
function route_match(url, routes, method) {
    if (method === void 0) { method = null; }
    var parts = parts_1.parts_deserialize(url), imax = routes.length, i = -1;
    while (++i < imax) {
        var route = routes[i];
        if (route_isMatch(parts, route, method)) {
            route.current = route_utils_1.route_parsePath(route, url);
            return route;
        }
    }
    return null;
}
exports.route_match = route_match;
;
function route_matchAll(url, routes, method) {
    var parts = parts_1.parts_deserialize(url), imax = routes.length, i = -1, out = [];
    while (++i < imax) {
        var route = routes[i];
        if (route_isMatch(parts, route, method)) {
            route.current = route_utils_1.route_parsePath(route, url);
            out.push(route);
        }
    }
    return out;
}
exports.route_matchAll = route_matchAll;
;
function route_isMatch(parts, route, currentMethod) {
    if (currentMethod === void 0) { currentMethod = null; }
    if (currentMethod != null &&
        route.method != null &&
        route.method !== currentMethod) {
        return false;
    }
    if (route.match) {
        return route.match.test(typeof parts === 'string'
            ? parts
            : parts_1.parts_serialize(parts));
    }
    if (typeof parts === 'string')
        parts = parts_1.parts_deserialize(parts);
    // route defines some query, match these with the current path{parts}
    if (route.query) {
        var query = parts.query, key, value;
        if (query == null)
            return false;
        for (key in route.query) {
            value = route.query[key];
            var c = key[0];
            if (c === ':') {
                // '?:isGlob(g|glob) will match if any is present
                var alias = rgx_1.rgx_parsePartWithRegExpAlias(key);
                if (alias == null || hasKey(query, alias.matcher) === false)
                    return false;
                continue;
            }
            if (c === '?')
                continue;
            if (typeof value === 'string') {
                if (query[key] == null)
                    return false;
                if (value && query[key] !== value)
                    return false;
                continue;
            }
            if (value.test && !value.test(query[key]))
                return false;
        }
    }
    var routePath = route.path, routeLength = routePath.length;
    if (routeLength === 0) {
        if (route.strict)
            return parts.path.length === 0;
        return true;
    }
    var arr = parts.path;
    for (var i = 0, x, imax = arr.length; i < imax; i++) {
        x = routePath[i];
        if (i >= routeLength)
            return route.strict !== true;
        if (typeof x === 'string') {
            if (arr[i] === x)
                continue;
            return false;
        }
        if (x.matcher) {
            if (x.matcher.test(arr[i]) === false)
                return false;
            continue;
        }
        if (x.optional) {
            return true;
        }
        if (x.alias) {
            continue;
        }
        return false;
    }
    if (i < routeLength)
        return routePath[i].optional === true;
    return true;
}
exports.route_isMatch = route_isMatch;
;
function hasKey(obj, rgx) {
    for (var key in obj) {
        if (rgx.test(key))
            return true;
    }
    return false;
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_route_match) && isObject(module.exports)) {
		Object.assign(_src_route_match, module.exports);
		return;
	}
	_src_route_match = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_route_RouteCollection;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Route_1 = _src_route_Route;
var match_1 = _src_route_match;
var route_utils_1 = _src_route_route_utils;
var RouteCollection = (function () {
    function RouteCollection() {
        //type: 'url' | 'hash' = 'url'
        this.routes = [];
        // private normalizePath (path: string) {
        // 	if (this.type === 'hash' && path.indexOf('#') !== -1) {
        // 		return path.substring(path.indexOf('#') + 1);
        // 	}
        // 	return path;
        // }
    }
    /** alias for `push` */
    RouteCollection.prototype.add = function (def, value) {
        this.push(def, value);
        return this;
    };
    RouteCollection.prototype.push = function (def, value) {
        this.routes.push(new Route_1.default(def, value));
        return this;
    };
    RouteCollection.prototype.unshift = function (def, value) {
        var route = new Route_1.default(def, value);
        this.routes.unshift(route);
        return this;
    };
    RouteCollection.prototype.remove = function (def, value) {
        var imax = this.routes.length, i = -1;
        while (++i < imax) {
            var route = this.routes[i];
            if (def == null || route.definition !== def) {
                continue;
            }
            if (value == null || route.value !== value) {
                continue;
            }
            this.routes.splice(i, 1);
            i--;
            imax--;
        }
    };
    RouteCollection.prototype.get = function (path, method) {
        //@TODO Sometimes user can request route by full url when using hash router, should we do smth.here
        //-path = this.normalizePath(path);
        return match_1.route_match(path, this.routes, method);
    };
    RouteCollection.prototype.getAll = function (path, method) {
        //-path = this.normalizePath(path)
        return match_1.route_matchAll(path, this.routes, method);
    };
    RouteCollection.prototype.clear = function () {
        this.routes.length = 0;
        return this;
    };
    RouteCollection.parse = function (definition, path) {
        var route = {};
        route_utils_1.route_parseDefinition(route, definition);
        return route_utils_1.route_parsePath(route, path);
    };
    return RouteCollection;
}());
exports.default = RouteCollection;
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_route_RouteCollection) && isObject(module.exports)) {
		Object.assign(_src_route_RouteCollection, module.exports);
		return;
	}
	_src_route_RouteCollection = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_Hash;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var HashEmitter = (function () {
    function HashEmitter(listener) {
        this.listener = listener;
        this.opts = null;
        window.onhashchange = this.onhashchange.bind(this);
    }
    HashEmitter.supports = function () {
        if (typeof window === 'undefined' || 'onhashchange' in window === false)
            return false;
        return true;
    };
    HashEmitter.normalizeHash = function (hash) {
        return hash.replace(/^[!#/]+/, '/');
    };
    HashEmitter.prototype.onhashchange = function () {
        this.changed();
    };
    HashEmitter.prototype.navigate = function (hash, opts) {
        this.opts = opts;
        if (hash == null) {
            this.changed();
            return;
        }
        location.hash = hash;
    };
    HashEmitter.prototype.changed = function (opts_) {
        var opts = opts_ || this.opts;
        this.opts = null;
        this.listener.onChanged(this.current(), opts);
    };
    HashEmitter.prototype.current = function () {
        return HashEmitter.normalizeHash(location.hash);
    };
    HashEmitter.prototype.back = function () {
        window.history.back();
    };
    HashEmitter.prototype.forward = function () {
        window.history.forward();
    };
    return HashEmitter;
}());
exports.default = HashEmitter;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_Hash) && isObject(module.exports)) {
		Object.assign(_src_emit_Hash, module.exports);
		return;
	}
	_src_emit_Hash = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_obj;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function obj_extend(a, b) {
    if (b == null)
        return a || {};
    if (a == null)
        return obj_create(b);
    for (var key in b) {
        a[key] = b[key];
    }
    return a;
}
exports.obj_extend = obj_extend;
;
function obj_default(a, b) {
    if (b == null)
        return a || {};
    if (a == null)
        return obj_create(b);
    for (var key in b) {
        if (a[key] == null) {
            a[key] = b[key];
        }
    }
    return a;
}
exports.obj_default = obj_default;
;
var obj_create = Object.create || function (x) {
    var Ctor = function () { };
    Ctor.prototype = x;
    return new Ctor;
};
exports.obj_create = obj_create;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_obj) && isObject(module.exports)) {
		Object.assign(_src_utils_obj, module.exports);
		return;
	}
	_src_utils_obj = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_ILocationSource;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LocationNavigateOptions = (function () {
    function LocationNavigateOptions() {
        /**
         * History step. 1: Forward, 0: Replace Current, -1-(-n): Back
         * @default: 1
         * */
        this.step = 1;
        /**
         * Backcompat.
         * @deprecated Use `step:0`
         */
        this.replace = false;
        /** When true and query arguments are used, than navigation extends current query */
        this.extend = false;
        /** When false listeners are not notified */
        this.silent = false;
        /** Additional arguments which will be attached to the routes model params */
        this.params = null;
    }
    return LocationNavigateOptions;
}());
exports.LocationNavigateOptions = LocationNavigateOptions;
var LocationBackOptions = (function () {
    function LocationBackOptions() {
    }
    return LocationBackOptions;
}());
exports.LocationBackOptions = LocationBackOptions;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_ILocationSource) && isObject(module.exports)) {
		Object.assign(_src_emit_ILocationSource, module.exports);
		return;
	}
	_src_emit_ILocationSource = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_navigation;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getStep(opts) {
    if (opts == null)
        return 1;
    if (opts.replace === true)
        return 0;
    if (opts.step != null)
        return opts.step;
    return 1;
}
exports.getStep = getStep;
;
function setProperty(opts, key, val) {
    var x = opts || {};
    x[key] = val;
    return x;
}
exports.setProperty = setProperty;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_navigation) && isObject(module.exports)) {
		Object.assign(_src_utils_navigation, module.exports);
		return;
	}
	_src_utils_navigation = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_Stack;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Stack;
(function (Stack) {
    var time = Date.now();
    var uuid = 1;
    Stack.stack = [];
    Stack.forwardStates = [];
    function create(url) {
        return {
            id: time + "_" + ++uuid,
            url: url
        };
    }
    Stack.create = create;
    function push(current) {
        Stack.stack.push(current);
        Stack.forwardStates.length = 0;
    }
    Stack.push = push;
    function replace(current) {
        Stack.stack[Math.max(0, Stack.stack.length - 1)] = current;
    }
    Stack.replace = replace;
    // export function last () {
    // 	return stack.length === 1 
    // 		? null 
    // 		: stack[stack.length - 2]
    // 		;
    // }
    // export function next () {
    // 	return forwardStates[0];
    // }
    // export function isLast(id: number) {
    // 	let x = last();
    // 	return id != null && x != null && x.id === id;
    // }
    // export function findLastIndex(id: number) {
    // 	let i = backStates.length;
    // 	while(--i > -1) {
    // 		if (backStates[i].id == id) {
    // 			return i;
    // 		}
    // 	}
    // 	return -1;
    // }
    // export function findNextIndex(id: number) {
    // 	let i = -1;
    // 	while(++i < forwardStates.length) {
    // 		if (forwardStates[i].id == id) {
    // 			return i;
    // 		}
    // 	}
    // 	return -1;
    // }
    // export function isNext(id: number) {
    // 	let x = next();
    // 	return id != null && x != null && x.id === id;
    // }
    // export function pop (count = 1) {
    // 	return stack.splice(stack.length - count);
    // }
    function goBackById(id) {
        var i = Stack.stack.length;
        while (--i > -1) {
            if (Stack.stack[i].id !== id) {
                continue;
            }
            var count = Stack.stack.length - (i + 1);
            goBackByCount(count);
            return -count;
        }
        return 0;
    }
    Stack.goBackById = goBackById;
    function goBackByCount(count) {
        var arr = Stack.stack.splice(Stack.stack.length - count);
        Stack.forwardStates.unshift.apply(Stack.forwardStates, arr);
    }
    Stack.goBackByCount = goBackByCount;
    function goForwardById(id) {
        for (var i = 0; i < Stack.forwardStates.length; i++) {
            if (Stack.forwardStates[i].id !== id) {
                continue;
            }
            var count = i + 1;
            goForwardByCount(count);
            return count;
        }
        return 0;
    }
    Stack.goForwardById = goForwardById;
    function goForwardByCount(count) {
        var arr = Stack.forwardStates.splice(0, count);
        Stack.stack.push.apply(Stack.stack, arr);
    }
    Stack.goForwardByCount = goForwardByCount;
    // export function setForwards (states: State[]) {
    // 	forwardStates.unshift(...states);
    // }
    // export function goForward () {
    // 	backStates.push(forwardStates.shift());
    // }
    function hasBack() {
        return Stack.stack.length > 1;
    }
    Stack.hasBack = hasBack;
    function hasForwad() {
        return Stack.forwardStates.length > 0;
    }
    Stack.hasForwad = hasForwad;
    function getCurrent() {
        return Stack.stack.length === 0 ? null : Stack.stack[Stack.stack.length - 1];
    }
    Stack.getCurrent = getCurrent;
    function getBackStack() {
        return Stack.stack.length === 0 ? [] : Stack.stack.slice(0, Stack.stack.length - 1);
    }
    Stack.getBackStack = getBackStack;
})(Stack = exports.Stack || (exports.Stack = {}));
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_Stack) && isObject(module.exports)) {
		Object.assign(_src_emit_Stack, module.exports);
		return;
	}
	_src_emit_Stack = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_History;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var obj_1 = _src_utils_obj;
var path_1 = _src_utils_path;
var ILocationSource_1 = _src_emit_ILocationSource;
var navigation_1 = _src_utils_navigation;
var Stack_1 = _src_emit_Stack;
var HistoryEmitter = (function () {
    function HistoryEmitter(listener) {
        this.listener = listener;
        this.initial = location.href;
        window.onpopstate = this.onpopstate.bind(this);
        Stack_1.Stack.push(history.state || Stack_1.Stack.create(this.current()));
    }
    HistoryEmitter.supports = function () {
        if (typeof window === 'undefined') {
            return false;
        }
        if (!(window.history && window.history.pushState)) {
            return false;
        }
        return true;
    };
    HistoryEmitter.prototype.navigate = function (mix, opts) {
        if (opts === void 0) { opts = new ILocationSource_1.LocationNavigateOptions; }
        if (mix == null) {
            this.changed(opts);
            return;
        }
        var isQueryObject = typeof mix === 'object', url = null;
        if (opts.extend === true) {
            var query = isQueryObject ? mix : path_1.path_getQuery(mix), current = path_1.path_getQuery(location.search);
            if (current != null && query != null) {
                for (var key in current) {
                    // strict compare
                    if (query[key] !== void 0 && query[key] === null) {
                        delete current[key];
                    }
                }
                query = obj_1.obj_extend(current, query);
                url = path_1.path_setQuery(url || '', query);
            }
        }
        if (url == null) {
            url = isQueryObject ? path_1.path_setQuery('', mix) : mix;
        }
        var nextState = Stack_1.Stack.create(url);
        var step = navigation_1.getStep(opts);
        if (step === 0) {
            history.replaceState(nextState, null, url);
            Stack_1.Stack.replace(nextState);
        }
        else {
            history.pushState(nextState, null, url);
            Stack_1.Stack.push(nextState);
        }
        opts.step = 1;
        this.initial = null;
        this.changed(opts);
    };
    HistoryEmitter.prototype.current = function () {
        return location.pathname + location.search;
    };
    HistoryEmitter.prototype.back = function () {
        window.history.back();
    };
    HistoryEmitter.prototype.forward = function () {
        window.history.forward();
    };
    HistoryEmitter.prototype.onpopstate = function (e) {
        if (this.initial === location.href) {
            this.initial = null;
            return;
        }
        this.initial = null;
        var step = -1;
        var id = e.state && e.state.id;
        if (id != null) {
            step = Stack_1.Stack.goBackById(id);
            if (step === 0) {
                step = Stack_1.Stack.goForwardById(id);
            }
        }
        if (step === 0) {
            if (e.state) {
                Stack_1.Stack.replace(e.state);
            }
            step = -1;
            Stack_1.Stack.goBackByCount(1);
        }
        var opts = new ILocationSource_1.LocationNavigateOptions();
        opts.step = step;
        this.changed(opts);
    };
    HistoryEmitter.prototype.changed = function (opts) {
        this.listener.onChanged(this.current(), opts);
    };
    return HistoryEmitter;
}());
exports.default = HistoryEmitter;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_History) && isObject(module.exports)) {
		Object.assign(_src_emit_History, module.exports);
		return;
	}
	_src_emit_History = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_Memory;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var navigation_1 = _src_utils_navigation;
var ILocationSource_1 = _src_emit_ILocationSource;
var MemoryEmitter = (function () {
    function MemoryEmitter(listener) {
        this.listener = listener;
        this.stack = ['/'];
        this.forwardStack = [];
    }
    MemoryEmitter.prototype.navigate = function (path, opts) {
        var step = navigation_1.getStep(opts);
        if (step < 1) {
            var arr = this.stack.splice(step - 1);
            (_a = this.forwardStack).unshift.apply(_a, arr);
        }
        else {
            this.forwardStack.length = 0;
        }
        this.stack.push(path);
        this.listener.onChanged(path, opts);
        var _a;
    };
    MemoryEmitter.prototype.current = function () {
        return this.stack[this.stack.length - 1];
    };
    MemoryEmitter.prototype.back = function () {
        this.forwardStack.unshift(this.stack.pop());
        var opts = new ILocationSource_1.LocationNavigateOptions();
        opts.step = -1;
        this.listener.onChanged(this.current(), opts);
    };
    MemoryEmitter.prototype.forward = function () {
        this.stack.push(this.forwardStack.shift());
        var opts = new ILocationSource_1.LocationNavigateOptions();
        opts.step = 1;
        this.listener.onChanged(this.current(), opts);
    };
    return MemoryEmitter;
}());
exports.default = MemoryEmitter;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_Memory) && isObject(module.exports)) {
		Object.assign(_src_emit_Memory, module.exports);
		return;
	}
	_src_emit_Memory = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_Lifycycle;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Route_1 = _src_route_Route;
var match_1 = _src_route_match;
var Lifecycle = (function () {
    function Lifecycle(location, definition, callback) {
        this.location = location;
        this.definition = definition;
        this.callback = callback;
        this.changed = this.changed.bind(this);
        this.location.on('^/', this.changed);
        this.route = new Route_1.default(definition);
        var current = match_1.route_match(this.location.currentPath(), [this.route]);
        this.state = {
            type: EventType.Initial,
            direction: Direction.Forward,
            route: current
        };
        this.callback(this.state);
    }
    Lifecycle.prototype.changed = function (route, opts) {
        this.state.direction = opts.step < 0
            ? Direction.Back
            : Direction.Forward;
        var state = this.state;
        var current = match_1.route_match(this.location.currentPath(), [this.route]);
        if (current == null) {
            if (this.state.route == null) {
                return;
            }
            state.type = EventType.Leave;
            state.route = null;
            this.callback(state);
            return;
        }
        if (this.state.route == null) {
            state.type = EventType.Enter;
            state.route = current;
            this.callback(state);
            return;
        }
        state.type = EventType.Change;
        state.route = current;
        this.callback(state);
    };
    Lifecycle.prototype.dispose = function () {
        this.location.off('^/', this.changed);
    };
    return Lifecycle;
}());
exports.default = Lifecycle;
var EventType;
(function (EventType) {
    EventType["Initial"] = "initial";
    EventType["Enter"] = "enter";
    EventType["Leave"] = "leave";
    EventType["Change"] = "change";
})(EventType = exports.EventType || (exports.EventType = {}));
;
var Direction;
(function (Direction) {
    Direction["Forward"] = "forward";
    Direction["Back"] = "back";
})(Direction = exports.Direction || (exports.Direction = {}));
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_Lifycycle) && isObject(module.exports)) {
		Object.assign(_src_emit_Lifycycle, module.exports);
		return;
	}
	_src_emit_Lifycycle = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_LocationEmitter;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RouteCollection_1 = _src_route_RouteCollection;
var Hash_1 = _src_emit_Hash;
var History_1 = _src_emit_History;
var Memory_1 = _src_emit_Memory;
var log_1 = _src_utils_log;
var obj_1 = _src_utils_obj;
var ILocationSource_1 = _src_emit_ILocationSource;
var Lifycycle_1 = _src_emit_Lifycycle;
var Stack_1 = _src_emit_Stack;
var LocationEmitter = (function () {
    function LocationEmitter(collection, type) {
        if (collection === void 0) { collection = new RouteCollection_1.default(); }
        if (type === void 0) { type = null; }
        this.collection = collection;
        this.type = type;
        this.listeners = new RouteCollection_1.default();
        this.lifecycles = [];
        if (type == null) {
            if (History_1.default.supports()) {
                type = 'history';
            }
            else if (Hash_1.default.supports()) {
                type = 'hash';
            }
        }
        switch (type) {
            case 'hash':
                this.emitter = new Hash_1.default(this);
                break;
            case 'history':
                this.emitter = new History_1.default(this);
                break;
            case 'memory':
                this.emitter = new Memory_1.default(this);
                break;
        }
        if (this.emitter == null) {
            log_1.log_error('Router can not be initialized - (nor HistoryAPI / nor hashchange');
        }
    }
    LocationEmitter.prototype.onChanged = function (path, opts) {
        if (opts === void 0) { opts = null; }
        if (opts && opts.silent === true) {
            return;
        }
        var route = this.collection.get(path);
        if (route) {
            this.doAction(route, opts);
        }
        var routes = this.listeners.getAll(path), imax = routes.length, i = -1;
        while (++i < imax) {
            this.doAction(routes[i], opts);
        }
    };
    LocationEmitter.prototype.doAction = function (route, opts) {
        if (opts === void 0) { opts = null; }
        if (typeof route.value === 'function') {
            var current = route.current;
            var params = current && current.params;
            if (opts && opts.params != null) {
                current.params = params = obj_1.obj_default(params, opts.params);
            }
            route.value(route, params);
        }
    };
    LocationEmitter.prototype.navigate = function (mix, opts) {
        if (opts === void 0) { opts = new ILocationSource_1.LocationNavigateOptions(); }
        this.emitter.navigate(mix, opts);
    };
    LocationEmitter.prototype.back = function (opts) {
        if (Stack_1.Stack.hasBack()) {
            this.emitter.back();
            return;
        }
        if (opts != null && opts.default != null) {
            var navOptions = opts.default.opts || new ILocationSource_1.LocationNavigateOptions();
            navOptions.step = 0;
            this.navigate(opts.default.url, navOptions);
            return;
        }
    };
    LocationEmitter.prototype.forward = function () {
        if (Stack_1.Stack.hasForwad()) {
            this.emitter.forward();
        }
    };
    LocationEmitter.prototype.getStack = function () {
        return Stack_1.Stack.stack;
    };
    LocationEmitter.prototype.getBackStack = function () {
        return Stack_1.Stack.getBackStack();
    };
    LocationEmitter.prototype.getForwardStack = function () {
        return Stack_1.Stack.forwardStates;
    };
    LocationEmitter.prototype.current = function () {
        return this.collection.get(this.currentPath());
    };
    LocationEmitter.prototype.currentPath = function () {
        return this.emitter.current();
    };
    LocationEmitter.prototype.on = function (def, cb) {
        this.listeners.push(def, cb);
    };
    LocationEmitter.prototype.off = function (def, cb) {
        this.listeners.remove(def, cb);
    };
    LocationEmitter.prototype.onLifecycle = function (def, cb) {
        this.lifecycles.push(new Lifycycle_1.default(this, def, cb));
    };
    LocationEmitter.prototype.offLifecycle = function (def, cb) {
        for (var i = 0; i < this.lifecycles.length; i++) {
            var x = this.lifecycles[i];
            if (x.definition === def && x.callback === cb) {
                x.dispose();
                this.lifecycles.splice(i, 1);
                i--;
            }
        }
    };
    return LocationEmitter;
}());
exports.default = LocationEmitter;
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_LocationEmitter) && isObject(module.exports)) {
		Object.assign(_src_emit_LocationEmitter, module.exports);
		return;
	}
	_src_emit_LocationEmitter = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_api_utils;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = _src_utils_path;
var query_1 = _src_utils_query;
exports.default = {
    /**
     * Format URI path from CLI command:
     * some action -foo bar === /some/action?foo=bar
     */
    pathFromCLI: path_1.path_fromCLI,
    query: {
        serialize: query_1.query_serialize,
        deserialize: query_1.query_deserialize,
        get: function (path_) {
            var path = path_ == null
                ? location.search
                : path_;
            return path_1.path_getQuery(path);
        }
    }
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_api_utils) && isObject(module.exports)) {
		Object.assign(_src_api_utils, module.exports);
		return;
	}
	_src_api_utils = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_globals;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mask_;
exports.mask = mask_;
if (typeof mask !== 'undefined') {
    exports.mask = mask_ = mask;
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_globals) && isObject(module.exports)) {
		Object.assign(_src_globals, module.exports);
		return;
	}
	_src_globals = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_mask_attr_anchor_dynamic;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = _src_globals;
var ruta_1 = _src_ruta;
if (globals_1.mask) {
    globals_1.mask.registerAttrHandler('x-dynamic', function (node, value, model, ctx, tag) {
        tag.onclick = navigate;
    }, 'client');
}
function navigate(event) {
    event.preventDefault();
    event.stopPropagation();
    ruta_1.default.navigate(this.getAttribute('href'));
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_mask_attr_anchor_dynamic) && isObject(module.exports)) {
		Object.assign(_src_mask_attr_anchor_dynamic, module.exports);
		return;
	}
	_src_mask_attr_anchor_dynamic = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_ruta;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RouteCollection_1 = _src_route_RouteCollection;
var LocationEmitter_1 = _src_emit_LocationEmitter;
var utils_1 = _src_api_utils;
var options_1 = _src_options;
_src_mask_attr_anchor_dynamic;
var Stack_1 = _src_emit_Stack;
exports.State = Stack_1.IState;
var routes = new RouteCollection_1.default();
var router;
function router_ensure() {
    if (router == null) {
        router = new LocationEmitter_1.default(routes);
    }
    return router;
}
exports.default = {
    Collection: RouteCollection_1.default,
    setRouterType: function (type) {
        if (router == null) {
            router = new LocationEmitter_1.default(routes, type);
        }
        return this;
    },
    setStrictBehaviour: function (isStrict) {
        options_1.default.isStrict = isStrict;
        return this;
    },
    add: function (regpath, mix) {
        router_ensure();
        routes.add(regpath, mix);
        return this;
    },
    on: function (regpath, mix) {
        router_ensure().on(regpath, mix);
        return this;
    },
    off: function (regpath, mix) {
        router_ensure().off(regpath, mix);
        return this;
    },
    onLifecycle: function (def, cb) {
        router_ensure().onLifecycle(def, cb);
        return this;
    },
    offLifecycle: function (def, cb) {
        router_ensure().offLifecycle(def, cb);
        return this;
    },
    get: function (path) {
        return routes.get(path);
    },
    navigate: function (mix, opts) {
        router_ensure().navigate(mix, opts);
        return this;
    },
    back: function (opts) {
        return router_ensure().back(opts);
    },
    forward: function () {
        return router_ensure().forward();
    },
    current: function () {
        return router_ensure().current();
    },
    currentPath: function () {
        return router_ensure().currentPath();
    },
    getStack: function () {
        return router_ensure().getStack();
    },
    getBackStack: function () {
        return router_ensure().getBackStack();
    },
    getForwardStack: function () {
        return router_ensure().getForwardStack();
    },
    notifyCurrent: function () {
        router_ensure().navigate();
        return this;
    },
    parse: RouteCollection_1.default.parse,
    /*
     * @deprecated - use `_` instead
     */
    $utils: utils_1.default,
    _: utils_1.default,
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_ruta) && isObject(module.exports)) {
		Object.assign(_src_ruta, module.exports);
		return;
	}
	_src_ruta = module.exports;
}());
// end:source ./ModuleSimplified.js

"use strict";
var ruta_1 = _src_ruta;
module.exports = ruta_1.default;

}));
// end:source ./UMD.js

// source ./browser/eval.js
function __eval(source, include) {
	"use strict";

	try {
	
		return eval.call(window, source);

	} catch (error) {
		error.url = include && include.url;
		console.error(error);
	}
	
}

// end:source ./browser/eval.js
// source ./umd/umd.js
(function (root, factory) {
    'use strict';

	var _global, _module;

	_global = typeof window === 'undefined' ? global : window;

	if (root != null && root !== _global && root.exports) {
		_module = root;
	}
	if (_module == null) {
		_module = typeof module === 'undefined' ? { exports: {} } : module;
	}
	
	factory(_global, _module, _module.exports, _global.document);

	if (typeof include !== 'undefined' && typeof include.js === 'function') {
		include.exports = _module.exports;
		// allow only one `include` per application
		return;
	}
	_global.include = _module.exports.include;
	_global.includeLib = _module.exports.includeLib;

}(this, function (global, module, exports, document) {
	'use strict';
	
	var CURRENT_MODULE = module;

	var _src_Bin = {};
var _src_Config = {};
var _src_CustomLoader = {};
var _src_Events = {};
var _src_Helper = {};
var _src_Include = {};
var _src_IncludeDeferred = {};
var _src_LazyModule = {};
var _src_PathResolver = {};
var _src_Resource = {};
var _src_Routing = {};
var _src_ScriptStack = {};
var _src_global = {};
var _src_loader_json = {};
var _src_loader_load = {};
var _src_loader_mask = {};
var _src_models_State = {};
var _src_models_Type = {};
var _src_modules_amd = {};
var _src_modules_common = {};
var _src_utils_array = {};
var _src_utils_fn = {};
var _src_utils_object = {};
var _src_utils_path = {};
var _src_utils_res = {};
var _src_utils_tree = {};

// source ./ModuleSimplified.js
var _src_global;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _global = typeof global === 'undefined' ? null : global;
exports.global = _global;
var _module = typeof module === 'undefined' ? null : module;
exports.module = _module;
var _document = typeof document === 'undefined' ? null : document;
exports.document = _document;
var _require = typeof require === 'undefined' ? null : require;
exports.loadBags = [
    _document
];
exports.IncludeLib = {
    loadBags: exports.loadBags,
};
exports.emptyResponse = {
    load: {}
};
exports.__require = {
    nativeRequire: _require,
    includeRequire: null
};
var _isBrowser = false, _isNode = false;
//#if (BROWSER)
_isBrowser = true;
_isNode = false;
//#endif
exports.isBrowser = _isBrowser;
exports.isNode = _isNode;
exports.isWeb = !!(typeof location !== 'undefined' && location.protocol && /^https?:/.test(location.protocol));
exports.refs = {
    XMLHttpRequest: global.XMLHttpRequest,
    evaluate: typeof __eval !== 'undefined' ? __eval : null
};
exports.handler = {
    onerror: null
};
var __noConflict = {
    require: _global.require,
    module: _global.module,
    include: _global.include,
    exports: _global.exports
};
function noConflict() {
    for (var key in __noConflict) {
        try {
            _global[key] = __noConflict[key];
        }
        catch (error) { }
    }
}
exports.noConflict = noConflict;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_global) && isObject(module.exports)) {
		Object.assign(_src_global, module.exports);
		return;
	}
	_src_global = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_models_Type;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResourceType;
(function (ResourceType) {
    ResourceType["Js"] = "js";
    ResourceType["Css"] = "css";
    ResourceType["Load"] = "load";
    ResourceType["Ajax"] = "ajax";
    ResourceType["Embed"] = "embed";
    ResourceType["Lazy"] = "lazy";
    ResourceType["Mask"] = "mask";
})(ResourceType = exports.ResourceType || (exports.ResourceType = {}));
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_models_Type) && isObject(module.exports)) {
		Object.assign(_src_models_Type, module.exports);
		return;
	}
	_src_models_Type = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_array;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function arr_invoke(arr, args, ctx) {
    if (arr == null || arr instanceof Array === false) {
        return;
    }
    for (var i = 0, length = arr.length; i < length; i++) {
        if (typeof arr[i] !== 'function') {
            continue;
        }
        if (args == null) {
            arr[i].call(ctx);
        }
        else {
            arr[i].apply(ctx, args);
        }
    }
}
exports.arr_invoke = arr_invoke;
function arr_ensure(obj, xpath) {
    if (!xpath) {
        return obj;
    }
    var arr = xpath.split('.'), imax = arr.length - 1, i = 0, key;
    for (; i < imax; i++) {
        key = arr[i];
        obj = obj[key] || (obj[key] = {});
    }
    key = arr[imax];
    return obj[key] || (obj[key] = []);
}
exports.arr_ensure = arr_ensure;
function arr_indexOf(arr, fn) {
    if (arr == null)
        return -1;
    var imax = arr.length, i = -1;
    while (++i < imax) {
        if (fn(arr[i], i))
            return i;
    }
    return -1;
}
exports.arr_indexOf = arr_indexOf;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_array) && isObject(module.exports)) {
		Object.assign(_src_utils_array, module.exports);
		return;
	}
	_src_utils_array = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_fn;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function fn_proxy(fn, ctx) {
    return function () {
        fn.apply(ctx, arguments);
    };
}
exports.fn_proxy = fn_proxy;
function fn_doNothing(fn) {
    typeof fn === 'function' && fn();
}
exports.fn_doNothing = fn_doNothing;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_fn) && isObject(module.exports)) {
		Object.assign(_src_utils_fn, module.exports);
		return;
	}
	_src_utils_fn = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Events;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var array_1 = _src_utils_array;
var fn_1 = _src_utils_fn;
var readycollection = [];
var supports = typeof document !== 'undefined' && typeof window !== 'undefined';
function onReady() {
    exports.Events.ready = fn_1.fn_doNothing;
    if (readycollection.length === 0) {
        return;
    }
    array_1.arr_invoke(readycollection);
    readycollection.length = 0;
}
function bind() {
    if ('onreadystatechange' in document) {
        document.onreadystatechange = function () {
            if (/complete|interactive/g.test(document.readyState) === false) {
                return;
            }
            onReady();
        };
    }
    else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', onReady);
    }
    else {
        window.onload = onReady;
    }
}
if (supports) {
    bind();
}
exports.Events = {
    ready: function (callback) {
        if (supports === false) {
            callback();
            return;
        }
        readycollection.unshift(callback);
    }
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_Events) && isObject(module.exports)) {
		Object.assign(_src_Events, module.exports);
		return;
	}
	_src_Events = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_object;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function obj_inherit(target /* source, ..*/) {
    if (typeof target === 'function') {
        target = target.prototype;
    }
    var i = 1, imax = arguments.length, source, key;
    for (; i < imax; i++) {
        source = typeof arguments[i] === 'function'
            ? arguments[i].prototype
            : arguments[i];
        for (key in source) {
            target[key] = source[key];
        }
    }
    return target;
}
exports.obj_inherit = obj_inherit;
;
function obj_getProperty(obj, property) {
    var chain = property.split('.'), length = chain.length, i = 0;
    for (; i < length; i++) {
        if (obj == null)
            return null;
        obj = obj[chain[i]];
    }
    return obj;
}
exports.obj_getProperty = obj_getProperty;
;
function obj_setProperty(obj, property, value) {
    var chain = property.split('.'), imax = chain.length - 1, i = -1, key;
    while (++i < imax) {
        key = chain[i];
        if (obj[key] == null)
            obj[key] = {};
        obj = obj[key];
    }
    obj[chain[i]] = value;
}
exports.obj_setProperty = obj_setProperty;
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_object) && isObject(module.exports)) {
		Object.assign(_src_utils_object, module.exports);
		return;
	}
	_src_utils_object = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_tree;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var object_1 = _src_utils_object;
var Routing_1 = _src_Routing;
function tree_resolveUsage(resource, usage, next) {
    var use = [], imax = usage.length, i = -1, obj, path, name, index, parent;
    while (++i < imax) {
        name = path = usage[i];
        index = path.indexOf('.');
        if (index !== -1) {
            name = path.substring(0, index);
            path = path.substring(index + 1);
        }
        parent = use_resolveParent(name, resource.parent, resource);
        if (parent == null)
            return null;
        if (parent.state !== 4) {
            resource.state = 3;
            parent.on(4, next, parent, 'push');
            return null;
        }
        obj = parent.exports;
        if (name !== path)
            obj = object_1.obj_getProperty(obj, path);
        // if DEBUG
        (typeof obj === 'object' && obj == null)
            && console.warn('<include:use> Used resource has no exports', name, resource.url);
        // endif
        use[i] = obj;
    }
    return use;
}
exports.tree_resolveUsage = tree_resolveUsage;
;
function use_resolveParent(name, resource, initiator) {
    if (resource == null) {
        // if DEBUG
        console.warn('<include> Usage Not Found:', name);
        console.warn('- Ensure to have it included before with the correct alias');
        console.warn('- Initiator Stacktrace:');
        var arr = [], res = initiator;
        while (res != null) {
            arr.push(res.url);
            res = res.parent;
        }
        console.warn(arr.join('\n'));
        // endif
        return null;
    }
    var includes = resource.includes, i = -1, imax = includes.length, include, exports, alias;
    while (++i < imax) {
        include = includes[i];
        alias = include.route.alias || Routing_1.Routes.parseAlias(include.route);
        if (alias === name)
            return include.resource;
    }
    return use_resolveParent(name, resource.parent, initiator);
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_tree) && isObject(module.exports)) {
		Object.assign(_src_utils_tree, module.exports);
		return;
	}
	_src_utils_tree = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_models_State;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
/**
 * STATES:
 * 0: Resource Created
 * 1: Loading
 * 2: Loaded - Evaluating
 * 2.5: Paused - Evaluating paused
 * 3: Evaluated - Childs Loading
 * 4: Childs Loaded - Completed
 */
Object.defineProperty(exports, "__esModule", { value: true });
var State;
(function (State) {
    State[State["Unknown"] = -1] = "Unknown";
    State[State["Created"] = 0] = "Created";
    State[State["Loading"] = 1] = "Loading";
    State[State["Evaluating"] = 2] = "Evaluating";
    State[State["Paused"] = 2.5] = "Paused";
    State[State["Evaluated"] = 3] = "Evaluated";
    State[State["AllCompleted"] = 4] = "AllCompleted";
})(State = exports.State || (exports.State = {}));
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_models_State) && isObject(module.exports)) {
		Object.assign(_src_models_State, module.exports);
		return;
	}
	_src_models_State = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_IncludeDeferred;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Events_1 = _src_Events;
var Routing_1 = _src_Routing;
var Config_1 = _src_Config;
var global_1 = _src_global;
var tree_1 = _src_utils_tree;
var State_1 = _src_models_State;
var Type_1 = _src_models_Type;
var IncludeDeferred = /** @class */ (function () {
    function IncludeDeferred() {
        this.callbacks = [];
        this.state = State_1.State.Unknown;
        this.response = null;
        this.includes = [];
        // Array: exports
        this._use = null;
        // Array: names
        this._usage = null;
    }
    IncludeDeferred.prototype.on = function (state, callback, sender, mutator) {
        if (sender === void 0) { sender = null; }
        if (this === sender && this.state === State_1.State.Unknown) {
            callback(this);
            return this;
        }
        // this === sender in case when script loads additional
        // resources and there are already parents listeners
        if (mutator == null) {
            mutator = (this.state < State_1.State.Evaluated || this === sender)
                ? 'unshift'
                : 'push';
        }
        state <= this.state ? callback(this) : this.callbacks[mutator]({
            state: state,
            callback: callback
        });
        return this;
    };
    IncludeDeferred.prototype.hasPendingChildren = function () {
        return false;
    };
    IncludeDeferred.prototype.readystatechanged = function (state) {
        if (this.state < state) {
            this.state = state;
        }
        if (this.state === State_1.State.Evaluated) {
            if (this.hasPendingChildren()) {
                return;
            }
            this.state = State_1.State.AllCompleted;
        }
        var currentState = this.state, cbs = this.callbacks, imax = cbs.length, i = -1;
        if (imax === 0) {
            return;
        }
        while (++i < imax) {
            var x = cbs[i];
            if (x == null || x.state > this.state) {
                continue;
            }
            cbs.splice(i, 1);
            imax--;
            i--;
            x.callback(this);
            if (this.state < currentState) {
                break;
            }
        }
    };
    /** assets loaded and DomContentLoaded */
    IncludeDeferred.prototype.ready = function (callback) {
        var _this = this;
        return this.on(State_1.State.AllCompleted, function () {
            Events_1.Events.ready(function () { return _this.resolve(callback); });
        }, this);
    };
    /** assets loaded */
    IncludeDeferred.prototype.done = function (callback) {
        var _this = this;
        return this.on(State_1.State.AllCompleted, function () { return _this.resolve(callback); }, this);
    };
    IncludeDeferred.prototype.resolve = function (callback) {
        var _this = this;
        var includes = this.includes, length = includes == null
            ? 0
            : includes.length;
        if (length > 0) {
            for (var i = 0; i < length; i++) {
                var x = includes[i];
                var resource = x.resource;
                var route = x.route;
                var type = resource.type;
                switch (type) {
                    case 'js':
                    case 'load':
                    case 'ajax':
                    case 'mask':
                    case 'embed':
                        var alias = route.alias || Routing_1.Routes.parseAlias(route), obj = type === 'js'
                            ? (this.response)
                            : (this.response[type] || (this.response[type] = {}));
                        if (alias != null) {
                            var exp = resource.exports;
                            if (Config_1.cfg.es6Exports && (exp != null && typeof exp === 'object')) {
                                exp = exp.default || exp;
                            }
                            obj[alias] = exp;
                            break;
                        }
                        console.warn('<includejs> Alias is undefined', resource);
                        break;
                }
            }
        }
        var response = this.response || global_1.emptyResponse;
        if (this._use == null && this._usage != null) {
            this._use = tree_1.tree_resolveUsage(this, this._usage, function () {
                _this.state = State_1.State.AllCompleted;
                _this.resolve(callback);
                _this.readystatechanged(State_1.State.AllCompleted);
            });
            if (this.state < State_1.State.AllCompleted)
                return;
        }
        if (this._use) {
            callback.apply(null, [response].concat(this._use));
            return;
        }
        var before = null;
        if (this.type === Type_1.ResourceType.Js) {
            before = global.include;
            global.include = this;
        }
        callback(response);
        if (before != null && global.include === this) {
            global.include = before;
        }
    };
    return IncludeDeferred;
}());
exports.IncludeDeferred = IncludeDeferred;
;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_IncludeDeferred) && isObject(module.exports)) {
		Object.assign(_src_IncludeDeferred, module.exports);
		return;
	}
	_src_IncludeDeferred = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Bin;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = _src_utils_path;
var Config_1 = _src_Config;
exports.Bin = {
    add: function (type, id, resource) {
        exports.bin[type][normalize(id)] = resource;
    },
    find: function (url) {
        var x = find(exports.bin, url);
        return x && x.resource || null;
    },
    remove: function (url) {
        while (true) {
            // clear if has multiple types
            var x = find(exports.bin, url);
            if (x == null)
                break;
            exports.bin[x.type][x.id] = null;
        }
    },
    get: function (type, url) {
        var x = findInType(exports.bin, type, url);
        if (x == null) {
            x = find(exports.bin, url);
        }
        return x && x.resource || null;
    }
};
exports.bin = {
    js: {},
    css: {},
    load: {},
    ajax: {},
    embed: {},
    mask: {}
};
function bin_removeDelegate(url) {
    // use timeout as sys-file-change event is called twice
    var timeout;
    return function () {
        if (timeout)
            clearTimeout(timeout);
        timeout = setTimeout(function () {
            bin_tryReload(url, function () {
                Config_1.cfg.autoreload && Config_1.cfg.autoreload.fileChanged(url, 'include');
            });
        }, 150);
    };
}
exports.bin_removeDelegate = bin_removeDelegate;
;
function bin_remove(url) {
    var x = find(exports.bin, url);
    if (x == null) {
        console.warn('<include:res:remove> Resource is not in cache', url);
        return null;
    }
    var type = x.type, id = x.id, resource = x.resource;
    if (resource == null) {
        return null;
    }
    if (global.io && global.io.File) {
        global.io.File.clearCache(resource.url);
    }
    exports.bin[type][id] = null;
    var roots = clearParents(exports.bin, resource);
    return {
        resource: resource,
        parents: roots
    };
}
exports.bin_remove = bin_remove;
;
function bin_tryReload(path, callback) {
    var result = bin_remove(path);
    if (result == null) {
        callback(false);
        return;
    }
    var resource = result.resource, parents = result.parents;
    if (parents == null || parents.length === 0) {
        callback(true);
        return;
    }
    var count = parents.length, imax = count, i = -1;
    while (++i < imax) {
        bin_load(resource, parents[i]).done(function () {
            if (--count === 0) {
                callback(true);
            }
        });
    }
}
exports.bin_tryReload = bin_tryReload;
// PRIVATE
function bin_load(resource, parent) {
    parent.exports = null;
    return parent
        .create(resource.type, resource.route, resource.namespace, resource.xpath)
        .resource
        .on(4, parent.childLoaded);
}
function normalize(url) {
    var id = path_1.path_normalize(url);
    var q = id.indexOf('?');
    if (q !== -1)
        id = id.substring(0, q);
    return id.toLowerCase();
}
function find(bins, url) {
    if (url == null) {
        return null;
    }
    url = normalize(url);
    for (var type in bins) {
        var x = findInType(bins, type, url);
        if (x != null) {
            return x;
        }
    }
    return null;
}
function findInType(bins, type, url) {
    if (url == null || type == null) {
        return null;
    }
    var bin = bins[type];
    if (url in bin) {
        return {
            type: type,
            id: url,
            resource: bin[url]
        };
    }
    url = normalize(url);
    for (var id in bin) {
        if (endsWith(id, url) || endsWith(url, id)) {
            var resource = bin[id];
            if (resource == null) {
                continue;
            }
            return {
                type: type,
                id: id,
                resource: resource
            };
        }
    }
}
function endsWith(str, end) {
    var sL = str.length;
    var eL = end.length;
    return sL >= eL && str.indexOf(end) === str.length - end.length;
}
function findParents(bins, resource) {
    var arr = [];
    for (var type in bins) {
        var bin_1 = bins[type];
        for (var id in bin_1) {
            var res = bin_1[id];
            if (res == null) {
                continue;
            }
            var children = res.includes;
            if (children == null) {
                continue;
            }
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.resource.url === resource.url) {
                    arr.push({ resource: res, id: id, type: type });
                    break;
                }
            }
        }
    }
    return arr;
}
function clearParents(bins, resource, roots, handled) {
    if (roots === void 0) { roots = []; }
    if (handled === void 0) { handled = []; }
    if (handled.indexOf(resource.url) > -1) {
        return roots;
    }
    var parents = findParents(bins, resource);
    if (parents.length === 0) {
        roots.push(resource);
        return roots;
    }
    parents.forEach(function (x) {
        bins[x.type][x.id] = null;
        handled.push(x.resource.url);
        clearParents(bins, x.resource, roots, handled);
    });
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_Bin) && isObject(module.exports)) {
		Object.assign(_src_Bin, module.exports);
		return;
	}
	_src_Bin = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Helper;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Config_1 = _src_Config;
var global_1 = _src_global;
exports.Helper = {
    reportError: function (e) {
        console.error('IncludeJS Error:', e, e.message, e.url);
        global_1.handler.onerror && global_1.handler.onerror(e);
    },
    XHR: function (resource, callback) {
        var xhr = new global_1.refs.XMLHttpRequest();
        xhr.onreadystatechange = function () {
            xhr.readyState === 4 && callback && callback(resource, xhr.responseText);
        };
        var url = typeof resource === 'object' ? resource.url : resource;
        var async = Config_1.cfg.sync === true ? false : true;
        if (global_1.isBrowser && Config_1.cfg.version) {
            url += (url.indexOf('?') === -1 ? '?' : '&') + 'v=' + Config_1.cfg.version;
        }
        if (url[0] === '/' && Config_1.cfg.lockedToFolder === true) {
            url = url.substring(1);
        }
        xhr.open('GET', url, async);
        xhr.send();
    },
    XHR_LOAD: function (url, callback) {
        var xhr = new global_1.refs.XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if (xhr.readyState !== 4) {
                return;
            }
            if (xhr.status !== 200) {
                callback(xhr.status);
                return;
            }
            callback(null, xhr.responseText);
        };
        xhr.open('GET', url, Config_1.cfg.sync === true ? false : true);
        xhr.send();
    }
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_Helper) && isObject(module.exports)) {
		Object.assign(_src_Helper, module.exports);
		return;
	}
	_src_Helper = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_ScriptStack;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Config_1 = _src_Config;
var Helper_1 = _src_Helper;
var global_1 = _src_global;
/** @TODO Refactor loadBy* {combine logic} */
var head, currentResource, stack = [], _cb_complete = [], _paused;
function loadScript(url, callback) {
    if (Config_1.cfg.version) {
        url += (url.indexOf('?') === -1 ? '?' : '&') + 'v=' + Config_1.cfg.version;
    }
    if (url[0] === '/' && Config_1.cfg.lockedToFolder === true) {
        url = url.substring(1);
    }
    var tag = document.createElement('script');
    tag.type = 'text/javascript';
    tag.src = url;
    if ('onreadystatechange' in tag) {
        tag.onreadystatechange = function () {
            (this.readyState === 'complete' || this.readyState === 'loaded') && callback();
        };
    }
    else {
        tag.onload = tag.onerror = callback;
    }
    if (head == null) {
        head = document.getElementsByTagName('head')[0];
    }
    head.appendChild(tag);
}
function loadByEmbedding() {
    if (_paused) {
        return;
    }
    if (stack.length === 0) {
        trigger_complete();
        return;
    }
    if (currentResource != null) {
        return;
    }
    var resource = (currentResource = stack[0]);
    if (resource.state === 1) {
        return;
    }
    resource.state = 1;
    global.include = resource;
    function resourceLoaded(e) {
        if (e === void 0) { e = null; }
        if (e && e.type === 'error') {
            console.log('Script Loaded Error', resource.url);
        }
        var i = 0, length = stack.length;
        for (; i < length; i++) {
            if (stack[i] === resource) {
                stack.splice(i, 1);
                break;
            }
        }
        if (i === length) {
            console.error('Loaded Resource not found in stack', resource);
            return;
        }
        if (resource.state !== 2.5)
            resource.readystatechanged(3);
        currentResource = null;
        loadByEmbedding();
    }
    if (resource.source) {
        global_1.refs.evaluate(resource.source, resource);
        resourceLoaded();
        return;
    }
    loadScript(resource.url, resourceLoaded);
}
function processByEval() {
    if (_paused) {
        return;
    }
    if (stack.length === 0) {
        trigger_complete();
        return;
    }
    if (currentResource != null) {
        return;
    }
    var resource = stack[0];
    if (resource.state < 2) {
        return;
    }
    currentResource = resource;
    currentResource.state = 1;
    global.include = resource;
    global_1.refs.evaluate(resource.source, resource);
    stackRemove(resource);
    if (resource.state !== 2.5) {
        resource.readystatechanged(3);
    }
    currentResource = null;
    processByEval();
}
function processByEvalSync() {
    if (_paused) {
        return;
    }
    if (stack.length === 0) {
        trigger_complete();
        return;
    }
    var resource = stack.shift();
    if (resource.state < 2) {
        return;
    }
    currentResource = resource;
    currentResource.state = 3;
    global.include = resource;
    global_1.refs.evaluate(resource.source, resource);
    resource.readystatechanged(3);
    currentResource = null;
    processByEvalSync();
}
function stackRemove(resource) {
    var imax = stack.length, i = -1;
    while (++i < imax) {
        if (stack[i] === resource) {
            stack.splice(i, 1);
            return;
        }
    }
}
function trigger_complete() {
    var i = -1, imax = _cb_complete.length;
    while (++i < imax) {
        _cb_complete[i]();
    }
    _cb_complete.length = 0;
}
exports.ScriptStack = {
    load: function (resource, parent, forceEmbed) {
        this.add(resource, parent);
        if (!Config_1.cfg.eval || forceEmbed) {
            loadByEmbedding();
            return;
        }
        // was already loaded, with custom loader for example
        if (resource.source) {
            resource.state = 2;
            processByEval();
            return;
        }
        Helper_1.Helper.XHR(resource, function (resource, response) {
            if (!response) {
                console.error('Not Loaded:', resource.url);
                console.error('- Initiator:', resource.parent && resource.parent.url || '<root resource>');
            }
            resource.source = response;
            resource.state = 2;
            if (Config_1.cfg.sync) {
                processByEvalSync();
                return;
            }
            processByEval();
        });
    },
    add: function (resource, parent) {
        if (resource.priority === 1)
            return stack.unshift(resource);
        if (parent == null)
            return stack.push(resource);
        var imax = stack.length, i = -1;
        // move close to parent
        while (++i < imax) {
            if (stack[i] === parent)
                return stack.splice(i, 0, resource);
        }
        // was still not added
        stack.push(resource);
    },
    /* Move resource in stack close to parent */
    moveToParent: function (resource, parent) {
        var length = stack.length, parentIndex = -1, resourceIndex = -1, i;
        for (i = 0; i < length; i++) {
            if (stack[i] === resource) {
                resourceIndex = i;
                break;
            }
        }
        if (resourceIndex === -1) {
            return;
        }
        for (i = 0; i < length; i++) {
            if (stack[i] === parent) {
                parentIndex = i;
                break;
            }
        }
        if (parentIndex === -1) {
            return;
        }
        if (resourceIndex < parentIndex) {
            return;
        }
        stack.splice(resourceIndex, 1);
        stack.splice(parentIndex, 0, resource);
    },
    pause: function () {
        _paused = true;
    },
    resume: function () {
        _paused = false;
        if (currentResource != null)
            return;
        this.touch();
    },
    touch: function () {
        var fn = Config_1.cfg.eval
            ? processByEval
            : loadByEmbedding;
        fn();
    },
    complete: function (callback) {
        if (_paused !== true && stack.length === 0) {
            callback();
            return;
        }
        _cb_complete.push(callback);
    }
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_ScriptStack) && isObject(module.exports)) {
		Object.assign(_src_ScriptStack, module.exports);
		return;
	}
	_src_ScriptStack = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Include;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Type_1 = _src_models_Type;
var IncludeDeferred_1 = _src_IncludeDeferred;
var global_1 = _src_global;
var Config_1 = _src_Config;
var Routing_1 = _src_Routing;
var Bin_1 = _src_Bin;
var path_1 = _src_utils_path;
var CustomLoader_1 = _src_CustomLoader;
var Helper_1 = _src_Helper;
var ScriptStack_1 = _src_ScriptStack;
var Resource_1 = _src_Resource;
var global_2 = _src_global;
var Include = /** @class */ (function (_super) {
    __extends(Include, _super);
    function Include() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isBrowser = global_1.isBrowser;
        _this.isNode = global_1.isNode;
        _this.isRoot = false;
        _this.Lib = global_1.IncludeLib;
        _this.bin_tryReload = Bin_1.bin_tryReload;
        _this.bin_remove = Bin_1.bin_remove;
        return _this;
    }
    Include.prototype.setCurrent = function (data) {
        var url = data.url, resource = this.getResourceById(url, 'js');
        if (resource == null) {
            if (url[0] === '/' && this.base)
                url = this.base + url.substring(1);
            resource = new Resource_1.Resource('js', { path: url }, data.namespace, null, null, url);
        }
        if (resource.state < 3) {
            console.error("<include> Resource should be loaded", data);
        }
        if (data.aliases) {
            data.aliases.forEach(function (alias) {
                Bin_1.Bin.add(Type_1.ResourceType.Js, alias, resource);
            });
        }
        /**@TODO - probably state shoulb be changed to 2 at this place */
        resource.state = 3;
        global_2.global.include = resource;
    };
    Include.prototype.cfg = function (a, b) {
        return Config_1.cfg.call(this, a, b);
    };
    Include.prototype.routes = function (mix) {
        if (mix == null) {
            return Routing_1.Routes.getRoutes();
        }
        if (arguments.length === 2) {
            Routing_1.Routes.register(mix, arguments[1], this);
            return this;
        }
        for (var key in mix) {
            Routing_1.Routes.register(key, mix[key], this);
        }
        return this;
    };
    Include.prototype.promise = function (namespace) {
        var arr = namespace.split('.'), obj = global_2.global;
        while (arr.length) {
            var key = arr.shift();
            obj = obj[key] || (obj[key] = {});
        }
        return obj;
    };
    /** @TODO - `id` property seems to be unsed and always equal to `url` */
    Include.prototype.register = function (_bin) {
        var base = this.base, key, info, infos, imax, i;
        function transform(info) {
            if (base == null)
                return info;
            if (info.url[0] === '/')
                info.url = base + info.url.substring(1);
            if (info.parent[0] === '/')
                info.parent = base + info.parent.substring(1);
            info.id = info.url;
            return info;
        }
        for (key in _bin) {
            infos = _bin[key];
            imax = infos.length;
            i = -1;
            while (++i < imax) {
                info = transform(infos[i]);
                var id = info.url, url = info.url, namespace = info.namespace, parent = info.parent && Bin_1.Bin.find(info.parent), resource = new Resource_1.Resource(), state = info.state;
                if (!(id || url))
                    continue;
                if (url) {
                    if (url[0] === '/') {
                        url = url.substring(1);
                    }
                    resource.location = path_1.path_getDir(url);
                }
                resource.state = state == null
                    ? (key === 'js' ? 3 : 4)
                    : state;
                resource.namespace = namespace;
                resource.type = key;
                resource.url = url || id;
                resource.parent = parent;
                resource.base = parent && parent.base || base;
                switch (key) {
                    case 'load':
                    case 'lazy':
                        var query = '[data-bundler-path="/' + url + '"]';
                        var bags = global_1.IncludeLib.loadBags, j = bags.length, el = null;
                        while (--j > -1 && el == null) {
                            if (bags[j] == null)
                                continue;
                            el = bags[j].querySelector(query);
                        }
                        if (el == null) {
                            console.error('"%s" Data was not embedded into html', id);
                            break;
                        }
                        resource.exports = el.innerHTML;
                        if (CustomLoader_1.CustomLoader.exists(resource)) {
                            resource.state = 3;
                            CustomLoader_1.CustomLoader.load(resource, CustomLoader_onComplete);
                        }
                        break;
                }
                Bin_1.Bin.add(key, id, resource);
            }
        }
        function CustomLoader_onComplete(resource, response) {
            resource.exports = response;
            resource.readystatechanged(4);
        }
    };
    /**
     *    Create new Resource Instance,
     *    as sometimes it is necessary to call include. on new empty context
     */
    Include.prototype.instance = function (url, parent) {
        return Include.instance(url, parent);
    };
    Include.instance = function (url, parent) {
        var resource;
        if (url == null) {
            resource = new Include();
            resource.isRoot = true;
            resource.state = 4;
            return resource;
        }
        resource = new Resource_1.Resource('js');
        resource.state = 4;
        resource.url = path_1.path_resolveUrl(url, parent);
        resource.location = path_1.path_getDir(resource.url);
        resource.parent = parent;
        resource.isRoot = true;
        return resource;
    };
    Include.prototype.noConflict = function () {
        global_2.noConflict();
    };
    Include.prototype.getResource = function (url, type) {
        if (this.base && url[0] === '/')
            url = this.base + url.substring(1);
        return this.getResourceById(url, type);
    };
    Include.prototype.getResourceById = function (url, type) {
        var _res = Bin_1.Bin.get(type, url);
        if (_res != null)
            return _res;
        if (this.base && url[0] === '/') {
            _res = Bin_1.Bin.get(type, path_1.path_combine(this.base, url));
            if (_res != null)
                return _res;
        }
        if (this.base && this.location) {
            _res = Bin_1.Bin.get(type, path_1.path_combine(this.base, this.location, url));
            if (_res != null)
                return _res;
        }
        if (this.location) {
            _res = Bin_1.Bin.get(null, path_1.path_combine(this.location, url));
            if (_res != null)
                return _res;
        }
        return null;
    };
    Include.prototype.getResources = function () {
        return Bin_1.bin;
    };
    Include.prototype.removeFromCache = function (path) {
        Bin_1.Bin.remove(path);
    };
    Include.prototype.plugin = function (pckg, callback) {
        var urls = [], length = 0, j = 0, i = 0, onload = function (url, response) {
            j++;
            embedPlugin(response);
            if (j === length - 1 && callback) {
                callback();
                callback = null;
            }
        };
        Routing_1.Routes.each(null, pckg, function (namespace, route) {
            urls.push(route.path[0] === '/' ? route.path.substring(1) : route.path);
        });
        length = urls.length;
        for (; i < length; i++) {
            Helper_1.Helper.XHR(urls[i], onload);
        }
        return this;
    };
    Include.prototype.client = function () {
        if (Config_1.cfg.server === true)
            stub_freeze(this);
        return this;
    };
    Include.prototype.server = function () {
        if (Config_1.cfg.server !== true)
            stub_freeze(this);
        return this;
    };
    Include.prototype.use = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.parent == null) {
            console.error('<include.use> Parent resource is undefined');
            return this;
        }
        this._usage = args;
        return this;
    };
    Include.prototype.pauseStack = function () {
        return ScriptStack_1.ScriptStack.pause();
    };
    Include.prototype.resumeStack = function () {
        return ScriptStack_1.ScriptStack.resume();
    };
    Include.prototype.allDone = function (callback) {
        ScriptStack_1.ScriptStack.complete(function () {
            var pending = include.getPending(), await_ = pending.length;
            if (await_ === 0) {
                callback();
                return;
            }
            var i = -1, imax = await_;
            while (++i < imax) {
                pending[i].on(4, check, null, 'push');
            }
            function check() {
                if (--await_ < 1)
                    callback();
            }
        });
    };
    Include.prototype.getPending = function (type) {
        var resources = [], res, key, id;
        for (key in Bin_1.bin) {
            if (key === 'all' || (type != null && type !== key))
                continue;
            for (id in Bin_1.bin[key]) {
                res = Bin_1.bin[key][id];
                if (res.state < 4)
                    resources.push(res);
            }
        }
        return resources;
    };
    Include.prototype.js = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).js.apply(_a, args);
    };
    Include.prototype.inject = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).inject.apply(_a, args);
    };
    Include.prototype.css = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).css.apply(_a, args);
    };
    Include.prototype.load = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).load.apply(_a, args);
    };
    Include.prototype.ajax = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).ajax.apply(_a, args);
    };
    Include.prototype.embed = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).embed.apply(_a, args);
    };
    Include.prototype.lazy = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).lazy.apply(_a, args);
    };
    Include.prototype.mask = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).mask.apply(_a, args);
    };
    return Include;
}(IncludeDeferred_1.IncludeDeferred));
exports.Include = Include;
;
// >> FUNCTIONS
function embedPlugin(source) {
    eval(source);
}
function doNothing() {
    return this;
}
function stub_freeze(include) {
    include.js =
        include.css =
            include.load =
                include.ajax =
                    include.embed =
                        include.lazy =
                            include.inject =
                                include.mask = doNothing;
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_Include) && isObject(module.exports)) {
		Object.assign(_src_Include, module.exports);
		return;
	}
	_src_Include = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_PathResolver;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = _src_utils_path;
var Helper_1 = _src_Helper;
var Type_1 = _src_models_Type;
var Routing_1 = _src_Routing;
exports.PathResolver = {
    configMap: function (map) {
        for (var key in map) {
            _map[key] = map[key];
        }
    },
    configExt: function (config) {
        var def = config.def;
        var types = config.types;
        for (var key_1 in def) {
            _ext[key_1] = def[key_1];
        }
        for (var key in types) {
            _extTypes[key] = types[key];
        }
    },
    resolveBasic: function (path_, type, parent) {
        if (type === 'js' && isNodeModuleResolution(path_)) {
            return path_;
        }
        var path = map(path_);
        if (path[0] === '@') {
            var i = path.indexOf('/');
            var namespace = path.substring(0, i);
            var template = path.substring(i + 1);
            var info = Routing_1.Routes.resolve(namespace, template);
            path = info.path;
        }
        path = path_1.path_resolveUrl(path, parent);
        return ensureExtension(path, type);
    },
    isNpm: isNodeModuleResolution,
    getType: getTypeForPath,
    resolveNpm: function (path_, type, parent, cb) {
        var path = map(path_);
        if (path.indexOf('.') > -1) {
            cb(null, path);
            return;
        }
        if (type === 'js') {
            if (isNodeModuleResolution(path)) {
                var parentsPath = parent && parent.location;
                if (!parentsPath || parentsPath === '/') {
                    parentsPath = path_1.path_resolveCurrent();
                }
                nodeModuleResolve(parentsPath, path, cb);
                return;
            }
        }
        if (hasExt(path) === false) {
            path += '.' + _ext[type];
        }
        cb(null, path);
    },
    isNodeNative: function (path) {
        return _nodeBuiltIns.indexOf(path) !== -1;
    }
};
var _map = {};
var _ext = {
    'js': 'js',
    'css': 'css',
    'mask': 'mask'
};
var _extTypes = {
    'js': Type_1.ResourceType.Js,
    'es6': Type_1.ResourceType.Js,
    'ts': Type_1.ResourceType.Js,
    'css': Type_1.ResourceType.Css,
    'less': Type_1.ResourceType.Css,
    'scss': Type_1.ResourceType.Css,
    'mask': Type_1.ResourceType.Mask,
    'json': Type_1.ResourceType.Load,
    'yml': Type_1.ResourceType.Load
};
var _nodeBuiltIns = [
    "assert",
    "async_hooks",
    "buffer",
    "child_process",
    "cluster",
    "console",
    "constants",
    "crypto",
    "dgram",
    "dns",
    "domain",
    "events",
    "fs",
    "http",
    "http2",
    "https",
    "inspector",
    "module",
    "net",
    "os",
    "path",
    "perf_hooks",
    "process",
    "punycode",
    "querystring",
    "readline",
    "repl",
    "stream",
    "string_decoder",
    "timers",
    "tls",
    "tty",
    "url",
    "util",
    "v8",
    "vm",
    "zlib"
];
function map(path) {
    return _map[path] || path;
}
function hasExt(path) {
    return /\.[\w]{1,8}($|\?|#)/.test(path);
}
function isNodeModuleResolution(path) {
    var isNpm = /^(@?[\w\-]+)(\/[\w\-_]+)*$/.test(path);
    if (isNpm === false) {
        return false;
    }
    if (path[0] !== '@') {
        return true;
    }
    var namespace = path.substring(0, path.indexOf('/'));
    return Routing_1.Routes.routes[namespace] == null;
}
function nodeModuleResolve(current_, path, cb) {
    var name = /^(@?[\w\-]+)/.exec(path)[0];
    var resource = path.substring(name.length + 1);
    if (resource && hasExt(resource) === false) {
        resource += '.js';
    }
    var current = current_.replace(/[^\/]+\.[\w]{1,8}$/, '');
    function check() {
        var dir = path_1.path_combine(current, '/node_modules/', name, '/');
        var filename = dir + 'package.json';
        Helper_1.Helper.XHR_LOAD(filename, function (error, text) {
            var json;
            if (text) {
                if (typeof text === 'string') {
                    try {
                        json = JSON.parse(text);
                    }
                    catch (error) { }
                }
                else {
                    json = text;
                }
            }
            if (error != null || json == null) {
                var next = current.replace(/[^\/]+\/?$/, '');
                if (next === current) {
                    cb('Not found');
                    return;
                }
                current = next;
                check();
                return;
            }
            if (resource) {
                cb(null, path_1.path_combine(dir, resource));
                return;
            }
            if (json.main) {
                combineMain(dir, json.main, cb);
                return;
            }
            cb(null, dir + 'index.js');
        });
    }
    check();
}
function ensureExtension(path, type) {
    if (hasExt(path)) {
        return path;
    }
    var ext = _ext[type];
    if (ext == null) {
        console.warn('Extension is not defined for ' + type);
        return path;
    }
    var i = path.indexOf('?');
    if (i === -1)
        return path + '.' + ext;
    return path.substring(0, i) + '.' + ext + path.substring(i);
}
function getTypeForPath(path) {
    var match = /\.([\w]{1,8})($|\?|:)/.exec(path);
    if (match === null) {
        return _extTypes.js;
    }
    var ext = match[1];
    var type = _extTypes[ext];
    return type || Type_1.ResourceType.Load;
}
function combineMain(dir, fileName, cb) {
    var path = path_1.path_combine(dir, fileName);
    if (hasExt(path)) {
        cb(null, path);
        return;
    }
    var url = path + '.js';
    Helper_1.Helper.XHR_LOAD(url, function (error, text) {
        if (error == null) {
            cb(null, url);
            return;
        }
        url = path + '/index.js';
        Helper_1.Helper.XHR_LOAD(url, function (error, text) {
            if (error == null) {
                cb(null, url);
                return;
            }
            cb('Entry File does not exist: ' + fileName + ' in ' + dir);
        });
    });
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_PathResolver) && isObject(module.exports)) {
		Object.assign(_src_PathResolver, module.exports);
		return;
	}
	_src_PathResolver = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_res;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PathResolver_1 = _src_PathResolver;
function res_groupByType(arr) {
    var pckg = {}, imax = arr.length, i = -1;
    while (++i < imax) {
        var path = arr[i];
        var type = PathResolver_1.PathResolver.getType(path);
        append(pckg, type, path);
    }
    return pckg;
}
exports.res_groupByType = res_groupByType;
;
function append(pckg, type, path) {
    var arr = pckg[type];
    if (arr == null) {
        arr = pckg[type] = [];
    }
    arr.push(path);
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_res) && isObject(module.exports)) {
		Object.assign(_src_utils_res, module.exports);
		return;
	}
	_src_utils_res = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_LazyModule;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Helper_1 = _src_Helper;
var Resource_1 = _src_Resource;
var global_1 = _src_global;
exports.LazyModule = {
    create: function (xpath, code) {
        console.log('WARN: LazyModule is obsolete');
        var arr = xpath.split('.'), obj = global, module = arr[arr.length - 1];
        while (arr.length > 1) {
            var prop = arr.shift();
            obj = obj[prop] || (obj[prop] = {});
        }
        arr = null;
        Object.defineProperty(obj, module, {
            get: function () {
                delete obj[module];
                try {
                    var r = global_1.refs.evaluate(code, global.include);
                    if (!(r == null || r instanceof Resource_1.Resource)) {
                        obj[module] = r;
                    }
                }
                catch (error) {
                    error.xpath = xpath;
                    Helper_1.Helper.reportError(error);
                }
                finally {
                    code = null;
                    xpath = null;
                    return obj[module];
                }
            }
        });
    }
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_LazyModule) && isObject(module.exports)) {
		Object.assign(_src_LazyModule, module.exports);
		return;
	}
	_src_LazyModule = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Resource;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = _src_global;
var Include_1 = _src_Include;
var Bin_1 = _src_Bin;
var path_1 = _src_utils_path;
var PathResolver_1 = _src_PathResolver;
var ScriptStack_1 = _src_ScriptStack;
var global_2 = _src_global;
var res_1 = _src_utils_res;
var Routing_1 = _src_Routing;
var CustomLoader_1 = _src_CustomLoader;
var Helper_1 = _src_Helper;
var LazyModule_1 = _src_LazyModule;
var Type_1 = _src_models_Type;
var Config_1 = _src_Config;
var Resource = /** @class */ (function (_super) {
    __extends(Resource, _super);
    function Resource(type, route, namespace, xpath, parent, id, priority) {
        if (type === void 0) { type = null; }
        if (route === void 0) { route = null; }
        if (namespace === void 0) { namespace = null; }
        if (xpath === void 0) { xpath = null; }
        if (parent === void 0) { parent = null; }
        if (id === void 0) { id = null; }
        if (priority === void 0) { priority = null; }
        var _this = _super.call(this) || this;
        var url = route && route.path;
        if (url != null) {
            url = path_1.path_normalize(url);
            url = PathResolver_1.PathResolver.resolveBasic(url, type, parent);
        }
        if (id == null && url) {
            id = url;
        }
        var resource = Bin_1.Bin.get(type, id);
        var isOfOtherType = false;
        if (resource) {
            if (type === 'js' && resource.state < 4) {
                ScriptStack_1.ScriptStack.moveToParent(resource, parent);
            }
            isOfOtherType = type != null && resource.type === 'load' && type !== 'load';
            if (isOfOtherType === false) {
                return resource;
            }
        }
        _this.id = id;
        _this.url = url;
        _this.type = type;
        _this.xpath = xpath;
        _this.route = route;
        _this.parent = parent;
        _this.priority = priority;
        _this.namespace = namespace;
        _this.base = parent && parent.base;
        _this.childLoaded = _this.childLoaded.bind(_this);
        _this.response = {};
        _this.exports = {};
        if (type == null) {
            _this.state = 3;
            return _this;
        }
        if (url == null) {
            _this.state = 3;
            _this.url = path_1.path_resolveCurrent();
            _this.location = path_1.path_getDir(_this.url);
            return _this;
        }
        _this.state = 0;
        _this.location = path_1.path_getDir(url);
        Bin_1.Bin.add(type, id, _this);
        if (isOfOtherType) {
            onXHRCompleted(_this, resource.exports);
        }
        var isNpm = PathResolver_1.PathResolver.isNpm(_this.url);
        if (isNpm && global_2.isNode) {
            var before = global_1.global.include;
            global_1.global.include = _this;
            _this.exports = global_2.__require.nativeRequire(_this.url);
            if (before != null && global_1.global.include === _this) {
                global_1.global.include = before;
            }
            _this.readystatechanged(4);
            return _this;
        }
        if (isNpm === false) {
            process(_this);
            return _this;
        }
        PathResolver_1.PathResolver.resolveNpm(_this.url, _this.type, _this.parent, function (error, url) {
            if (error) {
                _this.readystatechanged(4);
                return;
            }
            _this.url = url;
            _this.location = path_1.path_getDir(url);
            process(_this);
        });
        return _this;
    }
    Resource.prototype.setBase = function (baseUrl) {
        this.base = baseUrl;
        return this;
    };
    Resource.prototype.hasPendingChildren = function () {
        var arr = this.includes;
        if (arr == null) {
            return false;
        }
        var imax = arr.length, i = -1;
        while (++i < imax) {
            if (arr[i].isCyclic) {
                continue;
            }
            if (arr[i].resource.state !== 4) {
                return true;
            }
        }
        return false;
    };
    Resource.prototype.childLoaded = function (child) {
        var includes = this.includes;
        if (includes && includes.length) {
            if (this.state < 3) {
                // resource still loading/include is in process, but one of sub resources are already done
                return;
            }
            for (var i = 0; i < includes.length; i++) {
                var data = includes[i];
                if (data.isCyclic) {
                    continue;
                }
                if (data.resource.state !== 4) {
                    return;
                }
            }
        }
        this.readystatechanged(4);
    };
    Resource.prototype.create = function (type, route, namespace, xpath, id) {
        if (route === void 0) { route = null; }
        if (namespace === void 0) { namespace = null; }
        if (xpath === void 0) { xpath = null; }
        if (id === void 0) { id = null; }
        this.state = this.state >= 3
            ? 3
            : 2;
        if (this.includes == null) {
            this.includes = [];
        }
        var resource = new Resource(type, route, namespace, xpath, this, id);
        var isLazy = false;
        if (this.url && Config_1.cfg.lazy) {
            outer: for (var str in Config_1.cfg.lazy) {
                var rgx = new RegExp(str);
                if (rgx.test(this.url)) {
                    var paths = Config_1.cfg.lazy[str];
                    for (var i = 0; i < paths.length; i++) {
                        var rgxPath = new RegExp(paths[i]);
                        if (rgxPath.test(resource.url)) {
                            isLazy = true;
                            break outer;
                        }
                    }
                }
            }
        }
        var data = {
            resource: resource,
            route: route,
            isCyclic: isLazy || resource.contains(this.url),
            isLazy: isLazy
        };
        this.includes.push(data);
        return data;
    };
    Resource.prototype.include = function (type, pckg) {
        var _this = this;
        var children = [], child;
        Routing_1.Routes.each(type, pckg, function (namespace, route, xpath) {
            if (_this.route != null && _this.route.path === route.path) {
                // loading itself
                return;
            }
            child = _this.create(type, route, namespace, xpath);
            children.push(child);
        });
        var i = -1, imax = children.length;
        while (++i < imax) {
            var x = children[i];
            if (x.isCyclic) {
                this.childLoaded(x.resource);
                continue;
            }
            x.resource.on(4, this.childLoaded);
        }
        return this;
    };
    Resource.prototype.require = function (arr) {
        if (this.exports == null) {
            this.exports = {};
        }
        this.includes = [];
        var pckg = res_1.res_groupByType(arr);
        for (var key in pckg) {
            this.include(key, pckg[key]);
        }
        return this;
    };
    Resource.prototype.pause = function () {
        this.state = 2.5;
        var that = this;
        return function (exports) {
            if (arguments.length === 1)
                that.exports = exports;
            that.readystatechanged(3);
        };
    };
    Resource.prototype.contains = function (url, stack, refCache) {
        if (stack === void 0) { stack = []; }
        if (refCache === void 0) { refCache = {}; }
        refCache[this.url] = this;
        var arr = this.includes;
        if (arr == null) {
            return false;
        }
        stack = __spreadArrays(stack, [this]);
        for (var i = 0; i < arr.length; i++) {
            if (arr[i].isLazy) {
                continue;
            }
            if (arr[i].resource.url in refCache) {
                continue;
            }
            if (arr[i].resource.url === url) {
                if (Config_1.cfg.logCyclic) {
                    var req = stack[0].url;
                    var chain = stack.slice(1).map(function (x, i) { return i + " \u2192 " + x.url; }).join('\n');
                    var isDirect = stack.length <= 1;
                    var message = "Caution: " + (isDirect ? 'Direct ' : '') + " cyclic dependency detected. In " + url + " was " + req + " imported.";
                    if (isDirect === false) {
                        message += " The loop chain is: " + chain;
                    }
                    console.log(message);
                }
                return true;
            }
            if (arr[i].resource.contains(url, stack, refCache)) {
                return true;
            }
        }
        return false;
    };
    Resource.prototype.getNestedOfType = function (type) {
        return resource_getChildren(this.includes, type);
    };
    Resource.prototype.js = function () {
        var pckg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pckg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Js, PackageExtract(pckg));
    };
    Resource.prototype.inject = function () {
        var pckg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pckg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Js, PackageExtract(pckg));
    };
    Resource.prototype.css = function () {
        var pckg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pckg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Css, PackageExtract(pckg));
    };
    Resource.prototype.load = function () {
        var pckg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pckg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Load, PackageExtract(pckg));
    };
    Resource.prototype.ajax = function () {
        var pckg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pckg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Ajax, PackageExtract(pckg));
    };
    Resource.prototype.embed = function () {
        var pckg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pckg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Embed, PackageExtract(pckg));
    };
    Resource.prototype.lazy = function () {
        var pckg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pckg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Lazy, PackageExtract(pckg));
    };
    Resource.prototype.mask = function () {
        var pckg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pckg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Mask, PackageExtract(pckg));
    };
    return Resource;
}(Include_1.Include));
exports.Resource = Resource;
;
function PackageExtract(pckg) {
    if (pckg.length > 1)
        return pckg;
    if (Array.isArray(pckg[0]))
        return pckg[0];
    return pckg;
}
// private
function process(resource) {
    var type = resource.type, parent = resource.parent, url = resource.url;
    if (document == null && type === 'css') {
        resource.state = 4;
        return resource;
    }
    if (CustomLoader_1.CustomLoader.exists(resource)) {
        if ('js' === type || 'embed' === type) {
            ScriptStack_1.ScriptStack.add(resource, resource.parent);
        }
        CustomLoader_1.CustomLoader.load(resource, onXHRCompleted);
        return resource;
    }
    switch (type) {
        case 'js':
        case 'embed':
            ScriptStack_1.ScriptStack.load(resource, parent, type === 'embed');
            break;
        case 'ajax':
        case 'load':
        case 'lazy':
        case 'mask':
            Helper_1.Helper.XHR(resource, onXHRCompleted);
            break;
        case 'css':
            resource.state = 4;
            var tag = document.createElement('link');
            tag.href = url;
            tag.rel = "stylesheet";
            tag.type = "text/css";
            document.body.appendChild(tag);
            break;
    }
    return resource;
}
function onXHRCompleted(resource, response) {
    if (!response) {
        console.warn('Resource can`t be loaded', resource.url);
        //- resource.readystatechanged(4);
        //- return;
    }
    switch (resource.type) {
        case 'js':
        case 'embed':
            resource.source = response;
            resource.state = 2;
            ScriptStack_1.ScriptStack.touch();
            return;
        case 'load':
        case 'ajax':
        case 'mask':
            resource.exports = response;
            break;
        case 'lazy':
            LazyModule_1.LazyModule.create(resource.xpath, response);
            break;
        case 'css':
            var tag = document.createElement('style');
            tag.type = "text/css";
            tag.innerHTML = response;
            document.getElementsByTagName('head')[0].appendChild(tag);
            break;
        // case 'mask':
        //     if (response) {
        //         var mask = global.mask;
        //         if (mask == null) {
        //             mask = global.require('maskjs');
        //         }
        //         mask
        //             .Module
        //             .registerModule(response, { path: resource.url })
        //             .done(function (module) {
        //                 resource.exports = module.exports;
        //                 resource.readystatechanged(4);
        //             })
        //             .fail(function (error) {
        //                 console.error(error);
        //                 resource.readystatechanged(4);
        //             });
        //         return;
        //     }
        //     break;
    }
    resource.readystatechanged(4);
}
function resource_getChildren(includes, type, out) {
    if (out === void 0) { out = []; }
    if (includes == null)
        return null;
    var imax = includes.length, i = -1, x;
    while (++i < imax) {
        x = includes[i].resource;
        if (type === x.type)
            out.push(x);
        if (x.includes != null)
            resource_getChildren(x.includes, type, out);
    }
    return out;
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_Resource) && isObject(module.exports)) {
		Object.assign(_src_Resource, module.exports);
		return;
	}
	_src_Resource = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_CustomLoader;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = _src_utils_path;
var Resource_1 = _src_Resource;
var Routing_1 = _src_Routing;
var Helper_1 = _src_Helper;
var cfg = null;
function inject(cfg_) {
    cfg = cfg_;
}
exports.inject = inject;
;
function loader_isInstance(x) {
    if (typeof x === 'string')
        return false;
    return typeof x.ready === 'function' || typeof x.process === 'function';
}
function createLoader(url) {
    var extension = path_1.path_getExtension(url), loader = cfg.loader[extension];
    if (loader_isInstance(loader)) {
        return loader;
    }
    var path = loader, namespace;
    if (typeof path === 'object') {
        // is route {namespace: path}
        for (var key in path) {
            namespace = key;
            path = path[key];
            break;
        }
    }
    return (cfg.loader[extension] = new Resource_1.Resource('js', Routing_1.Routes.resolve(namespace, path), namespace, null, null, null, 1));
}
function loader_completeDelegate(callback, resource) {
    return function (response) {
        callback(resource, response);
    };
}
function loader_process(source, resource, loader, callback) {
    if (loader.process == null) {
        callback(resource, source);
        return;
    }
    var delegate = loader_completeDelegate(callback, resource), syncResponse = loader.process(source, resource, delegate);
    // match also null
    if (typeof syncResponse !== 'undefined') {
        callback(resource, syncResponse);
    }
}
function tryLoad(resource, loader, callback) {
    if (typeof resource.exports === 'string') {
        loader_process(resource.exports, resource, loader, callback);
        return;
    }
    function onLoad(resource, response) {
        loader_process(response, resource, loader, callback);
    }
    if (loader.load)
        return loader.load(resource, onLoad);
    Helper_1.Helper.XHR(resource, onLoad);
}
exports.CustomLoader = {
    load: function (resource, callback) {
        var loader = createLoader(resource.url);
        if (loader.process) {
            tryLoad(resource, loader, callback);
            return;
        }
        loader.on(4, function () {
            tryLoad(resource, loader.exports, callback);
        }, null, 'push');
    },
    exists: function (resource) {
        if (!resource.url) {
            return false;
        }
        var ext = path_1.path_getExtension(resource.url);
        var loader = cfg.loader[ext];
        if (loader == null) {
            return false;
        }
        if (loader.supports && loader.supports(resource) === false) {
            return false;
        }
        return true;
    },
    /**
     *	IHandler:
     *	{ process: function(content) { return _handler(content); }; }
     *
     *	Url:
     *	 path to IHandler
     */
    register: function (extension, handler) {
        if (typeof handler === 'string') {
            var resource = include;
            if (resource.location == null) {
                resource = {
                    location: path_1.path_getDir(path_1.path_resolveCurrent())
                };
            }
            handler = path_1.path_resolveUrl(handler, resource);
        }
        cfg.loader[extension] = handler;
    }
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_CustomLoader) && isObject(module.exports)) {
		Object.assign(_src_CustomLoader, module.exports);
		return;
	}
	_src_CustomLoader = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_modules_common;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = _src_global;
var Config_1 = _src_Config;
exports.CommonJS = {
    exports: null,
    require: function commonjs(path) {
        if (path.charCodeAt(0) !== 46 && global_1.__require.nativeRequire != null) {
            // .
            return global_1.__require.nativeRequire(path);
        }
        var currentSync = Config_1.cfg.sync;
        var currentEval = Config_1.cfg.eval;
        var currentInclude = include;
        var exports = null;
        Config_1.cfg.sync = true;
        Config_1.cfg.eval = true;
        include.js(path + '::Module').done(function (resp) {
            exports = resp.Module;
        });
        include = currentInclude;
        Config_1.cfg.sync = currentSync;
        Config_1.cfg.eval = currentEval;
        return exports;
    },
    enable: function () {
        // if (typeof __require.nativeRequire === 'function') {
        // 	return;
        // }
        enableExports();
        enableRequire();
    }
};
function enableRequire() {
    global_1.global.require = exports.CommonJS.require;
}
function enableExports() {
    if (global_1.global.module != null) {
        return;
    }
    if (typeof Object.defineProperty === 'undefined') {
        console.warn('Browser do not support Object.defineProperty');
        return;
    }
    Object.defineProperty(global_1.global, 'module', {
        get: function () {
            return global_1.global.include;
        },
        configurable: true
    });
    Object.defineProperty(global_1.global, 'exports', {
        get: function () {
            var current = global_1.global.include;
            return (current.exports || (current.exports = {}));
        },
        set: function (exports) {
            global_1.global.include.exports = exports;
        },
        configurable: true
    });
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_modules_common) && isObject(module.exports)) {
		Object.assign(_src_modules_common, module.exports);
		return;
	}
	_src_modules_common = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_modules_amd;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Bin_1 = _src_Bin;
var common_1 = _src_modules_common;
var global_1 = _src_global;
var Resource_1 = _src_Resource;
exports.Amd = {
    enable: function () {
        enable();
    },
};
function enable() {
    var define = (global_1.global.define = function (a, b, c) {
        var i = arguments.length, args = new Array(i);
        while (--i > -1)
            args[i] = arguments[i];
        var fn = getFn(patterns, args);
        var module = global_1.global.include;
        fn(module, a, b, c);
    });
    if (global_1.isBrowser) {
        define.amd = true;
    }
    var __includeRequire = (global_1.global.require = global_1.__require.includeRequire = function amd() {
        if (global_1.isNode && global_1.__require.nativeRequire && arguments.length === 1) {
            return global_1.__require.nativeRequire.apply(null, arguments);
        }
        return define.apply(null, arguments);
    });
    if (typeof require !== 'undefined') {
        require = __includeRequire;
    }
}
var patterns = [
    [
        [isExports],
        function (module, exports) {
            define(module, null, null, exports);
        },
    ],
    [
        [isString, isExports],
        function (module, name, exports) {
            define(module, name, null, exports);
        },
    ],
    [
        [isString, isArray, isExports],
        function (module, name, dependencies, exports) {
            define(module, name, dependencies, exports);
        },
    ],
    [
        [isArray, isExports],
        function (module, dependencies, exports) {
            define(module, null, dependencies, exports);
        },
    ],
];
function getFn(patterns, args) {
    var i = -1, imax = patterns.length;
    outer: while (++i < imax) {
        var pattern = patterns[i][0];
        if (pattern.length !== args.length) {
            continue;
        }
        var j = -1, jmax = pattern.length;
        while (++j < jmax) {
            var matcher = pattern[j];
            if (matcher(args[j]) === false) {
                continue outer;
            }
        }
        return patterns[i][1];
    }
    console.warn('Define function arguments are invalid', args);
    return emptyFn;
}
function emptyFn() { }
function define(module, name, dependencies, exports) {
    if (name != null) {
        Bin_1.bin.js[name] = module;
    }
    if (dependencies == null) {
        module.exports = getExports(exports) || module.exports;
        return;
    }
    var deps = getDepsInfo(dependencies, module);
    var arr = deps.array;
    var linked = deps.linked;
    if (linked.length === 0) {
        module.exports = getExports(exports, arr) || module.exports;
        return;
    }
    if (module.require == null) {
        module = new Resource_1.Resource();
    }
    module.require(deps.linked).done(function (resp) {
        readResp(arr, resp);
        module.exports = getExports(exports, arr) || module.exports;
    });
}
function getExports(mix, args) {
    if (args === void 0) { args = []; }
    if (typeof mix === 'function') {
        return mix.apply(null, args);
    }
    return mix;
}
function getDepsInfo(deps, module) {
    var array = new Array(deps.length), linked = [], imax = deps.length, i = -1;
    while (++i < imax) {
        var fn = StaticResolvers[deps[i]];
        if (fn == null) {
            linked.push(deps[i] + '::' + i);
            continue;
        }
        array[i] = fn(module);
    }
    return { array: array, linked: linked };
}
var StaticResolvers = {
    module: function (module) {
        return module;
    },
    exports: function (module) {
        return module.exports || (module.exports = {});
    },
    require: function (module) {
        return common_1.CommonJS.require;
    },
};
function isString(x) {
    return typeof x === 'string';
}
function isExports(x) {
    return true;
}
function isArray(x) {
    return x instanceof Array;
}
function enableExports() {
    if (typeof Object.defineProperty === 'undefined') {
        console.warn('Browser do not support Object.defineProperty');
        return;
    }
    Object.defineProperty(global_1.global, 'module', {
        get: function () {
            return global_1.global.include;
        },
    });
    Object.defineProperty(global_1.global, 'exports', {
        get: function () {
            var current = global_1.global.include;
            return current.exports || (current.exports = {});
        },
        set: function (exports) {
            global_1.global.include.exports = exports;
        },
    });
}
function readResp(arr, resp) {
    var digit = /^\d+$/;
    for (var key in resp) {
        var val = resp[key];
        if (val == null) {
            continue;
        }
        if (key === 'load' || key === 'ajax') {
            readResp(arr, val);
            continue;
        }
        arr[+key] = val;
    }
}
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_modules_amd) && isObject(module.exports)) {
		Object.assign(_src_modules_amd, module.exports);
		return;
	}
	_src_modules_amd = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_loader_json;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONParser = {
    process: function (source, res) {
        try {
            return JSON.parse(source);
        }
        catch (error) {
            console.error(error, source);
            return null;
        }
    }
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_loader_json) && isObject(module.exports)) {
		Object.assign(_src_loader_json, module.exports);
		return;
	}
	_src_loader_json = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_loader_load;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = _src_global;
exports.LoadBundleParser = {
    process: function (source, res) {
        var div = document.createElement('div');
        div.innerHTML = source;
        global_1.loadBags.push(div);
        return source;
    }
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_loader_load) && isObject(module.exports)) {
		Object.assign(_src_loader_load, module.exports);
		return;
	}
	_src_loader_load = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_loader_mask;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = _src_global;
exports.MaskLoader = {
    supports: function (resource) {
        return resource.type === 'mask';
    },
    process: function (response, resource, onComplete) {
        var mask = global_1.global.mask;
        if (mask == null) {
            mask = global_1.global.require('maskjs');
        }
        mask
            .Module
            .registerModule(response, { path: resource.url })
            .done(function (module) {
            onComplete(module.exports);
        })
            .fail(function (error) {
            console.error(error);
            onComplete(null);
        });
    }
};
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_loader_mask) && isObject(module.exports)) {
		Object.assign(_src_loader_mask, module.exports);
		return;
	}
	_src_loader_mask = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Config;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = _src_global;
var CustomLoader_1 = _src_CustomLoader;
var PathResolver_1 = _src_PathResolver;
var common_1 = _src_modules_common;
var amd_1 = _src_modules_amd;
var json_1 = _src_loader_json;
var load_1 = _src_loader_load;
var mask_1 = _src_loader_mask;
var Routing_1 = _src_Routing;
/**
 *	path = root path. @default current working path, im browser window.location;
 *	eval = in node.js this conf. is forced
 *	lockedToFolder = makes current url as root path
 *		Example "/script/main.js" within this window.location "{domain}/apps/1.html"
 *		will become "{domain}/apps/script/main.js" instead of "{domain}/script/main.js"
*/
var isFileProtocol = global_1.document && global_1.document.location && global_1.document.location.protocol === 'file:';
var Config = /** @class */ (function () {
    function Config() {
        this.path = '';
        this.base = null;
        this.loader = {
            //#if (!NODE)
            'json': json_1.JSONParser,
            //#endif
            'load': load_1.LoadBundleParser,
            'mask': mask_1.MaskLoader,
        };
        this.version = null;
        this.lockedToFolder = isFileProtocol;
        this.sync = false;
        this.eval = global_1.document == null;
        this.es6Exports = false;
        this.server = false;
        this.logCyclic = false;
        this.autoreload = null;
        this.lazy = null;
    }
    Config.prototype.call = function (ctx, a, b) {
        if (a == null) {
            return this;
        }
        var aType = typeof a;
        var bType = typeof b;
        if (aType === 'string' && b == null) {
            return this[a];
        }
        if (aType === 'string' && b != null) {
            set(this, a, b);
            return ctx;
        }
        if (aType === 'object' && b == null) {
            for (var key in a) {
                set(this, key, a[key]);
            }
        }
        return ctx;
    };
    return Config;
}());
exports.Config = Config;
;
function set(cfg, key, value) {
    switch (key) {
        case 'loader':
            for (var x in value) {
                CustomLoader_1.CustomLoader.register(x, value[x]);
            }
            return;
        case 'modules':
            if (value === true)
                enableModules();
            return;
        case 'commonjs':
            if (value === true)
                common_1.CommonJS.enable();
            return;
        case 'amd':
            if (value === true)
                amd_1.Amd.enable();
            return;
        case 'map':
            PathResolver_1.PathResolver.configMap(value);
            return;
        case 'extentionDefault':
            PathResolver_1.PathResolver.configExt({ def: value });
            return;
        case 'extentionTypes':
            PathResolver_1.PathResolver.configExt({ types: value });
            return;
        case 'routes':
            for (var pfx in value) {
                Routing_1.Routes.register(pfx, value[pfx]);
            }
            return;
    }
    if ((key in cfg) === false) {
        console.warn('Not supported config', key);
    }
    cfg[key] = value;
}
function enableModules() {
    if (typeof Object.defineProperty === 'undefined') {
        console.warn('Browser do not support Object.defineProperty');
        return;
    }
    Object.defineProperty(global, 'module', {
        get: function () {
            return global.include;
        }
    });
    Object.defineProperty(global, 'exports', {
        get: function () {
            var current = global.include;
            return (current.exports || (current.exports = {}));
        },
        set: function (exports) {
            global.include.exports = exports;
        }
    });
}
var cfg = new Config;
exports.cfg = cfg;
CustomLoader_1.inject(cfg);
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_Config) && isObject(module.exports)) {
		Object.assign(_src_Config, module.exports);
		return;
	}
	_src_Config = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_path;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Config_1 = _src_Config;
var global_1 = _src_global;
var reg_hasProtocol = /^[\w\-]{2,}:\/\//i;
function path_getDir(path) {
    return path.substring(0, path.lastIndexOf('/') + 1);
}
exports.path_getDir = path_getDir;
function path_getFile(path) {
    path = path
        .replace('file://', '')
        .replace(/\\/g, '/')
        .replace(/\?[^\n]+$/, '');
    if (/^\/\w+:\/[^\/]/i.test(path)) {
        // win32 drive
        return path.substring(1);
    }
    return path;
}
exports.path_getFile = path_getFile;
function path_getExtension(path) {
    var query = path.indexOf('?');
    if (query === -1) {
        return path.substring(path.lastIndexOf('.') + 1);
    }
    return path.substring(path.lastIndexOf('.', query) + 1, query);
}
exports.path_getExtension = path_getExtension;
function path_resolveBase() {
    var doc = global_1.document;
    var origin = global_1.document.location.origin;
    var path = Config_1.cfg.base || '/';
    if (Config_1.cfg.lockedToFolder) {
        path = doc.location.pathname;
    }
    return path_combine(origin, path, '/');
}
exports.path_resolveBase = path_resolveBase;
function path_resolveCurrent() {
    if (global_1.document == null) {
        return global_1.global.module == null ? '' : path_win32Normalize(process.cwd() + '/');
    }
    var scripts = global_1.document.getElementsByTagName('script'), last = scripts[scripts.length - 1], url = (last && last.getAttribute('src')) || '';
    if (url[0] === '/') {
        return url;
    }
    var location = window.location.pathname.replace(/\/[^\/]+\.\w+$/, '');
    if (location[location.length - 1] !== '/') {
        location += '/';
    }
    return location + url;
}
exports.path_resolveCurrent = path_resolveCurrent;
function path_normalize(path) {
    var path_ = path
        .replace(/\\/g, '/')
        // remove double slashes, but not near protocol
        .replace(/([^:\/])\/{2,}/g, '$1/');
    // use triple slashes by file protocol
    if (/^file:\/\/[^\/]/.test(path_)) {
        path_ = path_.replace('file://', 'file:///');
    }
    return path_;
}
exports.path_normalize = path_normalize;
function path_win32Normalize(path) {
    path = path_normalize(path);
    if (path.substring(0, 5) === 'file:') {
        return path;
    }
    return path_combine('file:///', path);
}
exports.path_win32Normalize = path_win32Normalize;
function path_toLocalFile(path) {
    return path;
}
exports.path_toLocalFile = path_toLocalFile;
function path_resolveUrl(url, parent) {
    url = path_normalize(url);
    if (reg_hasProtocol.test(url)) {
        return Path.collapse(url);
    }
    if (url.substring(0, 2) === './') {
        url = url.substring(2);
    }
    if (url[0] === '/' && parent != null && parent.base != null) {
        url = path_combine(parent.base, url);
        if (reg_hasProtocol.test(url)) {
            return Path.collapse(url);
        }
    }
    if (url[0] === '/' && Config_1.cfg.path && url.indexOf(Config_1.cfg.path) !== 0) {
        url = path_combine(Config_1.cfg.path, url);
        if (reg_hasProtocol.test(url)) {
            return Path.collapse(url);
        }
    }
    if (url[0] !== '/') {
        if (parent != null && parent.location != null) {
            url = path_combine(parent.location, url);
        }
        else {
            var current = path_resolveCurrent();
            var dir = path_getDir(current);
            url = path_combine(dir, url);
        }
    }
    if (url[0] !== '/' && reg_hasProtocol.test(url) === false) {
        url = '/' + url;
    }
    return Path.collapse(url);
}
exports.path_resolveUrl = path_resolveUrl;
function path_isRelative(path) {
    var c = path.charCodeAt(0);
    switch (c) {
        case 46: /* . */
            return true;
        case 47:
            // /
            return false;
    }
    return reg_hasProtocol.test(path) === false;
}
exports.path_isRelative = path_isRelative;
function path_combine() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var out = '', imax = args.length, i = -1, x;
    while (++i < imax) {
        x = args[i];
        if (!x)
            continue;
        x = path_normalize(x);
        if (out === '') {
            out = x;
            continue;
        }
        if (out[out.length - 1] !== '/')
            out += '/';
        if (x[0] === '/')
            x = x.substring(1);
        out += x;
    }
    return out;
}
exports.path_combine = path_combine;
var Path;
(function (Path) {
    var rgx_host = /^\w+:\/\/[^\/]+\//;
    var rgx_subFolder = /\/?([^\/]+\/)\.\.\//;
    var rgx_dottedFolder = /\/\.\.\//;
    function collapse(url) {
        var host = rgx_host.exec(url);
        if (host) {
            url = url.replace(host[0], '');
        }
        var path = url;
        do {
            url = path;
            path = path.replace(rgx_subFolder, '/');
        } while (path !== url);
        //#if (BROWSER)
        if (global_1.isBrowser) {
            do {
                url = path;
                path = path.replace(rgx_dottedFolder, '/');
            } while (path !== url);
        }
        //#endif
        path = path.replace(/\/\.\//g, '/');
        if (host) {
            return host[0] + path;
        }
        return path;
    }
    Path.collapse = collapse;
})(Path || (Path = {}));
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_path) && isObject(module.exports)) {
		Object.assign(_src_utils_path, module.exports);
		return;
	}
	_src_utils_path = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Routing;
(function () {
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = _src_utils_path;
var RoutesCtor = /** @class */ (function () {
    function RoutesCtor() {
        this.routes = {};
    }
    /**
     *    @param route {String} = Example: '.reference/libjs/{0}/{1}.js'
     */
    RoutesCtor.prototype.register = function (namespace, route) {
        if (typeof route === 'string') {
            if (path_1.path_isRelative(route)) {
                var location = path_1.path_getDir(path_1.path_resolveCurrent());
                if (path_1.path_isRelative(location)) {
                    location = '/' + location;
                }
                route = location + route;
            }
            if (route[0] === '/') {
                var base = path_1.path_resolveBase();
                route = path_1.path_combine(base, route);
            }
        }
        this.routes[namespace] = route instanceof Array
            ? route
            : route.split(/[\{\}]/g);
    };
    /**
     *    @param {String} template = Example: 'scroller/scroller.min?ui=black'
     */
    RoutesCtor.prototype.resolve = function (namespace, template) {
        var questionMark = template.indexOf('?'), aliasIndex = template.indexOf('::'), alias, query = '';
        if (aliasIndex !== -1) {
            alias = template.substring(aliasIndex + 2);
            template = template.substring(0, aliasIndex);
        }
        if (questionMark !== -1) {
            query = template.substring(questionMark);
            template = template.substring(0, questionMark);
        }
        var slugs = template.split('/');
        var route = this.routes[namespace];
        if (route == null) {
            return {
                path: slugs.join('/') + query,
                params: null,
                alias: alias
            };
        }
        var path = route[0];
        for (var i = 1; i < route.length; i++) {
            if (i % 2 === 0) {
                path += route[i];
            }
            else {
                /** if template provides less "breadcrumbs" than needed -
                 * take always the last one for failed peaces */
                var index = parseFloat(route[i]);
                if (index > slugs.length - 1) {
                    index = slugs.length - 1;
                }
                path += slugs[index];
                if (i === route.length - 2) {
                    for (index++; index < slugs.length; index++) {
                        path += '/' + slugs[index];
                    }
                }
            }
        }
        return {
            path: path + query,
            params: null,
            alias: alias
        };
    };
    /**
     *    @arg includeData :
     *    1. string - URL to resource
     *    2. array - URLs to resources
     *    3. object - {route: x} - route defines the route template to resource,
     *        it must be set before in include.cfg.
     *        example:
     *            include.cfg('net','scripts/net/{name}.js')
     *            include.js({net: 'downloader'}) // -> will load scipts/net/downloader.js
     *    @arg namespace - route in case of resource url template, or namespace in case of LazyModule
     *
     *    @arg fn - callback function, which receives namespace|route, url to resource and ?id in case of not relative url
     *    @arg xpath - xpath string of a lazy object 'object.sub.and.othersub';
     */
    RoutesCtor.prototype.each = function (type, includeData, fn, namespace, xpath) {
        if (includeData == null) {
            return;
        }
        if (type === 'lazy' && xpath == null) {
            var obj = includeData;
            for (var key_1 in obj) {
                this.each(type, obj[key_1], fn, null, key_1);
            }
            return;
        }
        if (includeData instanceof Array) {
            for (var i = 0; i < includeData.length; i++) {
                this.each(type, includeData[i], fn, namespace, xpath);
            }
            return;
        }
        if (typeof includeData === 'object') {
            for (var key in includeData) {
                this.each(type, includeData[key], fn, key, xpath);
            }
            return;
        }
        if (typeof includeData === 'string') {
            var x = this.resolve(namespace, includeData);
            if (namespace) {
                namespace += '.' + includeData;
            }
            fn(namespace, x, xpath);
            return;
        }
        console.error('Include Package is invalid', arguments);
    };
    RoutesCtor.prototype.getRoutes = function () {
        return this.routes;
    };
    RoutesCtor.prototype.parseAlias = function (route) {
        var path = route.path, result = regexpAlias.exec(path);
        return result && result[1];
    };
    return RoutesCtor;
}());
exports.RoutesCtor = RoutesCtor;
exports.Routes = new RoutesCtor();
function RoutesLib() {
    return new RoutesCtor();
}
exports.RoutesLib = RoutesLib;
;
var regexpAlias = /([^\\\/]+)\.\w+$/;
;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_Routing) && isObject(module.exports)) {
		Object.assign(_src_Routing, module.exports);
		return;
	}
	_src_Routing = module.exports;
}());
// end:source ./ModuleSimplified.js

"use strict";
_src_global;
var Routing_1 = _src_Routing;
var Resource_1 = _src_Resource;
var ScriptStack_1 = _src_ScriptStack;
var PathResolver_1 = _src_PathResolver;
var CustomLoader_1 = _src_CustomLoader;
var Include_1 = _src_Include;
var Config_1 = _src_Config;
var IncludeLib = {
    Routes: Routing_1.RoutesLib,
    Resource: Resource_1.Resource,
    ScriptStack: ScriptStack_1.ScriptStack,
    PathResolver: PathResolver_1.PathResolver,
    Config: Config_1.Config,
    registerLoader: CustomLoader_1.CustomLoader.register,
    instance: Include_1.Include.instance
};
module.exports = {
    include: new Include_1.Include,
    includeLib: IncludeLib
};


}));
// end:source ./umd/umd.js


/*!
 * MaskJS v0.71.78
 * Part of the Atma.js Project
 * http://atmajs.com/
 *
 * MIT license
 * http://opensource.org/licenses/MIT
 *
 * (c) 2012, 2020 Atma.js and other contributors
 */
(function(root, factory) {
  'use strict';
  var _env = 'undefined' === typeof window || null == window.navigator ? 'node' : 'dom';
  var _global = 'dom' === _env ? window : global;
  var _isCommonJs = 'undefined' !== typeof exports && (null == root || root === exports || root === _global);
  if (_isCommonJs) {
    root = exports;
  }
  var _exports = root || _global;
  var _document = _global.document;
  function construct() {
    var mask = factory(_global, _exports, _document);
    if (_isCommonJs) {
      module.exports = mask;
    }
    return mask;
  }
  if ('function' === typeof define && define.amd) {
    return define(construct);
  }
  // Browser OR Node
    return construct();
})(this, function(global, exports, document) {
  'use strict';
  var fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, arr_remove, arr_each, arr_contains, arr_pushMany, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, ModuleMidd, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, __rgxEscapedChar, expression_getHost, expression_bind, obj_addObserver, obj_removeObserver, expression_createListener, expression_createBinder, expression_callFn, expression_unbind, obj_addObserver, obj_hasObserver, obj_removeObserver, obj_lockObservers, obj_unlockObservers, obj_addMutatorObserver, obj_removeMutatorObserver, expression_bind, expression_unbind, expression_callFn, expression_createBinder, expression_createListener, expression_getHost, arr_remove, arr_each, arr_contains, arr_pushMany, prop_OBS, prop_MUTATORS, prop_TIMEOUT, prop_DIRTY, prop_PROXY, obj_defineProp, obj_ensureFieldDeep, obj_ensureObserversProperty, obj_getObserversProperty, obj_ensureRebindersProperty, obj_chainToProp, objMutator_addObserver, objMutator_removeObserver, getSelfMutators, obj_defineCrumbs, obj_sub_notifyListeners, obj_deep_notifyListeners, obj_callMethod, coll_each, coll_indexOf, coll_remove, coll_map, coll_find, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, env_class_overrideArgs, env_class_wrapCtors, arr_remove, arr_each, arr_contains, arr_pushMany, compo_addChild, compo_addChildren, compo_renderElements, compo_emitInserted, coll_each, coll_indexOf, coll_remove, coll_map, coll_find, __rgxEscapedChar, __rgxEscapedChar, arr_remove, arr_each, arr_contains, arr_pushMany, coll_each, coll_indexOf, coll_remove, coll_map, coll_find, coll_each, coll_indexOf, coll_remove, coll_map, coll_find, arr_remove, arr_each, arr_contains, arr_pushMany, coll_each, coll_indexOf, coll_remove, coll_map, coll_find, arr_remove, arr_each, arr_contains, arr_pushMany, arr_remove, arr_each, arr_contains, arr_pushMany, attr_first, attr_first, Methods, defMethods_getSource, defMethods_compile, nodeMethod_getSource, nodeMethod_compile, sourceUrl_get, _args_toCode, scopeRefs_getImportVars, sourceUrl_get, _args_toCode, scopeRefs_getImportVars, env_class_overrideArgs, env_class_wrapCtors, Define, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, Methods, coll_each, coll_indexOf, coll_remove, coll_map, coll_find, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, Define, ModuleMidd, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, coll_each, coll_indexOf, coll_remove, coll_map, coll_find, compo_addChild, compo_addChildren, compo_renderElements, compo_emitInserted, arr_remove, arr_each, arr_contains, arr_pushMany, arr_remove, arr_each, arr_contains, arr_pushMany, arr_remove, arr_each, arr_contains, arr_pushMany, expression_getHost, expression_bind, obj_addObserver, obj_removeObserver, expression_createListener, expression_createBinder, expression_callFn, expression_unbind, coll_each, coll_indexOf, coll_remove, coll_map, coll_find, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, compo_addChild, compo_addChildren, compo_renderElements, compo_emitInserted, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, arr_remove, arr_each, arr_contains, arr_pushMany, arr_remove, arr_each, arr_contains, arr_pushMany, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, arr_remove, arr_each, arr_contains, arr_pushMany, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, compo_addChild, compo_addChildren, compo_renderElements, compo_emitInserted, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, compo_addChild, compo_addChildren, compo_renderElements, compo_emitInserted, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern;
  var _Array_slice, _Array_splice, _Array_indexOf, _Object_hasOwnProp, _Object_getOwnProp, _Object_defineProperty, _global, _document;
  (function() {
    _Array_slice = Array.prototype.slice;
    _Array_splice = Array.prototype.splice;
    _Array_indexOf = Array.prototype.indexOf;
    _Object_hasOwnProp = Object.hasOwnProperty;
    _Object_getOwnProp = Object.getOwnPropertyDescriptor;
    _Object_defineProperty = Object.defineProperty;
    _global = 'undefined' !== typeof global ? global : window;
    _document = 'undefined' !== typeof window && null != window.document ? window.document : null;
  })();
  var is_Function, is_Object, is_Array, is_ArrayLike, is_String, is_rawObject, is_Date, is_PromiseLike, is_Observable, is_DOM, is_NODE;
  (function() {
    is_Function = function(x) {
      return 'function' === typeof x;
    };
    is_Object = function(x) {
      return null != x && 'object' === typeof x;
    };
    is_Array = function(arr) {
      return null != arr && 'object' === typeof arr && 'number' === typeof arr.length && 'function' === typeof arr.slice;
    };
    is_ArrayLike = is_Array;
    is_String = function(x) {
      return 'string' === typeof x;
    };
    is_rawObject = function(x) {
      return null != x && 'object' === typeof x && x.constructor === Object;
    };
    is_Date = function(x) {
      if (null == x || 'object' !== typeof x) {
        return false;
      }
      if (null != x.getFullYear && false === isNaN(x)) {
        return true;
      }
      return false;
    };
    is_PromiseLike = function(x) {
      return null != x && 'object' === typeof x && 'function' === typeof x.then;
    };
    is_Observable = function(x) {
      return null != x && 'object' === typeof x && 'function' === typeof x.subscribe;
    };
    is_DOM = 'undefined' !== typeof window && null != window.navigator;
    is_NODE = !is_DOM;
  })();
  var class_Dfr;
  (function() {
    (function() {
      fn_proxy = function(fn, ctx) {
        return function() {
          var imax = arguments.length, args = new Array(imax), i = 0;
          for (;i < imax; i++) {
            args[i] = arguments[i];
          }
          return fn_apply(fn, ctx, args);
        };
      };
      fn_apply = function(fn, ctx, args) {
        var l = args.length;
        if (0 === l) {
          return fn.call(ctx);
        }
        if (1 === l) {
          return fn.call(ctx, args[0]);
        }
        if (2 === l) {
          return fn.call(ctx, args[0], args[1]);
        }
        if (3 === l) {
          return fn.call(ctx, args[0], args[1], args[2]);
        }
        if (4 === l) {
          return fn.call(ctx, args[0], args[1], args[2], args[3]);
        }
        return fn.apply(ctx, args);
      };
      fn_doNothing = function() {
        return false;
      };
      fn_createByPattern = function(definitions, ctx) {
        var imax = definitions.length;
        return function() {
          var def, l = arguments.length, i = -1;
          outer: while (++i < imax) {
            def = definitions[i];
            if (def.pattern.length !== l) {
              continue;
            }
            var j = -1;
            while (++j < l) {
              var fn = def.pattern[j];
              var val = arguments[j];
              if (false === fn(val)) {
                continue outer;
              }
            }
            return def.handler.apply(ctx, arguments);
          }
          console.error('InvalidArgumentException for a function', definitions, arguments);
          return null;
        };
      };
    })();
    class_Dfr = function() {};
    class_Dfr.prototype = {
      _isAsync: true,
      _done: null,
      _fail: null,
      _always: null,
      _resolved: null,
      _rejected: null,
      defer: function() {
        this._rejected = null;
        this._resolved = null;
        return this;
      },
      isResolved: function() {
        return null != this._resolved;
      },
      isRejected: function() {
        return null != this._rejected;
      },
      isBusy: function() {
        return null == this._resolved && null == this._rejected;
      },
      resolve: function() {
        var done = this._done, always = this._always;
        this._resolved = arguments;
        dfr_clearListeners(this);
        arr_callOnce(done, this, arguments);
        arr_callOnce(always, this, [ this ]);
        return this;
      },
      reject: function() {
        var fail = this._fail, always = this._always;
        this._rejected = arguments;
        dfr_clearListeners(this);
        arr_callOnce(fail, this, arguments);
        arr_callOnce(always, this, [ this ]);
        return this;
      },
      then: function(filterSuccess, filterError) {
        return this.pipe(filterSuccess, filterError);
      },
      done: function(callback) {
        if (null != this._rejected) {
          return this;
        }
        return dfr_bind(this, this._resolved, this._done || (this._done = []), callback);
      },
      fail: function(callback) {
        if (null != this._resolved) {
          return this;
        }
        return dfr_bind(this, this._rejected, this._fail || (this._fail = []), callback);
      },
      always: function(callback) {
        return dfr_bind(this, this._rejected || this._resolved, this._always || (this._always = []), callback);
      },
      pipe: function(mix /* ..methods */) {
        var dfr;
        if ('function' === typeof mix) {
          dfr = new class_Dfr();
          var done_ = mix, fail_ = arguments.length > 1 ? arguments[1] : null;
          this.done(delegate(dfr, 'resolve', done_)).fail(delegate(dfr, 'reject', fail_));
          return dfr;
        }
        dfr = mix;
        var x, imax = arguments.length, done = 1 === imax, fail = 1 === imax, i = 0;
        while (++i < imax) {
          x = arguments[i];
          switch (x) {
           case 'done':
            done = true;
            break;

           case 'fail':
            fail = true;
            break;

           default:
            console.error('Unsupported pipe channel', arguments[i]);
            break;
          }
        }
        done && this.done(delegate(dfr, 'resolve'));
        fail && this.fail(delegate(dfr, 'reject'));
        function delegate(dfr, name, fn) {
          return function() {
            if (null != fn) {
              var override = fn.apply(this, arguments);
              if (null != override && override !== dfr) {
                if (isDeferred(override)) {
                  override.then(delegate(dfr, 'resolve'), delegate(dfr, 'reject'));
                  return;
                }
                dfr[name](override);
                return;
              }
            }
            dfr[name].apply(dfr, arguments);
          };
        }
        return this;
      },
      pipeCallback: function() {
        var self = this;
        return function(error) {
          if (null != error) {
            self.reject(error);
            return;
          }
          var args = _Array_slice.call(arguments, 1);
          fn_apply(self.resolve, self, args);
        };
      },
      resolveDelegate: function() {
        return fn_proxy(this.resolve, this);
      },
      rejectDelegate: function() {
        return fn_proxy(this.reject, this);
      },
      catch: function(cb) {
        return this.fail(cb);
      },
      finally: function(cb) {
        return this.always(cb);
      }
    };
    var static_Dfr = {
      resolve: function(a, b, c) {
        var dfr = new class_Dfr();
        return dfr.resolve.apply(dfr, _Array_slice.call(arguments));
      },
      reject: function(error) {
        var dfr = new class_Dfr();
        return dfr.reject(error);
      },
      run: function(fn, ctx) {
        var dfr = new class_Dfr();
        if (null == ctx) {
          ctx = dfr;
        }
        fn.call(ctx, fn_proxy(dfr.resolve, ctx), fn_proxy(dfr.reject, dfr), dfr);
        return dfr;
      },
      all: function(promises) {
        var dfr = new class_Dfr(), arr = new Array(promises.length), wait = promises.length, error = null;
        if (0 === wait) {
          return dfr.resolve(arr);
        }
        function tick(index) {
          if (null != error) {
            return;
          }
          var args = _Array_slice.call(arguments, 1);
          arr.splice.apply(arr, [ index, 0 ].concat(args));
          if (0 === --wait) {
            dfr.resolve(arr);
          }
        }
        function onReject(err) {
          dfr.reject(error = err);
        }
        var imax = promises.length, i = -1;
        while (++i < imax) {
          var x = promises[i];
          if (null == x || null == x.then) {
            tick(i);
            continue;
          }
          x.then(tick.bind(null, i), onReject);
        }
        return dfr;
      }
    };
    class_Dfr.resolve = static_Dfr.resolve;
    class_Dfr.reject = static_Dfr.reject;
    class_Dfr.run = static_Dfr.run;
    class_Dfr.all = static_Dfr.all;
    // PRIVATE
        function dfr_bind(dfr, arguments_, listeners, callback) {
      if (null == callback) {
        return dfr;
      }
      if (null != arguments_) {
        fn_apply(callback, dfr, arguments_);
      } else {
        listeners.push(callback);
      }
      return dfr;
    }
    function dfr_clearListeners(dfr) {
      dfr._done = null;
      dfr._fail = null;
      dfr._always = null;
    }
    function arr_callOnce(arr, ctx, args) {
      if (null == arr) {
        return;
      }
      var fn, imax = arr.length, i = -1;
      while (++i < imax) {
        fn = arr[i];
        if (fn) {
          fn_apply(fn, ctx, args);
        }
      }
      arr.length = 0;
    }
    function isDeferred(x) {
      return null != x && 'object' === typeof x && is_Function(x.then);
    }
  })();
  var obj_getProperty, obj_setProperty, obj_hasProperty, obj_defineProperty, obj_extend, obj_extendDefaults, obj_extendPropertiesDefaults, obj_extendMany, obj_toFastProps, _Object_create, obj_create;
  (function() {
    var getDescriptor = Object.getOwnPropertyDescriptor;
    var defineDescriptor = Object.defineProperty;
    var obj_copyProperty = null == getDescriptor ? function(target, source, key) {
      return target[key] = source[key];
    } : function(target, source, key) {
      var descr = getDescriptor(source, key);
      if (null == descr) {
        target[key] = source[key];
        return;
      }
      if (void 0 !== descr.value) {
        target[key] = descr.value;
        return;
      }
      defineDescriptor(target, key, descr);
    };
    obj_copyProperty;
    obj_getProperty = function(obj_, path) {
      if (null == obj_) {
        return null;
      }
      if (-1 === path.indexOf('.')) {
        return obj_[path];
      }
      var obj = obj_, chain = path.split('.'), imax = chain.length, i = -1;
      while (null != obj && ++i < imax) {
        var key = chain[i];
        if (63 /*?*/ === key.charCodeAt(key.length - 1)) {
          key = key.slice(0, -1);
        }
        obj = obj[key];
      }
      return obj;
    };
    obj_setProperty = function(obj_, path, val) {
      if (-1 === path.indexOf('.')) {
        obj_[path] = val;
        return;
      }
      var key, obj = obj_, chain = path.split('.'), imax = chain.length - 1, i = -1;
      while (++i < imax) {
        key = chain[i];
        if (63 /*?*/ === key.charCodeAt(key.length - 1)) {
          key = key.slice(0, -1);
        }
        var x = obj[key];
        if (null == x) {
          x = obj[key] = {};
        }
        obj = x;
      }
      obj[chain[i]] = val;
    };
    obj_hasProperty = function(obj, path) {
      var x = obj_getProperty(obj, path);
      return void 0 !== x;
    };
    obj_defineProperty = function(obj, path, dscr) {
      var key, x = obj, chain = path.split('.'), imax = chain.length - 1, i = -1;
      while (++i < imax) {
        key = chain[i];
        if (null == x[key]) {
          x[key] = {};
        }
        x = x[key];
      }
      key = chain[imax];
      if (_Object_defineProperty) {
        if (void 0 === dscr.writable) {
          dscr.writable = true;
        }
        if (void 0 === dscr.configurable) {
          dscr.configurable = true;
        }
        if (void 0 === dscr.enumerable) {
          dscr.enumerable = true;
        }
        _Object_defineProperty(x, key, dscr);
        return;
      }
      x[key] = void 0 === dscr.value ? dscr.value : dscr.get && dscr.get();
    };
    obj_extend = function(a, b) {
      if (null == b) {
        return a || {};
      }
      if (null == a) {
        return obj_create(b);
      }
      for (var key in b) {
        a[key] = b[key];
      }
      return a;
    };
    obj_extendDefaults = function(a, b) {
      if (null == b) {
        return a || {};
      }
      if (null == a) {
        return obj_create(b);
      }
      for (var key in b) {
        if (null == a[key]) {
          a[key] = b[key];
          continue;
        }
        if ('toString' === key && a[key] === Object.prototype.toString) {
          a[key] = b[key];
        }
      }
      return a;
    };
    var extendPropertiesFactory = function(overwriteProps) {
      if (null == _Object_getOwnProp) {
        return overwriteProps ? obj_extend : obj_extendDefaults;
      }
      return function(a, b) {
        if (null == b) {
          return a || {};
        }
        if (null == a) {
          return obj_create(b);
        }
        var key, descr, ownDescr;
        for (key in b) {
          descr = _Object_getOwnProp(b, key);
          if (null == descr) {
            continue;
          }
          if (true !== overwriteProps) {
            ownDescr = _Object_getOwnProp(a, key);
            if (null != ownDescr) {
              continue;
            }
          }
          if (descr.hasOwnProperty('value')) {
            a[key] = descr.value;
            continue;
          }
          _Object_defineProperty(a, key, descr);
        }
        return a;
      };
    };
    var obj_extendProperties = extendPropertiesFactory(true);
    obj_extendPropertiesDefaults = extendPropertiesFactory(false);
    obj_extendMany = function(a, arg1, arg2, arg3, arg4, arg5, arg6) {
      var imax = arguments.length, i = 1;
      for (;i < imax; i++) {
        a = obj_extend(a, arguments[i]);
      }
      return a;
    };
    obj_toFastProps = function(obj) {
      /*jshint -W027*/
      function F() {}
      F.prototype = obj;
      new F();
      return;
    };
    _Object_create = Object.create || function(x) {
      var Ctor = function() {};
      Ctor.prototype = x;
      return new Ctor();
    };
    obj_create = _Object_create;
    function obj_defaults(target, defaults) {
      for (var key in defaults) {
        if (null == target[key]) {
          target[key] = defaults[key];
        }
      }
      return target;
    }
    var obj_extendDescriptors;
    var obj_extendDescriptorsDefaults;
    (function() {
      if (null == getDescriptor) {
        obj_extendDescriptors = obj_extend;
        obj_extendDescriptorsDefaults = obj_defaults;
        return;
      }
      obj_extendDescriptors = function(target, source) {
        return _extendDescriptors(target, source, false);
      };
      obj_extendDescriptorsDefaults = function(target, source) {
        return _extendDescriptors(target, source, true);
      };
      function _extendDescriptors(target, source, defaultsOnly) {
        if (null == target) {
          return {};
        }
        if (null == source) {
          return source;
        }
        var descr, key;
        for (key in source) {
          if (true === defaultsOnly && null != target[key]) {
            continue;
          }
          descr = getDescriptor(source, key);
          if (null == descr) {
            obj_extendDescriptors(target, source['__proto__']);
            continue;
          }
          if (void 0 !== descr.value) {
            target[key] = descr.value;
            continue;
          }
          defineDescriptor(target, key, descr);
        }
        return target;
      }
    })();
    obj_extendDescriptors, obj_extendDescriptorsDefaults;
  })();
  var str_format, str_dedent;
  (function() {
    str_format = function(str_, a, b, c, d) {
      var x, imax = arguments.length, i = 0;
      while (++i < imax) {
        x = arguments[i];
        if (is_Object(x) && x.toJSON) {
          x = x.toJSON();
        }
        str_ = str_.replace(rgxNum(i - 1), String(x));
      }
      return str_;
    };
    str_dedent = function(str) {
      var rgx = /^[\t ]*\S/gm, match = rgx.exec(str), count = -1;
      while (null != match) {
        var x = match[0].length;
        if (-1 === count || x < count) {
          count = x;
        }
        match = rgx.exec(str);
      }
      if (--count < 1) {
        return str;
      }
      var replacer = new RegExp('^[\\t ]{1,' + count + '}', 'gm');
      return str.replace(replacer, '').replace(/^[\t ]*\r?\n/, '').replace(/\r?\n[\t ]*$/, '');
    };
    var rgxNum;
    (function() {
      rgxNum = function(num) {
        return cache_[num] || (cache_[num] = new RegExp('\\{' + num + '\\}', 'g'));
      };
      var cache_ = {};
    })();
  })();
  var class_create;
  (function() {
    /**
		 * create([...Base], Proto)
		 * Base: Function | Object
		 * Proto: Object {
		 *    constructor: ?Function
		 *    ...
		 */
    class_create = createClassFactory(obj_extendDefaults);
    // with property accessor functions support
        createClassFactory(obj_extendPropertiesDefaults);
    function createClassFactory(extendDefaultsFn) {
      return function(a, b, c, d, e, f, g, h) {
        var args = _Array_slice.call(arguments), Proto = args.pop();
        if (null == Proto) {
          Proto = {};
        }
        var Ctor;
        if (Proto.hasOwnProperty('constructor')) {
          Ctor = Proto.constructor;
          if (void 0 === Ctor.prototype) {
            var es6Method = Ctor;
            Ctor = function ClassCtor() {
              var imax = arguments.length, i = -1, args = new Array(imax);
              while (++i < imax) {
                args[i] = arguments[i];
              }
              return es6Method.apply(this, args);
            };
          }
        } else {
          Ctor = function ClassCtor() {};
        }
        var BaseCtor, x, i = args.length;
        while (--i > -1) {
          x = args[i];
          if ('function' === typeof x) {
            BaseCtor = wrapFn(x, BaseCtor);
            x = x.prototype;
          }
          extendDefaultsFn(Proto, x);
        }
        return createClass(wrapFn(BaseCtor, Ctor), Proto);
      };
    }
    function createClass(Ctor, Proto) {
      Proto.constructor = Ctor;
      Ctor.prototype = Proto;
      return Ctor;
    }
    function wrapFn(fnA, fnB) {
      if (null == fnA) {
        return fnB;
      }
      if (null == fnB) {
        return fnA;
      }
      return function() {
        var args = _Array_slice.call(arguments);
        var x = fnA.apply(this, args);
        if (void 0 !== x) {
          return x;
        }
        return fnB.apply(this, args);
      };
    }
  })();
  var error_createClass, error_formatSource;
  (function() {
    error_createClass = function(name, Proto, stackSliceFrom) {
      var Ctor = _createCtor(Proto, stackSliceFrom);
      Ctor.prototype = new Error();
      Proto.constructor = Error;
      Proto.name = name;
      obj_extend(Ctor.prototype, Proto);
      return Ctor;
    };
    error_formatSource = function(source, index, filename) {
      var cursor = error_cursor(source, index), lines = cursor[0], lineNum = cursor[1], rowNum = cursor[2], str = '';
      if (null != filename) {
        str += str_format(' at {0}:{1}:{2}\n', filename, lineNum, rowNum);
      }
      return str + error_formatCursor(lines, lineNum, rowNum);
    };
    /**
		 * @returns [ lines, lineNum, rowNum ]
		 */    function error_cursor(str, index) {
      var lines = str.substring(0, index).split('\n'), line = lines.length, row = index + 1 - lines.slice(0, line - 1).join('\n').length;
      if (line > 1) {
        // remove trailing newline
        row -= 1;
      }
      return [ str.split('\n'), line, row ];
    }
    function error_formatCursor(lines, lineNum, rowNum) {
      var BEFORE = 3, AFTER = 2, i = lineNum - BEFORE, imax = i + BEFORE + AFTER, str = '';
      if (i < 0) {
        i = 0;
      }
      if (imax > lines.length) {
        imax = lines.length;
      }
      var lineNumber, lineNumberLength = String(imax).length;
      for (;i < imax; i++) {
        if (str) {
          str += '\n';
        }
        lineNumber = ensureLength(i + 1, lineNumberLength);
        str += lineNumber + '|' + lines[i];
        if (i + 1 === lineNum) {
          str += '\n' + repeat(' ', lineNumberLength + 1);
          str += lines[i].substring(0, rowNum - 1).replace(/[^\s]/g, ' ');
          str += '^';
        }
      }
      return str;
    }
    function ensureLength(num, count) {
      var str = String(num);
      while (str.length < count) {
        str += ' ';
      }
      return str;
    }
    function repeat(char_, count) {
      var str = '';
      while (--count > -1) {
        str += char_;
      }
      return str;
    }
    function _createCtor(Proto, stackFrom) {
      var Ctor = Proto.hasOwnProperty('constructor') ? Proto.constructor : null;
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        obj_defineProperty(this, 'stack', {
          value: _prepairStack(stackFrom || 3)
        });
        obj_defineProperty(this, 'message', {
          value: str_format.apply(this, arguments)
        });
        if (null != Ctor) {
          Ctor.apply(this, arguments);
        }
      };
    }
    function _prepairStack(sliceFrom) {
      var stack = new Error().stack;
      return null == stack ? null : stack.split('\n').slice(sliceFrom).join('\n');
    }
  })();
  var class_EventEmitter;
  (function() {
    class_EventEmitter = function() {
      this._listeners = {};
    };
    class_EventEmitter.prototype = {
      on: function(event, fn) {
        if (null != fn) {
          (this._listeners[event] || (this._listeners[event] = [])).push(fn);
        }
        return this;
      },
      once: function(event, fn) {
        if (null != fn) {
          fn._once = true;
          (this._listeners[event] || (this._listeners[event] = [])).push(fn);
        }
        return this;
      },
      pipe: function(event) {
        var args, that = this;
        return function() {
          args = _Array_slice.call(arguments);
          args.unshift(event);
          fn_apply(that.trigger, that, args);
        };
      },
      emit: event_trigger,
      trigger: event_trigger,
      off: function(event, fn) {
        var listeners = this._listeners[event];
        if (null == listeners) {
          return this;
        }
        if (1 === arguments.length) {
          listeners.length = 0;
          return this;
        }
        var imax = listeners.length, i = -1;
        while (++i < imax) {
          if (listeners[i] === fn) {
            listeners.splice(i, 1);
            i--;
            imax--;
          }
        }
        return this;
      }
    };
    function event_trigger(event) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var fns = this._listeners[event];
      if (null == fns) {
        return this;
      }
      for (var i = 0; i < fns.length; i++) {
        var fn = fns[i];
        fn_apply(fn, this, args);
        if (fn !== fns[i]) {
          // the callback has removed itself
          i--;
          continue;
        }
        if (true === fn._once) {
          fns.splice(i, 1);
          i--;
        }
      }
      return this;
    }
  })();
  var listeners_on, listeners_off, listeners_emit;
  (function() {
    (function() {
      arr_remove = function(array, x) {
        var i = array.indexOf(x);
        if (-1 === i) {
          return false;
        }
        array.splice(i, 1);
        return true;
      };
      arr_each = function(arr, fn, ctx) {
        arr.forEach(fn, ctx);
      };
      arr_contains = function(arr, x) {
        return -1 !== arr.indexOf(x);
      };
      arr_pushMany = function(arr, arrSource) {
        if (null == arrSource || null == arr || arr === arrSource) {
          return;
        }
        var il = arr.length, jl = arrSource.length, j = -1;
        while (++j < jl) {
          arr[il + j] = arrSource[j];
        }
      };
    })();
    /**
		 * Bind listeners to some system events:
		 * - `error` Any parser or render error
		 * - `compoCreated` Each time new component is created
		 * - `config` Each time configuration is changed via `config` fn
		 * @param {string} eveny
		 * @param {function} cb
		 * @memberOf mask
		 * @method on
		 */    listeners_on = function(event, fn) {
      (bin[event] || (bin[event] = [])).push(fn);
    }
    /**
		 * Unbind listener
		 * - `error` Any parser or render error
		 * - `compoCreated` Each time new component is created
		 * @param {string} eveny
		 * @param {function} [cb]
		 * @memberOf mask
		 * @method on
		 */;
    listeners_off = function(event, fn) {
      if (null == fn) {
        bin[event] = [];
        return;
      }
      arr_remove(bin[event], fn);
    };
    listeners_emit = function(event, v1, v2, v3, v4, v5) {
      var fns = bin[event];
      if (null == fns) {
        return false;
      }
      var imax = fns.length, i = -1;
      while (++i < imax) {
        fns[i](v1, v2, v3, v4, v5);
      }
      return 0 !== i;
    };
    var bin = {
      compoCreated: null,
      error: null
    };
  })();
  var log, log_warn, log_error, error_, error_withNode, error_withCompo, warn_, warn_withNode, parser_error, parser_warn, reporter_createErrorNode, reporter_getNodeStack, reporter_deprecated;
  (function() {
    var noConsole = 'undefined' === typeof console;
    var bind = Function.prototype.bind;
    log = noConsole ? fn_doNothing : bind.call(console.warn, console);
    log_warn = noConsole ? fn_doNothing : bind.call(console.warn, console, 'MaskJS [Warn] :');
    log_error = noConsole ? fn_doNothing : bind.call(console.error, console, 'MaskJS [Error] :');
    var STACK_SLICE = 4;
    var MaskError = error_createClass('MaskError', {}, STACK_SLICE);
    var MaskWarn = error_createClass('MaskWarn', {}, STACK_SLICE);
    error_ = delegate_notify(MaskError, 'error');
    delegate_withSource(MaskError, 'error');
    error_withNode = delegate_withNode(MaskError, 'error');
    error_withCompo = delegate_withCompo(error_withNode);
    warn_ = delegate_notify(MaskWarn, 'warn');
    delegate_withSource(MaskWarn, 'warn');
    warn_withNode = delegate_withNode(MaskWarn, 'warn');
    delegate_withCompo(warn_withNode);
    parser_error = delegate_parserReporter(MaskError, 'error');
    parser_warn = delegate_parserReporter(MaskWarn, 'warn');
    reporter_createErrorNode = function(message) {
      return {
        type: 1,
        tagName: 'div',
        attr: {
          class: '-mask-compo-errored',
          style: 'background:red; color:white;'
        },
        nodes: [ {
          type: 2,
          content: message
        } ]
      };
    };
    reporter_getNodeStack = function(node) {
      var stack = [ node ];
      var parent = node.parent;
      while (null != parent) {
        stack.unshift(parent);
        parent = parent.parent;
      }
      var str = '';
      var root = stack[0];
      if (root !== node && is_String(root.source) && node.sourceIndex > -1) {
        str += error_formatSource(root.source, node.sourceIndex, root.filename) + '\n';
      }
      str += '  at ' + stack.map(function(x) {
        return x.tagName || x.compoName;
      }).join(' > ');
      return str;
    };
    reporter_deprecated = function(id, message) {
      if (void 0 !== _notified[id]) {
        return;
      }
      _notified[id] = 1;
      log_warn('[deprecated]', message);
    };
    var _notified = {};
    function delegate_parserReporter(Ctor, type) {
      return function(str, source, index, token, state, file) {
        var error = new Ctor(str);
        var tokenMsg = formatToken(token);
        if (tokenMsg) {
          error.message += tokenMsg;
        }
        var stateMsg = formatState(state);
        if (stateMsg) {
          error.message += stateMsg;
        }
        var cursorMsg = error_formatSource(source, index, file);
        if (cursorMsg) {
          error.message += '\n' + cursorMsg;
        }
        report(error, 'error');
      };
    }
    function delegate_withSource(Ctor, type) {
      return function(mix, source, index, file) {
        var error = new Ctor(stringifyError);
        error.message = '\n' + error_formatSource(source, index, file);
        report(error, type);
      };
    }
    function delegate_notify(Ctor, type) {
      return function(arg1, arg2, arg3) {
        var str = _Array_slice.call(arguments).join(' ');
        report(new Ctor(str), type);
      };
    }
    function delegate_withNode(Ctor, type) {
      return function(mix, node) {
        var error = mix instanceof Error ? mix : new Ctor(stringifyError(mix));
        if (null != node) {
          error.message += '\n' + reporter_getNodeStack(node);
        }
        report(error, type);
      };
    }
    function delegate_withCompo(withNodeFn) {
      return function(mix, compo) {
        var node = compo.node, cursor = compo.parent;
        while (null != cursor && null == node) {
          node = cursor.node;
          cursor = cursor.parent;
        }
        withNodeFn(mix, node);
      };
    }
    function report(error, type) {
      if (listeners_emit(type, error)) {
        return;
      }
      var fn = 'error' === type ? log_error : log_warn;
      var stack = error.stack || '';
      fn(error.message + '\n' + stack);
    }
    function stringifyError(mix) {
      if (null == mix) {
        return 'Uknown error';
      }
      if ('object' !== typeof mix) {
        return mix;
      }
      if (mix.toString !== Object.prototype.toString) {
        return String(mix);
      }
      return JSON.stringify(mix);
    }
    function formatToken(token) {
      if (null == token) {
        return '';
      }
      if ('number' === typeof token) {
        token = String.fromCharCode(token);
      }
      return ' Invalid token: `' + token + '`';
    }
    function formatState(state) {
      var states = {
        10: 'tag',
        3: 'tag',
        4: 'attribute key',
        12: 'attribute value',
        6: 'literal',
        var: 'VarStatement',
        expr: 'Expression'
      };
      if (null == state || null == states[state]) {
        return '';
      }
      return ' in `' + states[state] + '`';
    }
  })();
  var Dom;
  (function() {
    var _appendChild;
    var dom_NODE, dom_TEXTNODE, dom_FRAGMENT, dom_COMPONENT, dom_CONTROLLER, dom_SET, dom_STATEMENT, dom_DECORATOR;
    (function() {
      dom_NODE = 1;
      dom_TEXTNODE = 2;
      dom_FRAGMENT = 3;
      dom_COMPONENT = 4;
      dom_CONTROLLER = 9;
      dom_SET = 10;
      dom_STATEMENT = 15;
      dom_DECORATOR = 16;
    })();
    var TextNode;
    (function() {
      /**
			 * @name TextNode
			 * @type {class}
			 * @property {type} [type=2]
			 * @property {(string|function)} content
			 * @property {IMaskNode} parent
			 * @memberOf mask.Dom
			 */
      TextNode = class_create({
        constructor: function(text, parent) {
          this.content = text;
          this.parent = parent;
        },
        type: dom_TEXTNODE,
        content: null,
        parent: null,
        sourceIndex: -1
      });
    })();
    var Fragment, HtmlFragment;
    (function() {
      (function() {
        _appendChild = function(el) {
          el.parent = this;
          var nodes = this.nodes;
          if (null == nodes) {
            this.nodes = [ el ];
            return;
          }
          var length = nodes.length;
          if (0 !== length) {
            var prev = nodes[length - 1];
            if (null != prev) {
              prev.nextSibling = el;
            }
          }
          nodes.push(el);
        };
      })();
      Fragment = class_create({
        type: dom_FRAGMENT,
        nodes: null,
        appendChild: _appendChild,
        source: '',
        filename: '',
        syntax: 'mask',
        parent: null
      });
      HtmlFragment = class_create(Fragment, {
        syntax: 'html'
      });
    })();
    var Node;
    (function() {
      /**
			 * @name MaskNode
			 * @type {class}
			 * @property {type} [type=1]
			 * @property {object} attr
			 * @property {string} tagName
			 * @property {Array.<IMaskNode>} nodes
			 * @property {IMaskNode} parent
			 * @property {string} [expression]
			 * @property {function} appendChild
			 * @memberOf mask.Dom
			 */
      Node = class_create({
        constructor: function Node(tagName, parent) {
          this.type = dom_NODE;
          this.tagName = tagName;
          this.parent = parent;
          this.attr = {};
        },
        __single: null,
        appendChild: _appendChild,
        attr: null,
        props: null,
        expression: null,
        nodes: null,
        parent: null,
        sourceIndex: -1,
        stringify: null,
        tagName: null,
        type: dom_NODE,
        decorators: null,
        nextSibling: null
      });
    })();
    var DecoratorNode;
    (function() {
      DecoratorNode = class_create({
        constructor: function DecoratorNode(expression, parent) {
          this.expression = expression;
          this.parent = parent;
        },
        __single: true,
        expression: null,
        parent: null,
        sourceIndex: -1,
        type: dom_DECORATOR,
        stringify: function(stream) {
          stream.newline();
          stream.write('[' + this.expression + ']');
        }
      });
    })();
    var ComponentNode;
    (function() {
      ComponentNode = function(compoName, parent, controller) {
        this.tagName = compoName;
        this.parent = parent;
        this.controller = controller;
        this.attr = {};
      };
      ComponentNode.prototype = {
        constructor: ComponentNode,
        type: dom_COMPONENT,
        parent: null,
        attr: null,
        controller: null,
        nodes: null,
        components: null,
        model: null,
        modelRef: null
      };
    })();
    Dom = {
      NODE: dom_NODE,
      TEXTNODE: dom_TEXTNODE,
      FRAGMENT: dom_FRAGMENT,
      COMPONENT: dom_COMPONENT,
      CONTROLLER: dom_CONTROLLER,
      SET: dom_SET,
      STATEMENT: dom_STATEMENT,
      DECORATOR: dom_DECORATOR,
      Node: Node,
      TextNode: TextNode,
      Fragment: Fragment,
      HtmlFragment: HtmlFragment,
      Component: ComponentNode,
      DecoratorNode: DecoratorNode
    };
  })();
  var customTag_getAll, customStatement_get, customTag_register, custom_optimize, customTag_registerScoped, custom_Statements, customTag_registerFromTemplate, custom_Tags, customTag_registerResolver, custom_Parsers_Transform, customTag_Compo_getHandler, customAttr_register, customTag_define, customTag_get, customTag_Base, custom_Attributes, custom_Parsers, customStatement_register, customUtil_register, customUtil_$utils, customUtil_get, custom_Optimizers, custom_Utils, customAttr_get;
  (function() {
    var custom_Tags_global;
    (function() {
      var _HtmlTags = {
        /*
			        * Most common html tags
			        * http://jsperf.com/not-in-vs-null/3
			        */
        a: null,
        abbr: null,
        article: null,
        aside: null,
        audio: null,
        b: null,
        big: null,
        blockquote: null,
        br: null,
        button: null,
        canvas: null,
        datalist: null,
        details: null,
        div: null,
        em: null,
        fieldset: null,
        footer: null,
        form: null,
        h1: null,
        h2: null,
        h3: null,
        h4: null,
        h5: null,
        h6: null,
        header: null,
        i: null,
        img: null,
        input: null,
        label: null,
        legend: null,
        li: null,
        menu: null,
        nav: null,
        ol: null,
        option: null,
        p: null,
        pre: null,
        section: null,
        select: null,
        small: null,
        span: null,
        strong: null,
        svg: null,
        table: null,
        tbody: null,
        td: null,
        textarea: null,
        tfoot: null,
        th: null,
        thead: null,
        tr: null,
        tt: null,
        ul: null,
        video: null
      };
      var _HtmlAttr = {
        class: null,
        id: null,
        style: null,
        name: null,
        type: null,
        value: null,
        required: null,
        disabled: null
      };
      custom_Utils = {};
      custom_Optimizers = {};
      custom_Statements = {};
      custom_Attributes = obj_extend({}, _HtmlAttr);
      custom_Tags = obj_extend({}, _HtmlTags);
      custom_Tags_global = obj_extend({}, _HtmlTags);
      custom_Parsers = obj_extend({}, _HtmlTags);
      custom_Parsers_Transform = obj_extend({}, _HtmlTags);
      // use on server to define reserved tags and its meta info
            ({});
    })();
    (function() {
      custom_optimize = function() {
        var i = _arr.length;
        while (--i > -1) {
          readProps(_arr[i]);
        }
        i = _arr.length;
        while (--i > -1) {
          defineProps(_arr[i]);
          obj_toFastProps(_arr[i]);
        }
        obj_toFastProps(custom_Attributes);
      };
      var _arr = [ custom_Statements, custom_Tags, custom_Parsers, custom_Parsers_Transform ];
      var _props = {};
      function readProps(obj) {
        for (var key in obj) {
          _props[key] = null;
        }
      }
      function defineProps(obj) {
        for (var key in _props) {
          if (void 0 === obj[key]) {
            obj[key] = null;
          }
        }
      }
    })();
    (function() {
      /**
			 * Register an attribute handler. Any changes can be made to:
			 * - maskNode's template
			 * - current element value
			 * - controller
			 * - model
			 * Note: Attribute wont be set to an element.
			 * @param {string} name - Attribute name to handle
			 * @param {string} [mode] - Render mode `client|server|both`
			 * @param {AttributeHandler} handler
			 * @returns {void}
			 * @memberOf mask
			 * @method registerAttrHandler
			 */
      customAttr_register = function(attrName, mix, Handler) {
        if (is_Function(mix)) {
          Handler = mix;
        }
        custom_Attributes[attrName] = Handler;
      };
      /**
			 * Get attribute  handler
			 * @param {string} name
			 * @returns {AttributeHandler}
			 * @memberOf mask
			 * @method getAttrHandler
			 */      customAttr_get = function(attrName) {
        return null != attrName ? custom_Attributes[attrName] : custom_Attributes;
      };
      /**
			 * Is called when the builder matches the node by attribute name
			 * @callback AttributeHandler
			 * @param {MaskNode} node
			 * @param {string} attrValue
			 * @param {object} model
			 * @param {object} ctx
			 * @param {DomNode} element
			 * @param {object} parentComponent
			 */    })();
    (function() {
      (function() {
        ModuleMidd = {
          parseMaskContent: function(mix, path) {
            throw new Error('Not set');
          }
        };
      })();
      /**
			 * Get Components constructor from the global repository or the scope
			 * @param {string} name
			 * @param {object} [component] - pass a component to look in its scope
			 * @returns {IComponent}
			 * @memberOf mask
			 * @method getHandler
			 */      customTag_get = function(name, ctr) {
        if (0 === arguments.length) {
          reporter_deprecated('getHandler.all', 'Use `mask.getHandlers` to get all components (also scoped)');
          return customTag_getAll();
        }
        var Ctor = custom_Tags[name];
        if (null == Ctor) {
          return null;
        }
        if (Ctor !== Resolver) {
          return Ctor;
        }
        var ctr_ = is_Function(ctr) ? ctr.prototype : ctr;
        while (null != ctr_) {
          if (is_Function(ctr_.getHandler)) {
            Ctor = ctr_.getHandler(name);
            if (null != Ctor) {
              return Ctor;
            }
          }
          ctr_ = ctr_.parent;
        }
        return custom_Tags_global[name];
      }
      /**
			 * Get all components constructors from the global repository and/or the scope
			 * @param {object} [component] - pass a component to look also in its scope
			 * @returns {object} All components in an object `{name: Ctor}`
			 * @memberOf mask
			 * @method getHandlers
			 */;
      customTag_getAll = function(ctr) {
        if (null == ctr) {
          return custom_Tags;
        }
        var x, obj = {}, ctr_ = ctr;
        while (null != ctr_) {
          x = null;
          if (is_Function(ctr_.getHandlers)) {
            x = ctr_.getHandlers();
          } else {
            x = ctr_.__handlers__;
          }
          if (null != x) {
            obj = obj_extendDefaults(obj, x);
          }
          ctr_ = ctr_.parent;
        }
        for (var key in custom_Tags) {
          x = custom_Tags[key];
          if (null == x || x === Resolver) {
            continue;
          }
          if (null == obj[key]) {
            obj[key] = x;
          }
        }
        return obj;
      }
      /**
			 * Register a component
			 * @param {string} name
			 * @param {object|IComponent} component
			 * @param {object} component - Component static definition
			 * @param {IComponent} component - Components constructor
			 * @returns {void}
			 * @memberOf mask
			 * @method registerHandler
			 */;
      customTag_register = function(mix, Handler) {
        if ('string' !== typeof mix && 3 === arguments.length) {
          customTag_registerScoped.apply(this, arguments);
          return;
        }
        var Ctor = compo_ensureCtor(Handler), Repo = custom_Tags[mix] === Resolver ? custom_Tags_global : custom_Tags;
        Repo[mix] = Ctor;
        //> make fast properties
                obj_toFastProps(custom_Tags);
      }
      /**
			 * Register components from a template
			 * @param {string} template - Mask template
			 * @param {object|IComponent} [component] - Register in the components scope
			 * @param {string} [path] - Optionally define the path for the template
			 * @returns {Promise} - Fullfills when all submodules are resolved and components are registerd
			 * @memberOf mask
			 * @method registerFromTemplate
			 */;
      customTag_registerFromTemplate = function(mix, Ctr, path) {
        return ModuleMidd.parseMaskContent(mix, path).then(function(exports) {
          var store = exports.__handlers__;
          for (var key in store) {
            if (key in exports) {
              // is global
              customTag_register(key, store[key]);
              continue;
            }
            customTag_registerScoped(Ctr, key, store[key]);
          }
        });
      }
      /**
			 * Register a component
			 * @param {object|IComponent} scopedComponent - Use components scope
			 * @param {string} name - Name of the component
			 * @param {object|IComponent} component - Components definition
			 * @returns {void}
			 * @memberOf mask
			 * @method registerScoped
			 */;
      customTag_registerScoped = function(Ctx, name, Handler) {
        if (null == Ctx) {
          // Use global
          customTag_register(name, Handler);
          return;
        }
        customTag_registerResolver(name);
        var obj = is_Function(Ctx) ? Ctx.prototype : Ctx;
        var map = obj.__handlers__;
        if (null == map) {
          map = obj.__handlers__ = {};
        }
        map[name] = compo_ensureCtor(Handler);
        if (null == obj.getHandler) {
          obj.getHandler = customTag_Compo_getHandler;
        }
      }
      /** Variations:
			 * - 1. (template)
			 * - 2. (scopedCompoName, template)
			 * - 3. (scopedCtr, template)
			 * - 4. (name, Ctor)
			 * - 5. (scopedCtr, name, Ctor)
			 * - 6. (scopedCompoName, name, Ctor)
			 */;
      function is_Compo(val) {
        return is_Object(val) || is_Function(val);
      }
      /**
			 * Universal component definition, which covers all the cases: simple, scoped, template
			 * - 1. (template)
			 * - 2. (scopedCompoName, template)
			 * - 3. (scopedCtr, template)
			 * - 4. (name, Ctor)
			 * - 5. (scopedCtr, name, Ctor)
			 * - 6. (scopedCompoName, name, Ctor)
			 * @returns {void|Promise}
			 * @memberOf mask
			 * @method define
			 */      customTag_define = fn_createByPattern([ {
        pattern: [ is_String ],
        handler: function(template) {
          return customTag_registerFromTemplate(template);
        }
      }, {
        pattern: [ is_String, is_String ],
        handler: function(name, template) {
          var Scope = customTag_get(name);
          return customTag_registerFromTemplate(template, Scope);
        }
      }, {
        pattern: [ is_Compo, is_String ],
        handler: function(Scope, template) {
          return customTag_registerFromTemplate(template, Scope);
        }
      }, {
        pattern: [ is_String, is_Compo ],
        handler: function(name, Ctor) {
          return customTag_register(name, Ctor);
        }
      }, {
        pattern: [ is_Compo, is_String, is_Compo ],
        handler: function(Scope, name, Ctor) {
          customTag_registerScoped(Scope, name, Ctor);
        }
      }, {
        pattern: [ is_String, is_String, is_Compo ],
        handler: function(scopeName, name, Ctor) {
          var Scope = customTag_get(scopeName);
          return customTag_registerScoped(Scope, name, Ctor);
        }
      } ]);
      customTag_registerResolver = function(name) {
        var Ctor = custom_Tags[name];
        if (Ctor === Resolver) {
          return;
        }
        if (null != Ctor) {
          custom_Tags_global[name] = Ctor;
        }
        custom_Tags[name] = Resolver;
        //> make fast properties
                obj_toFastProps(custom_Tags);
      };
      customTag_Compo_getHandler = function(name) {
        var map = this.__handlers__;
        return null == map ? null : map[name];
      };
      customTag_Base = {
        async: false,
        attr: null,
        await: null,
        compoName: null,
        components: null,
        expression: null,
        ID: null,
        meta: null,
        node: null,
        model: null,
        nodes: null,
        parent: null,
        render: null,
        renderEnd: null,
        renderStart: null,
        tagName: null,
        type: null
      };
      var Resolver = function(node, model, ctx, container, ctr) {
        var Mix = customTag_get(node.tagName, ctr);
        if (null != Mix) {
          if (false === is_Function(Mix)) {
            return obj_create(Mix);
          }
          return new Mix(node, model, ctx, container, ctr);
        }
        error_withNode('Component not found: ' + node.tagName, node);
        return null;
      };
      Resolver;
      function wrapStatic(proto) {
        function Ctor(node, parent) {
          this.ID = null;
          this.node = null;
          this.tagName = node.tagName;
          this.attr = obj_create(node.attr);
          this.expression = node.expression;
          this.nodes = node.nodes;
          this.nextSibling = node.nextSibling;
          this.parent = parent;
          this.components = null;
        }
        Ctor.prototype = proto;
        return Ctor;
      }
      function compo_ensureCtor(Handler) {
        if (is_Object(Handler)) {
          //> static
          Handler.__Ctor = wrapStatic(Handler);
        }
        return Handler;
      }
    })();
    (function() {
      /**
			 * Utils Repository
			 * @param {string} name
			 * @param {(IUtilHandler|UtilHandler)} handler
			 * @memberOf mask
			 * @name _
			 * @category Mask Util
			 */
      customUtil_$utils = {};
      /**
			 * Register Util Handler. Template Example: `'~[myUtil: value]'`
			 * @param {string} name
			 * @param {(mask._.IUtilHandler|mask._.FUtilHandler)} handler
			 * @memberOf mask
			 * @method getUtil
			 * @category Mask Util
			 */      customUtil_register = function(name, mix) {
        if (is_Function(mix)) {
          custom_Utils[name] = mix;
          return;
        }
        custom_Utils[name] = createUtil(mix);
        if ('parsed' === mix['arguments']) {
          customUtil_$utils[name] = mix.process;
        }
      };
      /**
			 * Get the Util Handler
			 * @param {string} name
			 * @memberOf mask
			 * @method registerUtil
			 * @category Mask Util
			 */      customUtil_get = function(name) {
        return null != name ? custom_Utils[name] : custom_Utils;
      };
      function createUtil(obj) {
        if ('parsed' === obj['arguments']) {
          return processParsedDelegate(obj.process);
        }
        var fn = fn_proxy(obj.process || processRawFn, obj);
        // <static> save reference to the initial util object.
        // Mask.Bootstrap needs the original util
        // @workaround
                fn.util = obj;
        return fn;
      }
      function processRawFn(expr, model, ctx, el, ctr, attrName, type, node) {
        if ('node' === type) {
          this.nodeRenderStart(expr, model, ctx, el, ctr, type, node);
          return this.node(expr, model, ctx, el, ctr, type, node);
        }
        // `attr`, `compo-attr`
                this.attrRenderStart(expr, model, ctx, el, ctr, attrName, type, node);
        return this.attr(expr, model, ctx, el, ctr, attrName, type, node);
      }
      function processParsedDelegate(fn) {
        return function(expr, model, ctx, el, ctr, type, node) {
          var args = expression_evalStatements(expr, model, ctx, ctr, node);
          return fn.apply(null, args);
        };
      }
      /**
			 * Is called when the builder matches the interpolation.
			 * Define `process` function OR group of `node*`,`attr*` functions.
			 * The seperation `*RenderStart/*` is needed for Nodejs rendering - the first part is called on nodejs side,
			 * the other one is called on the client.
			 * @typedef IUtilHandler
			 * @type {object}
			 * @property {bool} [arguments=false] - should parse interpolation string to arguments, otherwise raw string is passed
			 * @property {UtilHandler} [process]
			 * @property {function} [nodeRenderStart] - `expr, model, ctx, element, controller, attrName`
			 * @property {function} [node] - `expr, model, ctx, element, controller`
			 * @property {function} [attr] - `expr, model, ctx, element, controller, attrName`
			 * @property {function} [attrRenderStart] - `expr, model, ctx, element, controller, attrName`
			 * @abstract
			 * @category Mask Util
			 */    })();
    (function() {
      /**
			 * Register a statement handler
			 * @param {string} name - Tag name to handle
			 * @param StatementHandler} handler
			 * @memberOf mask
			 * @method registerStatement
			 */
      customStatement_register = function(name, handler) {
        //@TODO should it be not allowed to override system statements, if, switch?
        custom_Statements[name] = is_Function(handler) ? {
          render: handler
        } : handler;
      };
      /**
			 * Get statement handler
			 * @param {string} name
			 * @returns {StatementHandler}
			 * @memberOf mask
			 * @method getStatement
			 */      customStatement_get = function(name) {
        return null != name ? custom_Statements[name] : custom_Statements;
      };
      /**
			 * Is called when the builder matches the node by tagName
			 * @callback StatementHandler
			 * @param {MaskNode} node
			 * @param {object} model
			 * @param {object} ctx
			 * @param {DomNode} container
			 * @param {object} parentComponent
			 * @param {Array} children - `out` Fill the array with rendered elements
			 */    })();
  })();
  var exp_type_Sync, exp_type_Async, exp_type_Observe, expression_getType, expression_eval, expression_evalStatements, expression_varRefs, ExpressionUtil;
  (function() {
    var util_throw, util_getNodeStack, util_resolveRef, util_resolveRefValue, util_resolveAcc, Ast_FunctionRefUtil, Ast_Body, Ast_Statement, Ast_Value, Ast_Array, Ast_Object, Ast_FunctionRef, Ast_SymbolRef, Ast_Accessor, Ast_AccessorExpr, Ast_UnaryPrefix, Ast_TernaryStatement, op_Minus, op_Plus, op_Divide, op_Multip, op_Modulo, op_LogicalOr, op_LogicalAnd, op_LogicalNot, op_LogicalEqual, op_LogicalEqual_Strict, op_LogicalNotEqual, op_LogicalNotEqual_Strict, op_LogicalGreater, op_LogicalGreaterEqual, op_LogicalLess, op_LogicalLessEqual, op_AsyncAccessor, op_ObserveAccessor, op_BitOr, op_BitXOr, op_BitAnd, punc_ParenthesisOpen, punc_ParenthesisClose, punc_BracketOpen, punc_BracketClose, punc_BraceOpen, punc_BraceClose, punc_Comma, punc_Dot, punc_Question, punc_Colon, punc_Semicolon, go_ref, go_acs, go_string, go_number, go_objectKey, type_Body, type_Statement, type_SymbolRef, type_FunctionRef, type_Accessor, type_AccessorExpr, type_Value, type_Object, type_Array, type_UnaryPrefix, type_Ternary, state_body, state_arguments, PRECEDENCE;
    var _parse;
    (function() {
      (function() {
        op_Minus = '-';
 //1;
                op_Plus = '+';
 //2;
                op_Divide = '/';
 //3;
                op_Multip = '*';
 //4;
                op_Modulo = '%';
 //5;
                op_LogicalOr = '||';
 //6;
                op_LogicalAnd = '&&';
 //7;
                op_LogicalNot = '!';
 //8;
                op_LogicalEqual = '==';
 //9;
                op_LogicalEqual_Strict = '===';
 // 111
                op_LogicalNotEqual = '!=';
 //11;
                op_LogicalNotEqual_Strict = '!==';
 // 112
                op_LogicalGreater = '>';
 //12;
                op_LogicalGreaterEqual = '>=';
 //13;
                op_LogicalLess = '<';
 //14;
                op_LogicalLessEqual = '<=';
 //15;
                var op_Member = '.';
 // 16
                op_AsyncAccessor = '->';
        op_ObserveAccessor = '>>';
        op_BitOr = '|';
        op_BitXOr = '^';
        op_BitAnd = '&';
        punc_ParenthesisOpen = 20;
        punc_ParenthesisClose = 21;
        punc_BracketOpen = 22;
        punc_BracketClose = 23;
        punc_BraceOpen = 24;
        punc_BraceClose = 25;
        punc_Comma = 26;
        punc_Dot = 27;
        punc_Question = 28;
        punc_Colon = 29;
        punc_Semicolon = 30;
        go_ref = 31;
        go_acs = 32;
        go_string = 33;
        go_number = 34;
        go_objectKey = 35;
        type_Body = 1;
        type_Statement = 2;
        type_SymbolRef = 3;
        type_FunctionRef = 4;
        type_Accessor = 5;
        type_AccessorExpr = 6;
        type_Value = 7;
        type_Object = 10;
        type_Array = 11;
        type_UnaryPrefix = 12;
        type_Ternary = 13;
        state_body = 1;
        state_arguments = 2;
        PRECEDENCE = {};
        PRECEDENCE[op_Member] = 1;
        PRECEDENCE[op_Divide] = 2;
        PRECEDENCE[op_Multip] = 2;
        PRECEDENCE[op_Minus] = 3;
        PRECEDENCE[op_Plus] = 3;
        PRECEDENCE[op_LogicalGreater] = 4;
        PRECEDENCE[op_LogicalGreaterEqual] = 4;
        PRECEDENCE[op_LogicalLess] = 4;
        PRECEDENCE[op_LogicalLessEqual] = 4;
        PRECEDENCE[op_LogicalEqual] = 5;
        PRECEDENCE[op_LogicalEqual_Strict] = 5;
        PRECEDENCE[op_LogicalNotEqual] = 5;
        PRECEDENCE[op_LogicalNotEqual_Strict] = 5;
        PRECEDENCE[op_BitOr] = 5;
        PRECEDENCE[op_BitXOr] = 5;
        PRECEDENCE[op_BitAnd] = 5;
        PRECEDENCE[op_LogicalAnd] = 7;
        PRECEDENCE[op_LogicalOr] = 7;
        obj_toFastProps(PRECEDENCE);
      })();
      (function() {
        Ast_Body = class_create({
          body: null,
          join: null,
          constructor: function Ast_Body(parent, node) {
            this.parent = parent;
            this.type = type_Body;
            this.body = [];
            this.join = null;
            this.node = node;
            this.source = null;
            this.async = false;
            this.observe = false;
          },
          toString: function() {
            var arr = this.body, l = arr.length, str = '';
            for (var i = 0; i < l; i++) {
              if (i > 0) {
                str += ', ';
              }
              str += arr[i].toString();
            }
            return str;
          }
        });
        Ast_Statement = class_create({
          constructor: function Ast_Statement(parent) {
            this.parent = parent;
            this.async = false;
            this.observe = false;
            this.preResultIndex = -1;
          },
          type: type_Statement,
          join: null,
          body: null,
          async: null,
          observe: null,
          parent: null,
          toString: function() {
            return this.body && this.body.toString() || '';
          }
        });
        Ast_Value = class_create({
          constructor: function Ast_Value(value) {
            this.type = type_Value;
            this.body = value;
            this.join = null;
          },
          toString: function() {
            if (is_String(this.body)) {
              return '\'' + this.body.replace(/'/g, '\\\'') + '\'';
            }
            return this.body;
          }
        });
        Ast_Array = class_create({
          constructor: function Ast_Array(parent) {
            this.type = type_Array;
            this.parent = parent;
            this.body = new Ast_Body(this);
          },
          toString: function() {
            return '[' + this.body.toString() + ']';
          }
        });
        Ast_Object = class_create({
          constructor: function Ast_Object(parent) {
            this.type = type_Object;
            this.parent = parent;
            this.props = {};
          },
          nextProp: function(prop) {
            var body = new Ast_Statement(this);
            this.props[prop] = body;
            return body;
          }
        });
        Ast_FunctionRef = class_create({
          constructor: function Ast_FunctionRef(parent, ref) {
            this.parent = parent;
            this.type = type_FunctionRef;
            this.body = ref;
            this.arguments = [];
            this.next = null;
          },
          newArg: function() {
            var body = new Ast_Body(this);
            this.arguments.push(body);
            return body;
          },
          closeArgs: function() {
            var last = this.arguments[this.arguments.length - 1];
            if (0 === last.body.length) {
              this.arguments.pop();
            }
          },
          toString: function() {
            var args = this.arguments.map(function(x) {
              return x.toString();
            }).join(', ');
            return this.body + '(' + args + ')';
          }
        });
        var Ast_AccessorBase = {
          optional: false,
          sourceIndex: null,
          next: null
        };
        Ast_SymbolRef = class_create(Ast_AccessorBase, {
          type: type_SymbolRef,
          constructor: function(parent, ref) {
            this.parent = parent;
            this.body = ref;
          },
          toString: function() {
            return null == this.next ? this.body : this.body + '.' + this.next.toString();
          }
        });
        Ast_Accessor = class_create(Ast_AccessorBase, {
          type: type_Accessor,
          constructor: function(parent, ref) {
            this.parent = parent;
            this.body = ref;
          },
          toString: function() {
            return '.' + this.body + (null == this.next ? '' : this.next.toString());
          }
        });
        Ast_AccessorExpr = class_create({
          type: type_AccessorExpr,
          constructor: function(parent) {
            this.parent = parent;
            this.body = new Ast_Statement(this);
            this.body.body = new Ast_Body(this.body);
          },
          getBody: function() {
            return this.body.body;
          },
          toString: function() {
            return '[' + this.body.toString() + ']';
          }
        });
        Ast_UnaryPrefix = class_create({
          type: type_UnaryPrefix,
          body: null,
          constructor: function Ast_UnaryPrefix(parent, prefix) {
            this.parent = parent;
            this.prefix = prefix;
          }
        });
        Ast_TernaryStatement = class_create({
          constructor: function Ast_TernaryStatement(assertions) {
            this.body = assertions;
            this.case1 = new Ast_Body(this);
            this.case2 = new Ast_Body(this);
          },
          type: type_Ternary,
          case1: null,
          case2: null
        });
      })();
      var ast_remove, ast_findPrev, ast_handlePrecedence;
      (function() {
        ast_remove = function(parent, ref) {
          if (parent.type === type_Statement) {
            parent.body = null;
          }
        };
        ast_findPrev = function(node, nodeType) {
          var x = node;
          while (null != x) {
            if (x.type === nodeType) {
              return x;
            }
            x = x.parent;
          }
          return null;
        };
        ast_handlePrecedence = function(ast) {
          if (ast.type !== type_Body) {
            if (null != ast.body && 'object' === typeof ast.body) {
              ast_handlePrecedence(ast.body);
            }
            return;
          }
          var x, prev, array, body = ast.body, i = 0, length = body.length;
          if (0 === length) {
            return;
          }
          for (;i < length; i++) {
            ast_handlePrecedence(body[i]);
          }
          for (i = 1; i < length; i++) {
            x = body[i];
            prev = body[i - 1];
            if (PRECEDENCE[prev.join] > PRECEDENCE[x.join]) {
              break;
            }
          }
          if (i === length) {
            return;
          }
          array = [ body[0] ];
          for (i = 1; i < length; i++) {
            x = body[i];
            prev = body[i - 1];
            var prec_Prev = PRECEDENCE[prev.join];
            if (prec_Prev > PRECEDENCE[x.join] && i < length - 1) {
              var nextJoin, arr, start = i;
              // collect all with join smaller or equal to previous
              // 5 == 3 * 2 + 1 -> 5 == (3 * 2 + 1);
                            while (++i < length) {
                nextJoin = body[i].join;
                if (null == nextJoin) {
                  break;
                }
                if (prec_Prev <= PRECEDENCE[nextJoin]) {
                  break;
                }
              }
              arr = body.slice(start, i + 1);
              x = ast_join(arr);
              ast_handlePrecedence(x);
            }
            array.push(x);
          }
          ast.body = array;
        }
        // = private
        ;
        function ast_join(bodyArr) {
          if (0 === bodyArr.length) {
            return null;
          }
          var body = new Ast_Body(bodyArr[0].parent);
          body.join = bodyArr[bodyArr.length - 1].join;
          body.body = bodyArr;
          return body;
        }
      })();
      (function() {
        (function() {
          Ast_FunctionRefUtil = {
            evalArguments: function(node, model, ctx, ctr, preResults) {
              var args = node.arguments, out = [], i = -1, imax = args.length;
              while (++i < imax) {
                out[i] = _evaluateAst(args[i], model, ctx, ctr, preResults);
              }
              return out;
            }
          };
        })();
        util_throw = function(template, index, msg, token, astNode) {
          return parser_error(msg + util_getNodeStack(astNode), template.toString(), index, token, 'expr');
        };
        util_getNodeStack = function(astNode) {
          var domNode = null, x = astNode;
          while (null == domNode && null != x) {
            domNode = x.node;
            x = x.parent;
          }
          if (null == domNode) {
            var str, i;
            x = astNode;
            while (null != x) {
              if (null == i) {
                i = x.sourceIndex;
              }
              if (null == str) {
                str = x.source;
              }
              x = x.parent;
            }
            if (null != str) {
              return '\n' + error_formatSource(str, i || 0);
            }
            return '';
          }
          return reporter_getNodeStack(domNode);
        };
        util_resolveRef = function(astRef, model, ctx, ctr) {
          var object, value, args, i, imax, controller = ctr, current = astRef, key = astRef.body;
          if ('$c' === key || '$' === key) {
            reporter_deprecated('accessor.compo', 'Use `this` instead of `$c` or `$`.' + util_getNodeStack(astRef));
            key = 'this';
          }
          if ('$u' === key) {
            reporter_deprecated('accessor.util', 'Use `_` instead of `$u`' + util_getNodeStack(astRef));
            key = '_';
          }
          if ('$a' === key) {
            reporter_deprecated('accessor.attr', 'Use `this.attr` instead of `$a`' + util_getNodeStack(astRef));
          }
          if ('this' === key) {
            value = controller;
            var next = current.next, nextBody = null != next && next.body;
            if (null != nextBody && null == value[nextBody]) {
              if (next.type === type_FunctionRef && is_Function(CompoProto[nextBody])) {
                // use fn from prototype if possible, like `closest`
                object = controller;
                value = CompoProto[nextBody];
                current = next;
              } else {
                // find the closest controller, which has the property
                while (true) {
                  value = value.parent;
                  if (null == value) {
                    break;
                  }
                  if (null == value[nextBody]) {
                    continue;
                  }
                  object = value;
                  value = value[nextBody];
                  current = next;
                  break;
                }
              }
              if (null == value) {
                // prepair for warn message
                key = '$.' + nextBody;
                current = next;
              }
            }
          } else if ('$a' === key) {
            value = controller && controller.attr;
          } else if ('_' === key) {
            value = customUtil_$utils;
          } else if ('$ctx' === key) {
            value = ctx;
          } else if ('$scope' === key) {
            next = current.next, nextBody = null != next && next.body;
            if (null != nextBody) {
              while (null != controller) {
                object = controller.scope;
                if (null != object) {
                  value = object[nextBody];
                }
                if (null != value) {
                  break;
                }
                controller = controller.parent;
              }
              current = next;
            }
          } else if ('global' === key && (null == model || void 0 === model.global)) {
            value = _global;
          } else {
            // scope resolver
            if (null != model) {
              object = model;
              value = model[key];
            }
            if (null == value) {
              while (null != controller) {
                object = controller.scope;
                if (null != object) {
                  value = object[key];
                }
                if (null != value) {
                  break;
                }
                controller = controller.parent;
              }
            }
          }
          do {
            if (null == value) {
              verifyPropertyUndefinedError(current, key);
              return null;
            }
            if (current.type === type_FunctionRef) {
              args = [];
              i = -1;
              imax = current.arguments.length;
              while (++i < imax) {
                args[i] = _evaluateAst(current.arguments[i], model, ctx, controller);
              }
              value = value.apply(object, args);
            }
            if (null == value || null == current.next) {
              break;
            }
            current = current.next;
            key = current.type === type_AccessorExpr ? _evaluateAst(current.body, model, ctx, controller) : current.body;
            object = value;
            value = value[key];
          } while (true);
          return value;
        };
        util_resolveRefValue = function(astRef, model, ctx, ctr, preResults) {
          var controller = ctr, current = astRef, key = astRef.body;
          if ('$c' === key || '$' === key) {
            reporter_deprecated('accessor.compo', 'Use `this` instead of `$c` or `$`.' + util_getNodeStack(astRef));
            key = 'this';
          }
          if ('$u' === key) {
            reporter_deprecated('accessor.util', 'Use `_` instead of `$u`' + util_getNodeStack(astRef));
            key = '_';
          }
          if ('$a' === key) {
            reporter_deprecated('accessor.attr', 'Use `this.attr` instead of `$a`' + util_getNodeStack(astRef));
            return controller && controller.attr;
          }
          if ('global' === key && (null == model || void 0 === model.global)) {
            return _global;
          }
          if ('_' === key) {
            return customUtil_$utils;
          }
          if ('$ctx' === key) {
            return ctx;
          }
          if ('this' === key) {
            var this_ = ctr;
            var nextKey = null == current.next ? null : current.next.body;
            if (null == nextKey) {
              return this_;
            }
            var x = this_;
            while (null != x) {
              if (_isDefined(x, nextKey)) {
                return x;
              }
              x = x.parent;
            }
            /** Backwards comp. */            if (_isDefined(CompoProto, nextKey)) {
              this_[nextKey] = CompoProto[nextKey];
            }
            return this_;
          }
          if ('$scope' === key) {
            nextKey = null == current.next ? null : current.next.body;
            if (null == nextKey) {
              return scope;
            }
            var scope = null;
            x = ctr;
            while (null != x) {
              if (null != x.scope) {
                if (null == scope) {
                  scope = x.scope;
                }
                if (_isDefined(x.scope, nextKey)) {
                  return x.scope;
                }
              }
              x = x.parent;
            }
            return scope;
          }
          // Model resolver
                    if (_isDefined(model, key)) {
            return model[key];
          }
          // Scope resolver
                    scope = null, x = ctr;
          while (null != x) {
            if (null != x.scope) {
              if (null == scope) {
                scope = x.scope;
              }
              if (_isDefined(x.scope, key)) {
                return x.scope[key];
              }
            }
            x = x.parent;
          }
          return null;
        };
        util_resolveAcc = function(object, astAcc, model, ctx, ctr, preResults) {
          var value = object, current = astAcc;
          do {
            if (null == value) {
              verifyPropertyUndefinedError(current.parent, key);
              return null;
            }
            var type = current.type;
            if (type === type_Accessor) {
              value = value[current.body];
              continue;
            }
            if (type === type_AccessorExpr) {
              var key = _evaluateAst(current.body, model, ctx, ctr, preResults);
              value = value[key];
              continue;
            }
            if (type_FunctionRef === type) {
              var fn = value[current.body];
              if ('function' !== typeof fn) {
                warn_(current.body + ' is not a function', util_getNodeStack(astAcc));
                return null;
              }
              var args = Ast_FunctionRefUtil.evalArguments(current, model, ctr, ctr, preResults);
              value = fn.apply(value, args);
              continue;
            }
            util_throw('Syntax error: Invalid accessor type', type, current);
            return null;
          } while (null != value && null != (current = current.next));
          return value;
        };
        function verifyPropertyUndefinedError(astNode, key) {
          if (null == astNode || null != astNode.next && true !== astNode.optional) {
            // notify that value is not in model, ctx, controller;
            warn_('Cannot read property \'' + astNode.next.body + '\' of undefined', key, util_getNodeStack(astNode.next));
          }
        }
        function _isDefined(obj, key) {
          return null != obj && 'object' === typeof obj && key in obj;
        }
      })();
      (function() {
        __rgxEscapedChar = {
          '\'': /\\'/g,
          '"': /\\"/g,
          '{': /\\\{/g,
          '>': /\\>/g,
          ';': /\\>/g
        };
      })();
      var template, ast, index = 0, length = 0;
      /*
			 * earlyExit - only first statement/expression is consumed
			 */      _parse = function(expr, earlyExit, node) {
        if (null == earlyExit) {
          earlyExit = false;
        }
        template = expr;
        index = 0;
        length = expr.length;
        ast = new Ast_Body(null, node);
        ast.source = expr;
        var c, t, directive, current = ast, state = state_body;
        outer: while (true) {
          if (index < length && (c = template.charCodeAt(index)) < 33) {
            index++;
            continue;
          }
          if (index >= length) {
            break;
          }
          directive = parser_getDirective(c);
          if (null == directive && index < length) {
            break;
          }
          if (directive === punc_Semicolon) {
            if (true === earlyExit) {
              return [ ast, index ];
            }
            break;
          }
          if (true === earlyExit) {
            var p = current.parent;
            if (null != p && p.type === type_Body && null == p.parent) {
              // is in root body
              if (directive === go_ref) {
                return [ ast, index ];
              }
            }
          }
          if (directive === punc_Semicolon) {
            break;
          }
          switch (directive) {
           case punc_ParenthesisOpen:
            current = ast_append(current, new Ast_Statement(current));
            current = ast_append(current, new Ast_Body(current));
            index++;
            continue;

           case punc_ParenthesisClose:
            var closest = type_Body;
            if (state === state_arguments) {
              state = state_body;
              closest = type_FunctionRef;
            }
            do {
              current = current.parent;
            } while (null != current && current.type !== closest);
            if (current.type === type_FunctionRef) {
              current.closeArgs();
            }
            if (closest === type_Body) {
              current = current.parent;
            }
            if (null == current) {
              util_throw(template, index, 'OutOfAst Exception', c);
              break outer;
            }
            index++;
            continue;

           case punc_BraceOpen:
            current = ast_append(current, new Ast_Object(current));
            directive = go_objectKey;
            index++;
            break;

           case punc_BraceClose:
            while (null != current && current.type !== type_Object) {
              current = current.parent;
            }
            index++;
            continue;

           case punc_Comma:
            if (state !== state_arguments) {
              state = state_body;
              do {
                current = current.parent;
              } while (null != current && current.type !== type_Body && current.type !== type_Object);
              index++;
              if (null == current) {
                util_throw(template, index, 'Unexpected comma', c);
                break outer;
              }
              if (current.type === type_Object) {
                directive = go_objectKey;
                break;
              }
              continue;
            }
            do {
              current = current.parent;
            } while (null != current && current.type !== type_FunctionRef);
            if (null == current) {
              util_throw(template, index, 'OutOfAst Exception', c);
              break outer;
            }
            current = current.newArg();
            index++;
            continue;

           case punc_Question:
            index++;
            c = parser_skipWhitespace();
            t = current.type;
            if ((t === type_SymbolRef || t === type_AccessorExpr || t === type_Accessor) && 46 === c) {
              // .
              index++;
              parser_skipWhitespace();
              directive = go_acs;
              current.optional = true;
              break;
            }
            ast = new Ast_TernaryStatement(ast);
            current = ast.case1;
            continue;

           case punc_Colon:
            current = ast.case2;
            index++;
            continue;

           case punc_Dot:
            c = template.charCodeAt(index + 1);
            if (c >= 48 && c <= 57) {
              directive = go_number;
            } else {
              index++;
              c = c > 32 ? c : parser_skipWhitespace();
              directive = current.type === type_Body ? go_ref : go_acs;
            }
            break;

           case op_AsyncAccessor:
           case op_ObserveAccessor:
            t = current.type;
            if (t !== type_SymbolRef && t !== type_Accessor && t !== type_FunctionRef) {
              return util_throw(template, index, 'Unexpected accessor:' + directive);
            }
            var ref = ast_findPrev(current, type_SymbolRef);
            if (null == ref) {
              ref = ast_findPrev(current, type_FunctionRef);
            }
            if (null == ref) {
              return util_throw(template, index, 'Ref not found');
            }
            var parent = ref.parent;
            if (parent.type !== type_Statement) {
              return util_throw(template, index, 'Ref is not in a statement');
            }
            ast_remove(parent, ref);
            var statement = new Ast_Statement(parent);
            var inner = new Ast_Statement(statement);
            if (directive === op_AsyncAccessor) {
              inner.async = true;
            } else {
              inner.observe = true;
            }
            ref.parent = inner;
            ast_append(inner, ref);
            ast_append(statement, inner);
            ast_append(parent, statement);
            index++;
            if (directive === op_AsyncAccessor) {
              ast.async = true;
            } else {
              ast.observe = true;
            }
            c = parser_skipWhitespace();
            directive = go_acs;
            current = statement.parent;
            break;

           case punc_BracketOpen:
            t = current.type;
            if (t === type_SymbolRef || t === type_AccessorExpr || t === type_Accessor) {
              current = ast_append(current, new Ast_AccessorExpr(current));
              current.sourceIndex = index;
              current = current.getBody();
              index++;
              continue;
            }
            current = ast_append(current, new Ast_Array(current));
            current = current.body;
            index++;
            continue;

           case punc_BracketClose:
            do {
              current = current.parent;
            } while (null != current && current.type !== type_AccessorExpr && current.type !== type_Array);
            index++;
            continue;
          }
          if (current.type === type_Body) {
            current = ast_append(current, new Ast_Statement(current));
          }
          if ((op_Minus === directive || op_LogicalNot === directive) && null == current.body) {
            current = ast_append(current, new Ast_UnaryPrefix(current, directive));
            index++;
            continue;
          }
          switch (directive) {
           case op_Minus:
           case op_Plus:
           case op_Multip:
           case op_Divide:
           case op_Modulo:
           case op_BitOr:
           case op_BitXOr:
           case op_BitAnd:
           case op_LogicalAnd:
           case op_LogicalOr:
           case op_LogicalEqual:
           case op_LogicalEqual_Strict:
           case op_LogicalNotEqual:
           case op_LogicalNotEqual_Strict:
           case op_LogicalGreater:
           case op_LogicalGreaterEqual:
           case op_LogicalLess:
           case op_LogicalLessEqual:
            while (current && current.type !== type_Statement) {
              current = current.parent;
            }
            if (null == current.body) {
              return util_throw(template, index, 'Unexpected operator', c);
            }
            current.join = directive;
            do {
              current = current.parent;
            } while (null != current && current.type !== type_Body);
            if (null == current) {
              return util_throw(template, index, 'Unexpected operator', c);
            }
            index++;
            continue;

           case go_string:
           case go_number:
            if (null != current.body && null == current.join) {
              return util_throw(template, index, 'Directive expected', c);
            }
            if (go_string === directive) {
              index++;
              ast_append(current, new Ast_Value(parser_getString(c)));
              index++;
            }
            if (go_number === directive) {
              ast_append(current, new Ast_Value(parser_getNumber()));
            }
            continue;

           case go_ref:
           case go_acs:
            var start = index;
            ref = parser_getRef();
            if (directive === go_ref) {
              if ('null' === ref) {
                ref = null;
              }
              if ('false' === ref) {
                ref = false;
              }
              if ('true' === ref) {
                ref = true;
              }
              if (current.type === type_Body || current.type === type_Statement) {
                if ('await' === ref) {
                  ast.async = true;
                  current.async = true;
                  continue;
                }
                if ('observe' === ref) {
                  ast.observe = true;
                  current.observe = true;
                  continue;
                }
              }
              if ('string' !== typeof ref) {
                ast_append(current, new Ast_Value(ref));
                continue;
              }
            }
            while (index < length) {
              c = template.charCodeAt(index);
              if (c < 33) {
                index++;
                continue;
              }
              break;
            }
            if (40 === c) {
              // (
              // function ref
              state = state_arguments;
              index++;
              var fn = new Ast_FunctionRef(current, ref);
              if (directive === go_acs && current.type === type_Statement) {
                current.next = fn;
              } else {
                ast_append(current, fn);
              }
              current = fn.newArg();
              continue;
            }
            var Ctor = directive === go_ref ? Ast_SymbolRef : Ast_Accessor;
            current = ast_append(current, new Ctor(current, ref));
            current.sourceIndex = start;
            break;

           case go_objectKey:
            if (125 === parser_skipWhitespace()) {
              continue;
            }
            var key = parser_getRef();
            if (58 !== parser_skipWhitespace()) {
              //:
              return util_throw(template, index, 'Object parser. Semicolon expeted', c);
            }
            index++;
            current = current.nextProp(key);
            directive = go_ref;
            continue;
          }
        }
        if (null == current.body && current.type === type_Statement) {
          return util_throw(template, index, 'Unexpected end of expression', c);
        }
        ast_handlePrecedence(ast);
        return ast;
      };
      function parser_skipWhitespace() {
        var c;
        while (index < length) {
          c = template.charCodeAt(index);
          if (c > 32) {
            return c;
          }
          index++;
        }
        return null;
      }
      function parser_getString(c) {
        var nindex, string, isEscaped = false, _char = 39 === c ? '\'' : '"', start = index;
        while ((nindex = template.indexOf(_char, index)) > -1) {
          index = nindex;
          if (92 /*'\\'*/ !== template.charCodeAt(nindex - 1)) {
            break;
          }
          isEscaped = true;
          index++;
        }
        string = template.substring(start, index);
        if (true === isEscaped) {
          string = string.replace(__rgxEscapedChar[_char], _char);
        }
        return string;
      }
      function parser_getNumber() {
        var code, isDouble, start = index;
        while (true) {
          code = template.charCodeAt(index);
          if (46 === code) {
            // .
            if (true === isDouble) {
              util_throw(template, index, 'Invalid number', code);
              return null;
            }
            isDouble = true;
          }
          if ((code >= 48 && code <= 57 || 46 === code) && index < length) {
            index++;
            continue;
          }
          break;
        }
        return +template.substring(start, index);
      }
      function parser_getRef() {
        var ref, start = index, c = template.charCodeAt(index);
        if (34 === c || 39 === c) {
          // ' | "
          index++;
          ref = parser_getString(c);
          index++;
          return ref;
        }
        while (true) {
          if (index === length) {
            break;
          }
          c = template.charCodeAt(index);
          if (36 === c || 95 === c) {
            // $ _
            index++;
            continue;
          }
          if (48 <= c && c <= 57 || // 0-9
          65 <= c && c <= 90 || // A-Z
          97 <= c && c <= 122) {
            // a-z
            index++;
            continue;
          }
          // - [removed] (exit on not allowed chars) 5ba755ca
                    break;
        }
        return template.substring(start, index);
      }
      function parser_getDirective(code) {
        if (null == code && index === length) {
          return null;
        }
        switch (code) {
         case 40 /*(*/ :
          return punc_ParenthesisOpen;

         case 41 /*)*/ :
          return punc_ParenthesisClose;

         case 123 /*{*/ :
          return punc_BraceOpen;

         case 125 /*}*/ :
          return punc_BraceClose;

         case 91 /*[*/ :
          return punc_BracketOpen;

         case 93 /*]*/ :
          return punc_BracketClose;

         case 44 /*,*/ :
          return punc_Comma;

         case 46 /*.*/ :
          return punc_Dot;

         case 59 /*;*/ :
          return punc_Semicolon;

         case 43 /*+*/ :
          return op_Plus;

         case 45 /*-*/ :
          if (62 /*>*/ === template.charCodeAt(index + 1)) {
            index++;
            return op_AsyncAccessor;
          }
          return op_Minus;

         case 42 /* * */ :
          return op_Multip;

         case 47 /*/*/ :
          return op_Divide;

         case 37 /*%*/ :
          return op_Modulo;

         case 61 /*=*/ :
          if (template.charCodeAt(++index) !== code) {
            util_throw(template, index, 'Assignment violation: View can only access model/controllers', '=');
            return null;
          }
          if (template.charCodeAt(index + 1) === code) {
            index++;
            return op_LogicalEqual_Strict;
          }
          return op_LogicalEqual;

         case 33 /*!*/ :
          if (61 === template.charCodeAt(index + 1)) {
            // =
            index++;
            if (61 === template.charCodeAt(index + 1)) {
              // =
              index++;
              return op_LogicalNotEqual_Strict;
            }
            return op_LogicalNotEqual;
          }
          return op_LogicalNot;

         case 62 /*>*/ :
          var next = template.charCodeAt(index + 1);
          if (61 /*=*/ === next) {
            index++;
            return op_LogicalGreaterEqual;
          }
          if (62 /*>*/ === next) {
            index++;
            return op_ObserveAccessor;
          }
          return op_LogicalGreater;

         case 60 /*<*/ :
          if (61 === template.charCodeAt(index + 1)) {
            index++;
            return op_LogicalLessEqual;
          }
          return op_LogicalLess;

         case 38 /*&*/ :
          if (template.charCodeAt(++index) !== code) {
            return op_BitAnd;
          }
          return op_LogicalAnd;

         case 124 /*|*/ :
          if (template.charCodeAt(++index) !== code) {
            return op_BitOr;
          }
          return op_LogicalOr;

         case 94 /*^*/ :
          return op_BitXOr;

         case 63 /*?*/ :
          return punc_Question;

         case 58 /*:*/ :
          return punc_Colon;
        }
        if (code >= 65 && code <= 90 || code >= 97 && code <= 122 || 95 === code || 36 === code) {
          // A-Z a-z _ $
          return go_ref;
        }
        if (code >= 48 && code <= 57) {
          // 0-9 .
          return go_number;
        }
        if (34 === code || 39 === code) {
          // " '
          return go_string;
        }
        util_throw(template, index, 'Unexpected or unsupported directive', code);
        return null;
      }
      function ast_append(current, next) {
        switch (current.type) {
         case type_Body:
          current.body.push(next);
          return next;

         case type_Statement:
          if (next.type === type_Accessor || next.type === type_AccessorExpr) {
            return current.next = next;
          }

          /* fall through */         case type_UnaryPrefix:
          return current.body = next;

         case type_SymbolRef:
         case type_FunctionRef:
         case type_Accessor:
         case type_AccessorExpr:
          return current.next = next;
        }
        return util_throw(template, index, 'Invalid expression');
      }
    })();
    var _evaluate, _evaluateAst;
    (function() {
      var _evaluateAstDeferred, _evaluateAstDeferredInner;
      (function() {
        var SubjectStream, Subscription, PromisedStream;
        var SubjectKind;
        (function() {
          (function(SubjectKind) {
            SubjectKind[SubjectKind['Value'] = 0] = 'Value';
            SubjectKind[SubjectKind['Stream'] = 1] = 'Stream';
            SubjectKind[SubjectKind['Promise'] = 2] = 'Promise';
          })(SubjectKind = SubjectKind || {});
        })();
        var DeferredExp;
        (function() {
          (function() {
            (function() {
              (function() {
                Subscription = /** @class */ function() {
                  function Subscription(stream, cb) {
                    this.stream = stream;
                    this.cb = cb;
                  }
                  Subscription.prototype.unsubscribe = function() {
                    this.stream.unsubscribe(this.cb);
                  };
                  return Subscription;
                }();
              })();
              SubjectStream = /** @class */ function() {
                function SubjectStream() {
                  this._value = void 0;
                  this._error = void 0;
                  this.cbs = [];
                  this.kind = SubjectKind.Stream;
                  this.canceled = false;
                  this.next = this.next.bind(this);
                  this.error = this.error.bind(this);
                }
                SubjectStream.prototype.next = function(x) {
                  if (x === this._value) {
                    return;
                  }
                  this._error = void 0;
                  this._value = x;
                  this.call(0, x);
                };
                SubjectStream.prototype.error = function(err) {
                  this._error = err;
                  this.call(1, err);
                };
                SubjectStream.prototype.current = function() {
                  return this._value;
                };
                SubjectStream.prototype.isBusy = function() {
                  return void 0 === this._value;
                };
                SubjectStream.prototype.fromStream = function(stream) {
                  this._pipe = stream;
                  if (0 !== this.cbs.length) {
                    stream.subscribe(this.next, this.error);
                  }
                };
                SubjectStream.prototype.subscribe = function(cb, onError) {
                  if (null != this._pipe && 0 === this.cbs.length) {
                    this._pipe.subscribe(this.next, this.error);
                  }
                  this.cbs.push([ cb, onError, null ]);
                  if (void 0 !== this._value) {
                    cb(this._value);
                  }
                  return new Subscription(this, cb);
                };
                SubjectStream.prototype.unsubscribe = function(cb) {
                  for (var i = 0; i < this.cbs.length; i++) {
                    if (this.cbs[i][0] === cb) {
                      this.cbs.splice(i, 1);
                    }
                  }
                  if (null != this._pipe && 0 === this.cbs.length) {
                    this._pipe.unsubscribe(this.next);
                    return;
                  }
                };
                SubjectStream.prototype.call = function(index, x) {
                  for (var i = 0; i < this.cbs.length; i++) {
                    var row = this.cbs[i];
                    var fn = row[index];
                    var opts = row[2];
                    if (opts && true === opts.once) {
                      this.cbs.splice(i, 1);
                    }
                    fn(x);
                  }
                };
                return SubjectStream;
              }();
            })();
            var __extends = this && this.__extends || function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(d, b) {
                  d.__proto__ = b;
                } || function(d, b) {
                  for (var p in b) {
                    if (b.hasOwnProperty(p)) {
                      d[p] = b[p];
                    }
                  }
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            PromisedStream = /** @class */ function(_super) {
              __extends(PromisedStream, _super);
              function PromisedStream() {
                return null !== _super && _super.apply(this, arguments) || this;
              }
              PromisedStream.prototype.resolve = function(x) {
                this.next(x);
              };
              PromisedStream.prototype.reject = function(err) {
                this.error(err);
              };
              PromisedStream.prototype.then = function(onSuccess, onError) {
                if (void 0 !== this._error) {
                  onError && onError(this._error);
                  return;
                }
                if (void 0 !== this._value) {
                  onSuccess && onSuccess(this._value);
                  return;
                }
                this.cbs.push([ onSuccess, onError, {
                  once: true
                } ]);
                if (null != this._pipe && 1 === this.cbs.length) {
                  if ('then' in this._pipe) {
                    this._pipe.then(this.next, this.error);
                    return;
                  }
                  if ('subscribe' in this._pipe) {
                    this._pipe.subscribe(this.next, this.error);
                    return;
                  }
                }
              };
              return PromisedStream;
            }(SubjectStream);
          })();
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p in b) {
                  if (b.hasOwnProperty(p)) {
                    d[p] = b[p];
                  }
                }
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          DeferredExp = /** @class */ function(_super) {
            __extends(DeferredExp, _super);
            function DeferredExp(deferred, root, model, ctx, ctr) {
              var _this = _super.call(this) || this;
              _this.deferred = deferred;
              _this.root = root;
              _this.model = model;
              _this.ctx = ctx;
              _this.ctr = ctr;
              _this.tick = _this.tick.bind(_this);
              return _this;
            }
            DeferredExp.prototype.subscribe = function(cb, onError) {
              for (var i = 0; i < this.deferred.length; i++) {
                var dfr = this.deferred[i];
                if (dfr.kind === SubjectKind.Stream) {
                  dfr.subscribe(this.tick);
                }
              }
              return _super.prototype.subscribe.call(this, cb, onError);
            };
            DeferredExp.prototype.unsubscribe = function(cb) {
              _super.prototype.unsubscribe.call(this, cb);
              for (var i = 0; i < this.deferred.length; i++) {
                var dfr = this.deferred[i];
                if (dfr.kind === SubjectKind.Stream) {
                  dfr.unsubscribe(this.tick);
                }
              }
            };
            DeferredExp.prototype.tick = function() {
              var preResults = [];
              for (var i = 0; i < this.deferred.length; i++) {
                var dfr = this.deferred[i];
                if (dfr.isBusy()) {
                  return;
                }
                preResults[i] = dfr.current();
              }
              var val = _evaluateAst(this.root, this.model, this.ctx, this.ctr, preResults);
              this.next(val);
            };
            DeferredExp.prototype.cancel = function() {
              this.deferred.map(function(x) {
                return x.cancel();
              });
            };
            return DeferredExp;
          }(PromisedStream);
        })();
        var getDeferrables;
        (function() {
          var AwaitableCtx;
          (function() {
            var __extends = this && this.__extends || function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(d, b) {
                  d.__proto__ = b;
                } || function(d, b) {
                  for (var p in b) {
                    if (b.hasOwnProperty(p)) {
                      d[p] = b[p];
                    }
                  }
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            AwaitableCtx = function(ctx) {
              if (is_PromiseLike(ctx)) {
                return new PromiseCtx(ctx);
              }
              if (is_Observable(ctx)) {
                return new ObservableCtx(ctx);
              }
              return new ValueCtx(ctx);
            };
            var IAwaitableCtx = /** @class */ function(_super) {
              __extends(IAwaitableCtx, _super);
              function IAwaitableCtx(ctx) {
                var _this = _super.call(this) || this;
                _this.ctx = ctx;
                _this.kind = SubjectKind.Promise;
                _this.ctx = ctx;
                return _this;
              }
              return IAwaitableCtx;
            }(PromisedStream);
            var ValueCtx = /** @class */ function(_super) {
              __extends(ValueCtx, _super);
              function ValueCtx(ctx) {
                var _this = _super.call(this, ctx) || this;
                _this.resolve(ctx);
                return _this;
              }
              ValueCtx.prototype.cancel = function() {};
              return ValueCtx;
            }(IAwaitableCtx);
            var PromiseCtx = /** @class */ function(_super) {
              __extends(PromiseCtx, _super);
              function PromiseCtx(ctx) {
                var _this = _super.call(this, ctx) || this;
                _this.onSuccess = _this.onSuccess.bind(_this);
                _this.onFail = _this.onFail.bind(_this);
                ctx.then(_this.onSuccess, _this.onFail);
                return _this;
              }
              PromiseCtx.prototype.onSuccess = function(val) {
                if (this.canceled) {
                  return;
                }
                this.resolve(val);
              };
              PromiseCtx.prototype.onFail = function(err) {
                if (this.canceled) {
                  return;
                }
                this.reject(err);
              };
              PromiseCtx.prototype.cancel = function() {
                this.canceled = true;
              };
              return PromiseCtx;
            }(IAwaitableCtx);
            var ObservableCtx = /** @class */ function(_super) {
              __extends(ObservableCtx, _super);
              function ObservableCtx(ctx) {
                var _this = _super.call(this, ctx) || this;
                _this.onValue = _this.onValue.bind(_this);
                ctx.subscribe(_this.onValue);
                return _this;
              }
              ObservableCtx.prototype.onValue = function(val) {
                if (this.canceled) {
                  return;
                }
                this.cancel();
                this.resolve(val);
              };
              ObservableCtx.prototype.cancel = function() {
                this.canceled = true;
                this.ctx.unsubscribe(this.onValue);
              };
              return ObservableCtx;
            }(IAwaitableCtx);
          })();
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p in b) {
                  if (b.hasOwnProperty(p)) {
                    d[p] = b[p];
                  }
                }
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          getDeferrables = function(mix, out) {
            if (void 0 === out) {
              out = [];
            }
            if (null == mix) {
              return out;
            }
            if (is_Array(mix)) {
              for (var i = 0; i < mix.length; i++) {
                getDeferrables(mix[i], out);
              }
              return out;
            }
            var expr = mix;
            var type = expr.type;
            if (type === type_Statement) {
              if (true === expr.observe) {
                expr.preResultIndex = out.length;
                out.push(new DeferStatement(expr));
                return out;
              }
              if (true === expr.async) {
                expr.preResultIndex = out.length;
                out.push(new DeferStatement(expr));
                return out;
              }
            }
            switch (type) {
             case type_Body:
              getDeferrables(expr.body, out);
              break;

             case type_FunctionRef:
              getDeferrables(expr.arguments, out);
              break;

             case type_SymbolRef:
              getDeferrables(expr.next, out);
              break;

             case type_Statement:
             case type_UnaryPrefix:
             case type_Ternary:
              getDeferrables(expr.body, out);
              break;
            }
            return out;
          };
          var DeferStatement = /** @class */ function(_super) {
            __extends(DeferStatement, _super);
            function DeferStatement(statement) {
              var _this = _super.call(this) || this;
              _this.statement = statement;
              return _this;
            }
            /**
					     * Get current value for the statement to calculate full expression result
					     * Subscription is made later
					     * */            DeferStatement.prototype.process = function(model, ctx, ctr) {
              var _this = this;
              this.deferExp = _evaluateAstDeferredInner(this.statement, model, ctx, ctr);
              switch (this.deferExp.kind) {
               case SubjectKind.Value:
               case SubjectKind.Promise:
                this.kind = SubjectKind.Promise;
                break;

               case SubjectKind.Stream:
                this.kind = SubjectKind.Stream;
                break;
              }
              this.deferExp.then(function(context) {
                _this.ctx = AwaitableCtx(context);
                _this.ctx.then(function(result) {
                  _this.resolve(result);
                }, function(error) {
                  this.reject(error);
                });
              }, function(err) {
                return _this.reject(err);
              });
              return this;
            };
            DeferStatement.prototype.subscribe = function(cb, onError) {
              if (0 === this.cbs.length) {
                this.deferExp.subscribe(this.next);
              }
              return _super.prototype.subscribe.call(this, cb, onError);
            };
            DeferStatement.prototype.unsubscribe = function(cb) {
              _super.prototype.unsubscribe.call(this, cb);
              if (0 === this.cbs.length) {
                this.deferExp.unsubscribe(this.next);
              }
            };
            DeferStatement.prototype.cancel = function() {
              this.deferExp && this.deferExp.cancel();
              this.ctx && this.ctx.cancel();
            };
            return DeferStatement;
          }(PromisedStream);
          DeferStatement;
        })();
        var ObjectStream;
        (function() {
          (function() {
            (function() {
              (function() {
                prop_OBS = '__observers';
                prop_MUTATORS = '__mutators';
                prop_TIMEOUT = '__dfrTimeout';
                prop_DIRTY = '__dirty';
                var prop_REBINDERS = '__rebinders';
                prop_PROXY = '__proxies';
                obj_defineProp = Object.defineProperty;
                obj_ensureFieldDeep = function(obj, chain) {
                  var i = -1, imax = chain.length - 1;
                  while (++i < imax) {
                    var key = chain[i];
                    if (null == obj[key]) {
                      obj[key] = {};
                    }
                    obj = obj[key];
                  }
                  return obj;
                };
                obj_ensureObserversProperty = function(obj, prop) {
                  var obs = obj[prop_OBS];
                  if (null == obs) {
                    obs = {
                      __dirty: null,
                      __dfrTimeout: null,
                      __mutators: null,
                      __rebinders: {},
                      __proxies: {}
                    };
                    obj_defineProp(obj, prop_OBS, {
                      value: obs,
                      enumerable: false
                    });
                  }
                  if (null == prop) {
                    return obs;
                  }
                  var arr = obs[prop];
                  return null == arr ? obs[prop] = [] : arr;
                };
                obj_getObserversProperty = function(obj, type) {
                  var obs = obj[prop_OBS];
                  return null == obs ? null : obs[type];
                };
                obj_ensureRebindersProperty = function(obj) {
                  var hash = obj[prop_REBINDERS];
                  if (null == hash) {
                    hash = {};
                    obj_defineProp(obj, prop_REBINDERS, {
                      value: hash,
                      enumerable: false
                    });
                  }
                  return hash;
                };
                obj_chainToProp = function(chain, start) {
                  var str = '', imax = chain.length, i = start - 1;
                  while (++i < imax) {
                    if (i !== start) {
                      str += '.';
                    }
                    str += chain[i];
                  }
                  return str;
                };
              })();
              (function() {
                objMutator_addObserver = function(obj, mutators, cb) {
                  var methods = mutators.methods, throttle = mutators.throttle, obs = obj_ensureObserversProperty(obj, prop_MUTATORS);
                  if (0 === obs.length) {
                    var method, fn, imax = methods.length, i = -1;
                    while (++i < imax) {
                      method = methods[i];
                      fn = obj[method];
                      if (null == fn) {
                        continue;
                      }
                      obj[method] = objMutator_createWrapper_(obj, fn, method, throttle);
                    }
                  }
                  obs[obs.length++] = cb;
                };
                objMutator_removeObserver = function(obj, mutators, cb) {
                  var obs = obj_getObserversProperty(obj, prop_MUTATORS);
                  if (null == obs) {
                    return;
                  }
                  if (void 0 === cb) {
                    obs.length = 0;
                    return;
                  }
                  arr_remove(obs, cb);
                };
                function objMutator_createWrapper_(obj, originalFn, method, throttle) {
                  var fn = true === throttle ? callDelayed : call;
                  return function() {
                    return fn(obj, originalFn, method, _Array_slice.call(arguments));
                  };
                }
                function call(obj, original, method, args) {
                  var cbs = obj_ensureObserversProperty(obj, prop_MUTATORS), result = original.apply(obj, args);
                  tryNotify(obj, cbs, method, args, result);
                  return result;
                }
                function callDelayed(obj, original, method, args) {
                  var cbs = obj_ensureObserversProperty(obj, prop_MUTATORS), result = original.apply(obj, args);
                  var obs = obj[prop_OBS];
                  if (null != obs[prop_TIMEOUT]) {
                    return result;
                  }
                  obs[prop_TIMEOUT] = setTimeout(function() {
                    obs[prop_TIMEOUT] = null;
                    tryNotify(obj, cbs, method, args, result);
                  });
                  return result;
                }
                function tryNotify(obj, cbs, method, args, result) {
                  if (0 === cbs.length) {
                    return;
                  }
                  var obs = obj[prop_OBS];
                  if (null != obs[prop_DIRTY]) {
                    obs[prop_DIRTY][prop_MUTATORS] = 1;
                    return;
                  }
                  var x, imax = cbs.length, i = -1;
                  while (++i < imax) {
                    x = cbs[i];
                    if ('function' === typeof x) {
                      x(obj, method, args, result);
                    }
                  }
                }
              })();
              (function() {
                //Resolve object, or if property do not exists - create
                getSelfMutators = function(obj) {
                  if (false === is_Object(obj)) {
                    return null;
                  }
                  if (is_ArrayLike(obj)) {
                    return MUTATORS_.Array;
                  }
                  if (is_Date(obj)) {
                    return MUTATORS_.Date;
                  }
                  return null;
                };
                var MUTATORS_ = {
                  Array: {
                    throttle: false,
                    methods: [ 
                    // native mutators
                    'push', 'unshift', 'splice', 'pop', 'shift', 'reverse', 'sort', 
                    // collection mutators
                    'remove' ]
                  },
                  Date: {
                    throttle: true,
                    methods: [ 'setDate', 'setFullYear', 'setHours', 'setMilliseconds', 'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds' ]
                  }
                };
              })();
              (function() {
                /* return false, when path contains null values */
                obj_defineCrumbs = function(obj, chain) {
                  var key, rebinder = obj_crumbRebindDelegate(obj), path = '';
                  var imax = chain.length - 1, i = 0, x = obj;
                  for (;i < imax; i++) {
                    key = chain[i];
                    path += key + '.';
                    obj_defineCrumb(path, x, key, rebinder);
                    x = x[key];
                    if (null == x || 'object' !== typeof x) {
                      return false;
                    }
                  }
                  return true;
                };
                function obj_defineCrumb(path, obj, key, rebinder) {
                  var cbs = obj[prop_OBS] && obj[prop_OBS][key];
                  if (null != cbs) {
                    return;
                  }
                  var old, value = obj[key];
                  var hash = obj_ensureRebindersProperty(obj);
                  var set = hash[key];
                  if (null != set) {
                    if (null == set[path]) {
                      set[path] = rebinder;
                    }
                    return;
                  }
                  set = hash[key] = {};
                  set[path] = rebinder;
                  obj_defineProp(obj, key, {
                    get: function() {
                      return value;
                    },
                    set: function(x) {
                      if (x === value) {
                        return;
                      }
                      old = value;
                      value = x;
                      for (var _path in set) {
                        set[_path](_path, old);
                      }
                    },
                    configurable: true,
                    enumerable: true
                  });
                }
                function obj_crumbRebindDelegate(obj) {
                  return function(path, oldValue) {
                    obj_crumbRebind(obj, path, oldValue);
                  };
                }
                function obj_crumbRebind(obj, path, oldValue) {
                  var obs = obj[prop_OBS];
                  if (null == obs) {
                    return;
                  }
                  for (var prop in obs) {
                    if (0 !== prop.indexOf(path)) {
                      continue;
                    }
                    var cbs = obs[prop].slice(0), imax = cbs.length, i = 0;
                    if (0 === imax) {
                      continue;
                    }
                    var val = obj_getProperty(obj, prop), oldProp = prop.substring(path.length), oldVal = obj_getProperty(oldValue, oldProp);
                    for (i = 0; i < imax; i++) {
                      var cb = cbs[i];
                      obj_removeObserver(obj, prop, cb);
                      if (null != oldValue && 'object' === typeof oldValue) {
                        obj_removeObserver(oldValue, oldProp, cb);
                      }
                    }
                    if (oldVal !== val) {
                      for (i = 0; i < imax; i++) {
                        cbs[i](val);
                      }
                    }
                    for (i = 0; i < imax; i++) {
                      obj_addObserver(obj, prop, cbs[i]);
                    }
                  }
                }
              })();
              (function() {
                obj_sub_notifyListeners = function(obj, path, oldVal) {
                  var obs = obj[prop_OBS];
                  if (null == obs) {
                    return;
                  }
                  for (var prop in obs) {
                    if (0 !== prop.indexOf(path + '.')) {
                      continue;
                    }
                    var oldProp, cb, cbs = obs[prop].slice(0), imax = cbs.length, i = 0;
                    if (0 === imax) {
                      continue;
                    }
                    var val = obj_getProperty(obj, prop);
                    for (i = 0; i < imax; i++) {
                      cb = cbs[i];
                      obj_removeObserver(obj, prop, cb);
                      if (null != oldVal && 'object' === typeof oldVal) {
                        oldProp = prop.substring(path.length + 1);
                        obj_removeObserver(oldVal, oldProp, cb);
                      }
                    }
                    for (i = 0; i < imax; i++) {
                      cbs[i](val);
                    }
                    for (i = 0; i < imax; i++) {
                      obj_addObserver(obj, prop, cbs[i]);
                    }
                  }
                };
                obj_deep_notifyListeners = function(obj, chain, oldVal, currentVal, fns) {
                  var i = 0, imax = chain.length, ctx = obj, arr = fns.slice(0);
                  do {
                    ctx = ctx[chain[i]];
                    if (null == ctx) {
                      return;
                    }
                    var obs = ctx[prop_OBS];
                    if (null == obs) {
                      continue;
                    }
                    var prop = obj_chainToProp(chain, i + 1);
                    var cbs = obs[prop];
                    if (null == cbs) {
                      continue;
                    }
                    for (var j = 0; j < cbs.length; j++) {
                      var cb = cbs[j];
                      if (-1 !== arr.indexOf(cb)) {
                        continue;
                      }
                      cb(currentVal);
                      arr.push(cb);
                    }
                  } while (++i < imax - 1);
                };
              })();
              var AddObserver;
              (function(AddObserver) {
                function add(obj, property, cb) {
                  if (null == obj) {
                    log_error('Not possible to add the observer for "' + property + '" as the model is undefined.');
                    return;
                  }
                  // closest observer
                                    var parts = property.split('.'), i = -1;
                  if (pushClosest(obj[parts[0]], parts, 1, cb)) {
                    /* We have added a callback as close as possible to the observle property owner
							             * But also add the cb to myself to listen different object path level setters
							             */
                    var cbs_1 = pushListener_(obj, property, cb);
                    if (1 === cbs_1.length) {
                      var arr = parts.splice(0, i);
                      if (0 !== arr.length) {
                        attachProxy_(obj, property, cbs_1, arr);
                      }
                    }
                    if (parts.length > 1) {
                      obj_defineCrumbs(obj, parts);
                    }
                    return;
                  }
                  var cbs = pushListener_(obj, property, cb);
                  if (1 === cbs.length) {
                    attachProxy_(obj, property, cbs, parts);
                  }
                  var val = obj_getProperty(obj, property), mutators = getSelfMutators(val);
                  if (null != mutators) {
                    objMutator_addObserver(val, mutators, cb);
                  }
                }
                AddObserver.add = add;
                function pushClosest(ctx, parts, i, cb) {
                  if (null == ctx) {
                    return false;
                  }
                  if (i < parts.length - 1 && pushClosest(ctx[parts[i]], parts, i + 1, cb)) {
                    return true;
                  }
                  var obs = ctx[prop_OBS];
                  if (null == obs) {
                    return false;
                  }
                  var prop = obj_chainToProp(parts, i);
                  var arr = obs[prop];
                  if (null == arr) {
                    // fix [obj.test](hosts)
                    var proxy = obs[prop_PROXY];
                    if (null != proxy && true === proxy[prop]) {
                      pushListener_(ctx, prop, cb);
                      var x = obj_getProperty(ctx, prop);
                      var mutators = getSelfMutators(x);
                      if (mutators) {
                        objMutator_addObserver(x, mutators, cb);
                      }
                      return true;
                    }
                    return false;
                  }
                  pushListener_(ctx, prop, cb);
                  return true;
                }
              })(AddObserver = AddObserver || {});
              obj_addObserver = AddObserver.add;
              obj_hasObserver = function(obj, property, callback) {
                // nested observer
                var parts = property.split('.'), imax = parts.length, i = -1, x = obj;
                while (++i < imax) {
                  x = x[parts[i]];
                  if (null == x) {
                    break;
                  }
                  if (null != x[prop_OBS]) {
                    if (obj_hasObserver(x, parts.slice(i + 1).join('.'), callback)) {
                      return true;
                    }
                    break;
                  }
                }
                var obs = obj[prop_OBS];
                if (null == obs || null == obs[property]) {
                  return false;
                }
                return arr_contains(obs[property], callback);
              };
              obj_removeObserver = function(obj, property, callback) {
                if (null == obj) {
                  log_error('Not possible to remove the observer for "' + property + '" as current model is undefined.');
                  return;
                }
                // nested observer
                                var parts = property.split('.'), imax = parts.length, i = -1, x = obj;
                while (++i < imax) {
                  x = x[parts[i]];
                  if (null == x) {
                    break;
                  }
                  if (null != x[prop_OBS]) {
                    obj_removeObserver(x, parts.slice(i + 1).join('.'), callback);
                    break;
                  }
                }
                var obs = obj_getObserversProperty(obj, property);
                if (null != obs) {
                  if (void 0 === callback) {
                    // callback not provided -> remove all observers
                    obs.length = 0;
                  } else {
                    arr_remove(obs, callback);
                  }
                }
                var val = obj_getProperty(obj, property);
                var mutators = getSelfMutators(val);
                if (null != mutators) {
                  objMutator_removeObserver(val, mutators, callback);
                }
              };
              obj_lockObservers = function(obj) {
                var obs = obj[prop_OBS];
                if (null != obs) {
                  obs[prop_DIRTY] = {};
                }
              };
              obj_unlockObservers = function(obj) {
                var obs = obj[prop_OBS], dirties = null == obs ? null : obs[prop_DIRTY];
                if (null == dirties) {
                  return;
                }
                obs[prop_DIRTY] = null;
                var prop, cbs, val, imax, i;
                for (prop in dirties) {
                  cbs = obj[prop_OBS][prop];
                  imax = null == cbs ? 0 : cbs.length;
                  if (0 === imax) {
                    continue;
                  }
                  i = -1;
                  val = prop === prop_MUTATORS ? obj : obj_getProperty(obj, prop);
                  while (++i < imax) {
                    cbs[i](val);
                  }
                }
              };
              obj_addMutatorObserver = function(obj, cb) {
                var mutators = getSelfMutators(obj);
                if (null != mutators) {
                  objMutator_addObserver(obj, mutators, cb);
                }
              };
              obj_removeMutatorObserver = function(obj, cb) {
                objMutator_removeObserver(obj, null, cb);
              };
              function attachProxy_(obj, property, cbs, chain) {
                var length = chain.length;
                if (length > 1) {
                  if (false === obj_defineCrumbs(obj, chain)) {
                    return;
                  }
                }
                // TODO: ensure is not required, as defineCrumbs returns false when path contains null value */
                                var parent = length > 1 ? obj_ensureFieldDeep(obj, chain) : obj;
                var key = chain[length - 1];
                var currentVal = parent[key];
                if ('length' === key) {
                  var mutators = getSelfMutators(parent);
                  if (null != mutators) {
                    objMutator_addObserver(parent, mutators, function() {
                      var imax = cbs.length, i = -1;
                      while (++i < imax) {
                        cbs[i].apply(null, arguments);
                      }
                    });
                    return currentVal;
                  }
                }
                var obs = obj_ensureObserversProperty(parent);
                var hash = obs[prop_PROXY];
                if (true === hash[key]) {
                  return;
                }
                hash[key] = true;
                obj_defineProp(parent, key, {
                  get: function() {
                    return currentVal;
                  },
                  set: function(x) {
                    if (x === currentVal) {
                      return;
                    }
                    var imax = cbs.length;
                    var oldVal = currentVal;
                    var oldMutators = getSelfMutators(oldVal);
                    if (null != oldMutators) {
                      for (var i = 0; i < imax; i++) {
                        objMutator_removeObserver(oldVal, oldMutators, cbs[i]);
                      }
                    }
                    currentVal = x;
                    var mutators = getSelfMutators(x);
                    if (null != mutators) {
                      for (i = 0; i < imax; i++) {
                        objMutator_addObserver(x, mutators, cbs[i]);
                      }
                    }
                    if (null != obj[prop_OBS][prop_DIRTY]) {
                      obj[prop_OBS][prop_DIRTY][property] = 1;
                      return;
                    }
                    for (i = 0; i < imax; i++) {
                      cbs[i](x);
                    }
                    obj_sub_notifyListeners(obj, property, oldVal);
                    obj_deep_notifyListeners(obj, chain, oldVal, currentVal, cbs);
                  },
                  configurable: true,
                  enumerable: true
                });
                return currentVal;
              }
              // Create Collection - Check If Exists - Add Listener
                            function pushListener_(obj, property, cb) {
                var obs = obj_ensureObserversProperty(obj, property);
                if (false === arr_contains(obs, cb)) {
                  obs.push(cb);
                }
                return obs;
              }
            })();
            (function() {
              (function() {
                obj_callMethod = function(obj, path, args) {
                  var end = path.lastIndexOf('.');
                  if (-1 === end) {
                    return call(obj, path, args);
                  }
                  var host = obj, i = -1;
                  while (null != host && i !== end) {
                    var start = i;
                    i = path.indexOf('.', i);
                    var key = path.substring(start + 1, i);
                    host = host[key];
                  }
                  return call(host, path.substring(end + 1), args);
                };
                function call(obj, key, args) {
                  var fn = null == obj ? null : obj[key];
                  if ('function' !== typeof fn) {
                    console.error('Not a function', key);
                    return null;
                  }
                  return fn.apply(obj, args);
                }
              })();
              expression_bind = function(expr, model, ctx, ctr, cb) {
                if ('.' === expr) {
                  if (null != model) {
                    obj_addMutatorObserver(model, cb);
                  }
                  return;
                }
                toggleExpressionsBindings(obj_addObserver, expr, model, ctr, cb);
              };
              expression_unbind = function(expr, model, ctr, cb) {
                if ('.' === expr) {
                  if (null != model) {
                    obj_removeMutatorObserver(model, cb);
                  }
                  return;
                }
                toggleExpressionsBindings(obj_removeObserver, expr, model, ctr, cb);
              };
              function toggleExpressionsBindings(fn, expr, model, ctr, cb) {
                var mix = expression_varRefs(expr, model, null, ctr);
                if (null == mix) {
                  return null;
                }
                if ('string' === typeof mix) {
                  _toggleObserver(fn, model, ctr, mix, cb);
                  return;
                }
                var arr = mix, imax = arr.length, i = -1;
                while (++i < imax) {
                  var accs = arr[i];
                  if ('string' === typeof accs) {
                    if (95 /*_*/ === accs.charCodeAt(0) && 46 /*.*/ === accs.charCodeAt(0)) {
                      continue;
                    }
                  } else if ('object' === typeof accs) {
                    if ('_' === accs.ref) {
                      continue;
                    }
                  }
                  _toggleObserver(fn, model, ctr, accs, cb);
                }
              }
              expression_callFn = function(accessor, model, ctx, ctr, args) {
                var tuple = expression_getHost(accessor, model, ctx, ctr);
                if (null != tuple) {
                  var obj = tuple[0], path = tuple[1];
                  return obj_callMethod(obj, path, args);
                }
                return null;
              };
              /**
							 * expression_bind only fires callback, if some of refs were changed,
							 * but doesnt supply new expression value
							 **/              expression_createBinder = function(expr, model, ctx, ctr, fn) {
                return expression_createListener(function() {
                  var value = expression_eval(expr, model, ctx, ctr);
                  var args = _Array_slice.call(arguments);
                  args[0] = null == value ? '' : value;
                  fn.apply(this, args);
                });
              };
              expression_createListener = function(callback) {
                var locks = 0;
                return function() {
                  if (++locks > 1) {
                    locks = 0;
                    log_warn('<listener:expression> concurrent binder');
                    return;
                  }
                  callback.apply(this, _Array_slice.call(arguments));
                  locks--;
                };
              };
              (function() {
                // [ObjectHost, Property]
                var tuple = [ null, null ];
                expression_getHost = function(accessor, model, ctx, ctr) {
                  var result = get(accessor, model, ctx, ctr);
                  if (null == result || null == result[0]) {
                    error_withCompo('Observable host is undefined or is not allowed: ' + accessor.toString(), ctr);
                    return null;
                  }
                  return result;
                };
                function get(accessor, model, ctx, ctr) {
                  if (null == accessor) {
                    return;
                  }
                  if ('object' === typeof accessor) {
                    var obj = expression_eval(accessor.accessor, model, null, ctr);
                    if (null == obj || 'object' !== typeof obj) {
                      return null;
                    }
                    tuple[0] = obj;
                    tuple[1] = accessor.ref;
                    return tuple;
                  }
                  var property = accessor, parts = property.split('.'), imax = parts.length;
                  if (imax > 1) {
                    var first = parts[0];
                    if ('this' === first || '$c' === first || '$' === first) {
                      // Controller Observer
                      var owner = _getObservable_Controller(ctr, parts[1]);
                      var cutIdx = first.length + 1;
                      tuple[0] = owner;
                      tuple[1] = property.substring(cutIdx);
                      return tuple;
                    }
                    if ('$scope' === first) {
                      // Controller Observer
                      var scope = _getObservable_Scope(ctr, parts[1]);
                      cutIdx = 7;
                      tuple[0] = scope;
                      tuple[1] = property.substring(cutIdx);
                      return tuple;
                    }
                  }
                  obj = null;
                  if (_isDefined(model, parts[0])) {
                    obj = model;
                  }
                  if (null == obj) {
                    obj = _getObservable_Scope(ctr, parts[0]);
                  }
                  if (null == obj) {
                    obj = model;
                  }
                  tuple[0] = obj;
                  tuple[1] = property;
                  return tuple;
                }
              })();
              function _toggleObserver(mutatorFn, model, ctr, accessor, callback) {
                var tuple = expression_getHost(accessor, model, null, ctr);
                if (null == tuple) {
                  return;
                }
                var obj = tuple[0], property = tuple[1];
                if (null == obj) {
                  return;
                }
                mutatorFn(obj, property, callback);
              }
              function _getObservable_Controller(ctr_, key) {
                var ctr = ctr_;
                while (null != ctr) {
                  if (_isDefined(ctr, key)) {
                    return ctr;
                  }
                  ctr = ctr.parent;
                }
                return ctr;
              }
              function _getObservable_Scope(ctr_, property) {
                var scope, ctr = ctr_;
                while (null != ctr) {
                  scope = ctr.scope;
                  if (_isDefined(scope, property)) {
                    return scope;
                  }
                  ctr = ctr.parent;
                }
                return null;
              }
              function _isDefined(obj_, key_) {
                var key = key_;
                if (63 /*?*/ === key.charCodeAt(key.length - 1)) {
                  key = key.slice(0, -1);
                }
                return null != obj_ && key in obj_;
              }
            })();
          })();
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p in b) {
                  if (b.hasOwnProperty(p)) {
                    d[p] = b[p];
                  }
                }
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          ObjectStream = /** @class */ function(_super) {
            __extends(ObjectStream, _super);
            function ObjectStream(value, astNode, model, ctx, ctr) {
              var _this = _super.call(this) || this;
              _this.value = value;
              _this.astNode = astNode;
              _this.model = model;
              _this.ctx = ctx;
              _this.ctr = ctr;
              _this.kind = SubjectKind.Stream;
              _this.tick = _this.tick.bind(_this);
              _this.next(value);
              return _this;
            }
            ObjectStream.prototype.subscribe = function(cb, onError) {
              if (0 === this.cbs.length) {
                expression_bind(this.astNode, this.model, this.ctx, this.ctr, this.tick);
              }
              return _super.prototype.subscribe.call(this, cb, onError);
            };
            ObjectStream.prototype.unsubscribe = function(cb) {
              _super.prototype.unsubscribe.call(this, cb);
              if (0 === this.cbs.length) {
                expression_unbind(this.astNode, this.model, this.ctr, this.tick);
              }
            };
            ObjectStream.prototype.tick = function() {
              var val = _evaluateAst(this.astNode, this.model, null, this.ctr);
              this.next(val);
            };
            return ObjectStream;
          }(PromisedStream);
        })();
        // Avaitables and Observables
                _evaluateAstDeferred = function(root, model, ctx, ctr) {
          var x = _evaluateAstDeferredInner(root, model, ctx, ctr);
          if (x.kind === SubjectKind.Stream) {
            return x;
          }
          return x;
        };
        _evaluateAstDeferredInner = function(root, model, ctx, ctr) {
          var deferred = getDeferrables(root.body);
          var deferExp = new DeferredExp(deferred, root, model, ctx, ctr);
          if (0 === deferred.length) {
            var result = _evaluateAst(root, model, ctx, ctr);
            if (null == result) {
              util_throw(root, null, 'Awaitable is undefined');
            }
            if (true === root.observe) {
              if (false === is_Observable(result)) {
                result = new ObjectStream(result, root, model, ctx, ctr);
              }
              deferExp.kind = SubjectKind.Stream;
              deferExp.fromStream(result);
              return deferExp;
            }
            deferExp.kind = SubjectKind.Promise;
            deferExp.next(result);
            return deferExp;
          }
          var count = deferred.length, error = null, i = count;
          while (--i > -1) {
            var dfr = deferred[i];
            dfr.process(model, ctx, ctr).then(done, fail);
          }
          function done() {
            if (0 === --count && null == error) {
              var preResults = [];
              for (var i_1 = 0; i_1 < deferred.length; i_1++) {
                var dfr = deferred[i_1];
                preResults[i_1] = dfr.current();
              }
              var result = _evaluateAst(root, model, ctx, ctr, preResults);
              deferExp.resolve(result);
            }
          }
          function fail(err) {
            error = err;
            if (error === err) {
              deferExp.reject(error);
            }
          }
          return deferExp;
        };
      })();
      var cache = {};
      _evaluate = function(mix, model, ctx, ctr, node) {
        var ast;
        if (null == mix) {
          return null;
        }
        if ('.' === mix) {
          return model;
        }
        if ('string' === typeof mix) {
          var node_ = node;
          if (null == node_ && null != ctr) {
            var x = ctr;
            while (null == node_ && null != x) {
              node_ = x.node;
              x = x.parent;
            }
          }
          ast = true === cache.hasOwnProperty(mix) ? cache[mix] : cache[mix] = _parse(mix, false, node_);
        } else {
          ast = mix;
        }
        if (null == ast) {
          return null;
        }
        if (true === ast.observe || true === ast.async) {
          return _evaluateAstDeferred(ast, model, ctx, ctr);
        }
        return _evaluateAst(ast, model, ctx, ctr, null);
      };
      _evaluateAst = function(ast, model, ctx, ctr, preResults) {
        if (null == ast) {
          return null;
        }
        var result, x, type = ast.type;
        if (type_Body === type) {
          var value, prev;
          for (var i = 0, length = ast.body.length; i < length; i++) {
            x = ast.body[i];
            if (null != prev && prev.join === op_LogicalOr && result) {
              return result;
            }
            value = _evaluateAst(x, model, ctx, ctr, preResults);
            if (null == prev || null == prev.join) {
              prev = x;
              result = value;
              continue;
            }
            if (prev.join === op_LogicalAnd) {
              if (!result) {
                for (;i < length; i++) {
                  if (ast.body[i].join === op_LogicalOr) {
                    break;
                  }
                }
              } else {
                result = value;
              }
            }
            if (prev.join === op_LogicalOr) {
              if (value) {
                return value;
              }
              result = value;
              prev = x;
              continue;
            }
            switch (prev.join) {
             case op_Minus:
              result -= value;
              break;

             case op_Plus:
              result += value;
              break;

             case op_Divide:
              result /= value;
              break;

             case op_Multip:
              result *= value;
              break;

             case op_Modulo:
              result %= value;
              break;

             case op_BitOr:
              result |= value;
              break;

             case op_BitXOr:
              result ^= value;
              break;

             case op_BitAnd:
              result &= value;
              break;

             case op_LogicalNotEqual:
              /* jshint eqeqeq: false */
              result = result != value;
              /* jshint eqeqeq: true */              break;

             case op_LogicalNotEqual_Strict:
              result = result !== value;
              break;

             case op_LogicalEqual:
              /* jshint eqeqeq: false */
              result = result == value;
              /* jshint eqeqeq: true */              break;

             case op_LogicalEqual_Strict:
              result = result === value;
              break;

             case op_LogicalGreater:
              result = result > value;
              break;

             case op_LogicalGreaterEqual:
              result = result >= value;
              break;

             case op_LogicalLess:
              result = result < value;
              break;

             case op_LogicalLessEqual:
              result = result <= value;
              break;
            }
            prev = x;
          }
          return result;
        }
        if (type_Statement === type) {
          if ((true === ast.async || true === ast.observe) && ast.preResultIndex > -1 && null != preResults) {
            result = preResults[ast.preResultIndex];
          } else {
            result = _evaluateAst(ast.body, model, ctx, ctr, preResults);
          }
          if (null == ast.next) {
            return result;
          }
          return util_resolveAcc(result, ast.next, model, ctx, ctr, preResults);
        }
        if (type_Value === type) {
          return ast.body;
        }
        if (type_Array === type) {
          var body = ast.body.body, imax = body.length;
          i = -1;
          result = new Array(imax);
          while (++i < imax) {
            result[i] = _evaluateAst(body[i], model, ctx, ctr, preResults);
          }
          return result;
        }
        if (type_Object === type) {
          result = {};
          var props = ast.props;
          for (var key in props) {
            result[key] = _evaluateAst(props[key], model, ctx, ctr, preResults);
          }
          return result;
        }
        if (type_SymbolRef === type || type_FunctionRef === type) {
          result = util_resolveRefValue(ast, model, ctx, ctr, preResults);
          if (type === type_FunctionRef) {
            if (is_Function(result)) {
              var args = Ast_FunctionRefUtil.evalArguments(ast, model, ctx, ctr, preResults);
              result = result.apply(null, args);
            } else {
              error_(ast.body + ' is not a function', util_getNodeStack(ast));
            }
          }
          if (null != ast.next) {
            return util_resolveAcc(result, ast.next, model, ctx, ctr, preResults);
          }
          return result;
        }
        if (type_AccessorExpr === type || type_Accessor === type) {
          return util_resolveRef(ast, model, ctx, ctr);
        }
        if (type_UnaryPrefix === type) {
          result = _evaluateAst(ast.body, model, ctx, ctr, preResults);
          switch (ast.prefix) {
           case op_Minus:
            result = -result;
            break;

           case op_LogicalNot:
            result = !result;
            break;
          }
        }
        if (type_Ternary === type) {
          result = _evaluateAst(ast.body, model, ctx, ctr, preResults);
          result = _evaluateAst(result ? ast.case1 : ast.case2, model, ctx, ctr, preResults);
        }
        return result;
      };
    })();
    var _evaluateStatements;
    (function() {
      _evaluateStatements = function(expr, model, ctx, ctr, node) {
        var body = _parse(expr, false, node).body, args = [], imax = body.length, i = -1;
        var group = new Ast_Body();
        while (++i < imax) {
          group.body.push(body[i]);
          if (null != body[i].join) {
            continue;
          }
          args.push(_evaluateAst(group, model, ctx, ctr));
          group.body.length = 0;
        }
        return args;
      };
    })();
    var refs_extractVars;
    (function() {
      /**
			 * extract symbol references
			 * ~[:user.name + 'px'] -> 'user.name'
			 * ~[:someFn(varName) + user.name] -> ['varName', 'user.name']
			 *
			 * ~[:someFn().user.name] -> {accessor: (Accessor AST function call) , ref: 'user.name'}
			 */
      refs_extractVars = function(mix, model, ctx, ctr) {
        var ast = 'string' === typeof mix ? _parse(mix) : mix;
        return _extractVars(ast, model, ctx, ctr);
      };
      function _extractVars(expr, model, ctx, ctr) {
        if (null == expr) {
          return null;
        }
        var refs, x, exprType = expr.type;
        if (type_Body === exprType) {
          var body = expr.body, imax = body.length, i = -1;
          while (++i < imax) {
            x = _extractVars(body[i], model, ctx, ctr);
            refs = _append(refs, x);
          }
        }
        if (type_SymbolRef === exprType || type_Accessor === exprType || type_AccessorExpr === exprType) {
          var nextType, path = expr.body, next = expr.next;
          while (null != next) {
            nextType = next.type;
            if (type_FunctionRef === nextType) {
              return _extractVars(next, model, ctx, ctr);
            }
            if (type_SymbolRef !== nextType && type_Accessor !== nextType && type_AccessorExpr !== nextType) {
              log_error('Ast Exception: next should be a symbol/function ref');
              return null;
            }
            var prop = nextType === type_AccessorExpr ? _evaluateAst(next.body, model, ctx, ctr) : next.body;
            if ('string' !== typeof prop) {
              log_warn('Can`t extract accessor name', path);
              return null;
            }
            path += '.' + prop;
            next = next.next;
          }
          return path;
        }
        switch (exprType) {
         case type_Statement:
         case type_UnaryPrefix:
         case type_Ternary:
          x = _extractVars(expr.body, model, ctx, ctr);
          refs = _append(refs, x);
          break;
        }
        // get also from case1 and case2
                if (type_Ternary === exprType) {
          x = _extractVars(expr.case1, model, ctx, ctr);
          refs = _append(refs, x);
          x = _extractVars(expr.case2, model, ctx, ctr);
          refs = _append(refs, x);
        }
        if (type_FunctionRef === exprType) {
          var args = expr.arguments;
          imax = args.length, i = -1;
          while (++i < imax) {
            x = _extractVars(args[i], model, ctx, ctr);
            refs = _append(refs, x);
          }
          x = null;
          var parent = expr;
          outer: while (parent = parent.parent) {
            switch (parent.type) {
             case type_SymbolRef:
             case type_Accessor:
             case type_AccessorExpr:
              x = parent.body + (null == x ? '' : '.' + x);
              break;

             case type_Body:
             case type_Statement:
              break outer;

             default:
              x = null;
              break outer;
            }
          }
          if (null != x) {
            refs = _append(refs, x);
          }
          if (expr.next) {
            x = _extractVars(expr.next, model, ctx, ctr);
            refs = _append(refs, {
              accessor: _getAccessor(expr),
              ref: x
            });
          }
        }
        return refs;
      }
      function _append(current, x) {
        if (null == current) {
          return x;
        }
        if (null == x) {
          return current;
        }
        if (!('object' === typeof current && null != current.length)) {
          current = [ current ];
        }
        if (!('object' === typeof x && null != x.length)) {
          if (-1 === current.indexOf(x)) {
            current.push(x);
          }
          return current;
        }
        for (var i = 0, imax = x.length; i < imax; i++) {
          if (-1 === current.indexOf(x[i])) {
            current.push(x[i]);
          }
        }
        return current;
      }
      function _getAccessor(current) {
        var parent = current;
        outer: while (parent.parent) {
          switch (parent.parent.type) {
           case type_Body:
           case type_Statement:
            break outer;
          }
          parent = parent.parent;
        }
        return _copy(parent, current.next);
      }
      function _copy(ast, stop) {
        if (ast === stop || null == ast) {
          return null;
        }
        if ('object' !== typeof ast) {
          return ast;
        }
        if (null != ast.length && 'function' === typeof ast.splice) {
          var arr = [];
          for (var i = 0, imax = ast.length; i < imax; i++) {
            arr[i] = _copy(ast[i], stop);
          }
          return arr;
        }
        var clone = {};
        for (var key in ast) {
          if (null == ast[key] || 'parent' === key) {
            continue;
          }
          clone[key] = _copy(ast[key], stop);
        }
        return clone;
      }
    })();
    /**
		 * ExpressionUtil
		 *
		 * Helper to work with expressions
		 **/    exp_type_Sync = 1;
    exp_type_Async = 2;
    exp_type_Observe = 3;
    expression_getType = function(expr) {
      var ast = _parse(expr);
      if (null != ast) {
        if (ast.observe) {
          return exp_type_Observe;
        }
        if (ast.async) {
          return exp_type_Async;
        }
      }
      return exp_type_Sync;
    };
    expression_eval = _evaluate;
    expression_evalStatements = _evaluateStatements;
    expression_varRefs = refs_extractVars;
    ExpressionUtil = {
      parse: _parse,
      /**
		     * Expression.eval(expression [, model, cntx, controller]) -> result
		     * - expression (String): Expression, only accessors are supoorted
		     *
		     * All symbol and function references will be looked for in
		     *
		     * 1. model, or via special accessors:
		     * 		- `$c` controller
		     * 		- `$ctx`
		     * 		- `$a' controllers attributes
		     * 2. scope:
		     * 		controller.scope
		     * 		controller.parent.scope
		     * 		...
		     *
		     * Sample:
		     * '(user.age + 20) / 2'
		     * 'fn(user.age + "!") + x'
		     **/
      eval: _evaluate,
      varRefs: refs_extractVars,
      // Return all values of a comma delimiter expressions
      // like argumets: ' foo, bar, "4,50" ' => [ %fooValue, %barValue, "4,50" ]
      evalStatements: _evaluateStatements
    };
    customUtil_register('expression', function(value, model, ctx, element, ctr, name, type, node) {
      var owner = 'compo-attr' === type || 'compo-prop' === type ? ctr.parent : ctr;
      return expression_eval(value, model, ctx, owner, node);
    });
  })();
  var domLib, Compo, Component, CompoProto;
  (function() {
    var compo_meta_toAttributeKey, compo_meta_prepairAttributesHandler, compo_meta_prepairArgumentsHandler, Anchor, compo_dispose, compo_detachChild, compo_ensureTemplate, compo_attachDisposer, compo_attach, compo_removeElements, compo_cleanElements, compo_prepairAsync, compo_errored, CompoSignals, compo_find, compo_findAll, compo_closest, compo_children, compo_child, CompoStaticsAsync, _fire, _hasSlot, _toggle_all, _toggle_single, _compound, dom_addEventListener, node_tryDispose, node_tryDisposeChildren, isTouchable, event_bind, event_unbind, event_trigger, TouchHandler, Touch, FastClick, domLib_find, domLib_on, CompoConfig, domLib_find, domLib_on, domLib_initialize, EventsDeco, dom_addEventListener, node_tryDispose, node_tryDisposeChildren, CompoStatics, compo_meta_toAttributeKey, compo_meta_prepairAttributesHandler, compo_meta_prepairArgumentsHandler, Pipes, dom_addEventListener, node_tryDispose, node_tryDisposeChildren, compo_dispose, compo_detachChild, compo_ensureTemplate, compo_attachDisposer, compo_attach, compo_removeElements, compo_cleanElements, compo_prepairAsync, compo_errored, compo_dispose, compo_detachChild, compo_ensureTemplate, compo_attachDisposer, compo_attach, compo_removeElements, compo_cleanElements, compo_prepairAsync, compo_errored, dom_addEventListener, node_tryDispose, node_tryDisposeChildren, CompoSignals, DomLite, compo_createExt, CompoStaticsAsync, compo_find, compo_findAll, compo_closest, compo_children, compo_child, Anchor, CompoConfig, Pipes, domLib_initialize, compo_meta_toAttributeKey, compo_meta_prepairAttributesHandler, compo_meta_prepairArgumentsHandler, CompoStatics, compo_createExt;
    var _mask_ensureTmplFn, _resolve_External, setDomLib;
    (function() {
      _mask_ensureTmplFn = function(value) {
        return 'string' !== typeof value ? value : parser_ensureTemplateFunction(value);
      };
      _resolve_External = function(key) {
        return _global[key] || _exports[key] || _atma[key];
      };
      var _atma = _global.atma || {}, _exports = exports || {};
      function resolve(a, b, c) {
        for (var i = 0; i < arguments.length; i++) {
          var val = _resolve_External(arguments[i]);
          if (null != val) {
            return val;
          }
        }
        return null;
      }
      domLib = resolve('jQuery', 'Zepto', '$');
      resolve('Class');
      setDomLib = function(lib) {
        domLib = lib;
      };
    })();
    (function() {
      (function() {
        // == Meta Attribute and Property Handler
        compo_meta_toAttributeKey = _getProperty;
        compo_meta_prepairAttributesHandler = function(Proto, type) {
          var meta = getMetaProp_(Proto);
          var attr = meta.attributes;
          if (null != attr) {
            var hash = _createHash(Proto, attr, true);
            meta.readAttributes = _attr_setProperties_Delegate(hash);
          }
          var props = meta.properties;
          if (null != props) {
            hash = _createHash(Proto, attr, false);
            meta.readProperties = _attr_setProperties_Delegate(hash);
          }
        };
        function _createHash(Proto, metaObj, isAttr) {
          var hash = {};
          for (var key in metaObj) {
            _attr_setProperty_Delegate(Proto, key, metaObj[key], isAttr, 
            /*out*/ hash);
          }
          return hash;
        }
        function _attr_setProperties_Delegate(hash) {
          return function(compo, attr, model, container) {
            for (var key in hash) {
              var fn = hash[key];
              var val = attr[key];
              var error = fn(compo, key, val, model, container, attr);
              if (null == error) {
                continue;
              }
              _errored(compo, error, key, val);
              return false;
            }
            return true;
          };
        }
        function _attr_setProperty_Delegate(Proto, metaKey, metaVal, isAttr, 
        /*out*/ hash) {
          var optional = 63 === metaKey.charCodeAt(0), // ?
          default_ = null, attrName = optional ? metaKey.substring(1) : metaKey;
          var property = isAttr ? _getProperty(attrName, metaVal) : attrName;
          var fn = null;
          var type = typeof metaVal;
          if ('string' === type) {
            if ('string' === metaVal || 'number' === metaVal || 'boolean' === metaVal) {
              fn = _ensureFns[metaVal];
            } else {
              optional = true;
              default_ = metaVal;
              fn = _ensureFns_Delegate.any();
            }
          } else if ('boolean' === type || 'number' === type) {
            optional = true;
            fn = _ensureFns[type];
            default_ = metaVal;
          } else if ('function' === type) {
            fn = metaVal;
          } else if (null == metaVal) {
            fn = _ensureFns_Delegate.any();
          } else if (metaVal instanceof RegExp) {
            fn = _ensureFns_Delegate.regexp(metaVal);
          } else if ('object' === typeof metaVal) {
            fn = _ensureFns_Delegate.options(metaVal);
            default_ = metaVal['default'];
            if (void 0 !== default_) {
              optional = true;
            }
          }
          if (null == fn) {
            log_error('Function expected for the attr. handler', metaKey);
            return;
          }
          var factory_ = is_Function(default_) ? default_ : null;
          Proto[property] = null;
          Proto = null;
          hash[attrName] = function(compo, attrName, attrVal, model, container, attr) {
            if (null == attrVal) {
              if (false === optional) {
                return Error('Expected attribute ' + attrName);
              }
              if (null != factory_) {
                compo[property] = factory_.call(compo, model, container, attr);
                return null;
              }
              if (null != default_) {
                compo[property] = default_;
              }
              return null;
            }
            var val = fn.call(compo, attrVal, model, container, attrName);
            if (val instanceof Error) {
              return val;
            }
            compo[property] = val;
            return null;
          };
        }
        function _toCamelCase_Replacer(full, char_) {
          return char_.toUpperCase();
        }
        function _getProperty(attrName, attrDef) {
          if (null != attrDef && 'function' !== typeof attrDef && null != attrDef.name) {
            return attrDef.name;
          }
          var prop = attrName;
          if (120 !== prop.charCodeAt(0)) {
            // x
            prop = 'x-' + prop;
          }
          return prop.replace(/-(\w)/g, _toCamelCase_Replacer);
        }
        function _errored(compo, error, key, val) {
          error.message = compo.compoName + ' - attribute \'' + key + '\': ' + error.message;
          compo_errored(compo, error);
          log_error(error.message, '. Current: ', val);
        }
        var _ensureFns = {
          string: function(x) {
            return 'string' === typeof x ? x : Error('String');
          },
          number: function(x) {
            var num = Number(x);
            return num === num ? num : Error('Number');
          },
          boolean: function(x, compo, model, attrName) {
            if ('boolean' === typeof x) {
              return x;
            }
            if (x === attrName) {
              return true;
            }
            if ('true' === x || '1' === x) {
              return true;
            }
            if ('false' === x || '0' === x) {
              return false;
            }
            return Error('Boolean');
          }
        };
        var _ensureFns_Delegate = {
          regexp: function(rgx) {
            return function(x) {
              return rgx.test(x) ? x : Error('RegExp');
            };
          },
          any: function() {
            return function(x) {
              return x;
            };
          },
          options: function(opts) {
            var type = opts.type, def = opts.default || _defaults[type], validate = opts.validate, transform = opts.transform;
            return function(x, model, container, attrName) {
              if (!x) {
                return def;
              }
              if (null != type) {
                var fn = _ensureFns[type];
                if (null != fn) {
                  x = fn.apply(this, arguments);
                  if (x instanceof Error) {
                    return x;
                  }
                }
              }
              if (null != validate) {
                var error = validate.call(this, x, model, container);
                if (error) {
                  return Error(error);
                }
              }
              if (null != transform) {
                x = transform.call(this, x, model, container);
              }
              return x;
            };
          }
        };
        var _defaults = {
          string: '',
          boolean: false,
          number: 0
        };
        // == Meta Attribute Handler
                compo_meta_prepairArgumentsHandler = function(Proto) {
          var meta = getMetaProp_(Proto);
          var args = meta.arguments;
          if (null != args) {
            var i = args.length;
            while (--i > -1) {
              if ('string' === typeof args[i]) {
                args[i] = {
                  name: args[i],
                  type: null
                };
              }
            }
            meta.readArguments = _modelArgsBinding_Delegate(args);
          }
        };
        function _modelArgsBinding_Delegate(args) {
          return function(expr, model, ctx, ctr) {
            return _modelArgsBinding(args, expr, model, ctx, ctr);
          };
        }
        function _modelArgsBinding(args, expr, model, ctx, ctr) {
          var arr = null;
          if (null == expr) {
            var i = args.length;
            arr = new Array(i);
            while (--i > -1) {
              arr[i] = expression_eval(args[i].name, model, ctx, ctr);
            }
          } else {
            arr = expression_evalStatements(expr, model, ctx, ctr);
          }
          var out = {}, arrMax = arr.length, argsMax = args.length;
          i = -1;
          while (++i < arrMax && i < argsMax) {
            var val = arr[i];
            if (null == val) {
              var type = args[i].type;
              if (null != type) {
                var Type = type;
                if ('string' === typeof type) {
                  Type = expression_eval(type, model, ctx, ctr);
                  if (null == Type) {
                    error_withCompo(type + ' was not resolved', ctr);
                  } else {
                    val = Di.resolve(Type);
                  }
                }
              }
            }
            out[args[i].name] = val;
          }
          return out;
        }
        function getMetaProp_(Proto) {
          var meta = Proto.meta;
          if (null == meta) {
            meta = Proto.meta = obj_create(CompoProto.meta);
          }
          return meta;
        }
      })();
      (function() {
        /**
				 *	Get component that owns an element
				 **/
        Anchor = {
          create: function(compo) {
            var id = compo.ID;
            if (null == id) {
              log_warn('Component should have an ID');
              return;
            }
            _cache[id] = compo;
          },
          resolveCompo: function(el, silent) {
            if (null == el) {
              return null;
            }
            var ownerId, id, compo;
            do {
              id = el.getAttribute('x-compo-id');
              if (null != id) {
                if (null == ownerId) {
                  ownerId = id;
                }
                compo = _cache[id];
                if (null != compo) {
                  compo = compo_find(compo, {
                    key: 'ID',
                    selector: ownerId,
                    nextKey: 'components'
                  });
                  if (null != compo) {
                    return compo;
                  }
                }
              }
              el = el.parentNode;
            } while (null != el && 1 === el.nodeType);
            // if DEBUG
                        ownerId && true !== silent && log_warn('No controller for ID', ownerId);
            // endif
                        return null;
          },
          removeCompo: function(compo) {
            var id = compo.ID;
            if (null != id) {
              _cache[id] = void 0;
            }
          },
          getByID: function(id) {
            return _cache[id];
          }
        };
        var _cache = {};
      })();
      (function() {
        (function() {
          coll_each = function(coll, fn, ctx) {
            if (null == ctx) {
              ctx = coll;
            }
            if (null == coll) {
              return coll;
            }
            var imax = coll.length, i = 0;
            for (;i < imax; i++) {
              fn.call(ctx, coll[i], i);
            }
            return ctx;
          };
          coll_indexOf = function(coll, x) {
            if (null == coll) {
              return -1;
            }
            var imax = coll.length, i = 0;
            for (;i < imax; i++) {
              if (coll[i] === x) {
                return i;
              }
            }
            return -1;
          };
          coll_remove = function(coll, x) {
            var i = coll_indexOf(coll, x);
            if (-1 === i) {
              return false;
            }
            coll.splice(i, 1);
            return true;
          };
          coll_map = function(coll, fn, ctx) {
            var arr = new Array(coll.length);
            coll_each(coll, function(x, i) {
              arr[i] = fn.call(this, x, i);
            }, ctx);
            return arr;
          };
          coll_find = function(coll, fn, ctx) {
            var imax = coll.length, i = 0;
            for (;i < imax; i++) {
              if (fn.call(ctx || coll, coll[i], i)) {
                return true;
              }
            }
            return false;
          };
        })();
        (function() {
          CompoStaticsAsync = {
            pause: function(compo, ctx) {
              if (null != ctx) {
                if (null == ctx.defers) {
                  // async components
                  ctx.defers = [];
                }
                if (null == ctx.resolve) {
                  obj_extend(ctx, class_Dfr.prototype);
                }
                ctx.async = true;
                ctx.defers.push(compo);
                ctx.defer();
              }
              obj_extend(compo, CompoProto);
              var slots = Slots.wrap(compo);
              return function() {
                // Restore only signals in case smth. will be emitted during resume
                Slots.unwrap(compo, slots, true, false);
                CompoStaticsAsync.resume(compo, ctx);
                Slots.unwrap(compo, slots, false, true);
              };
            },
            resume: function(compo, ctx) {
              compo.async = false;
              // fn can be null when calling resume synced after pause
                            if (compo.resume) {
                compo.resume();
              }
              if (null == ctx) {
                return;
              }
              var x, busy = false, dfrs = ctx.defers, imax = dfrs.length, i = -1;
              while (++i < imax) {
                x = dfrs[i];
                if (x === compo) {
                  dfrs[i] = null;
                  continue;
                }
                busy = busy || null != x;
              }
              if (false === busy) {
                ctx.resolve();
              }
            },
            await: function(compo) {
              return new Awaiter().await(compo);
            }
          };
          /** private */          var CompoProto = {
            async: true,
            resume: null,
            await: function(resume, deep) {
              if (true === deep) {
                CompoStaticsAsync.await(this).then(resume);
                return;
              }
              if (false === this.async) {
                resume();
                return;
              }
              if (null == this.resume) {
                this.resume = resume;
                return;
              }
              var fn = this.resume;
              this.resume = function() {
                fn.call(this);
                resume.call(this);
              };
            }
          };
          var Awaiter = class_create(class_Dfr, {
            isReady: false,
            count: 0,
            constructor: function() {
              this.dequeue = this.dequeue.bind(this);
            },
            enqueue: function() {
              this.count++;
            },
            dequeue: function() {
              if (0 === --this.count && true === this.isReady) {
                this.resolve();
              }
            },
            await: function(compo) {
              awaitDeep(compo, this);
              if (0 === this.count) {
                this.resolve();
                return this;
              }
              this.isReady = true;
              return this;
            }
          });
          function awaitDeep(compo, awaiter) {
            if (true === compo.async) {
              awaiter.enqueue();
              compo.await(awaiter.dequeue);
              return;
            }
            var arr = compo.components;
            if (null == arr) {
              return;
            }
            var imax = arr.length, i = -1;
            while (++i < imax) {
              awaitDeep(arr[i], awaiter);
            }
          }
          var Slots = {
            /* for now wrap only `domInsert` */
            wrap: function(compo) {
              var domInsertFn = compo.slots && compo.slots.domInsert;
              if (null == domInsertFn) {
                return null;
              }
              var slots = {
                /* [ Original Fn, Arguments if called] */
                domInsert: [ domInsertFn, null ]
              };
              compo.slots.domInsert = function() {
                slots.domInsert[1] = _Array_slice.call(arguments);
              };
              return slots;
            },
            unwrap: function(compo, slots, shouldRestore, shouldEmit) {
              if (null == slots) {
                return;
              }
              for (var key in slots) {
                var data = slots[key];
                if (shouldRestore) {
                  compo.slots[key] = data[0];
                }
                if (shouldEmit && null != data[1]) {
                  CompoSignals.signal.emitIn(compo, key, data[1]);
                }
              }
            }
          };
        })();
        compo_dispose = function(compo) {
          if (null != compo.dispose) {
            compo.dispose();
          }
          Anchor.removeCompo(compo);
          var compos = compo.components;
          if (null != compos) {
            var i = compos.length;
            while (--i > -1) {
              compo_dispose(compos[i]);
            }
          }
          compo.parent = null;
          compo.model = null;
          compo.components = null;
        };
        compo_detachChild = function(childCompo) {
          var parent = childCompo.parent;
          if (null == parent) {
            return;
          }
          var compos = parent.components;
          if (null == compos) {
            return;
          }
          var removed = coll_remove(compos, childCompo);
          if (false === removed) {
            log_warn('<compo:remove> - i`m not in parents collection', childCompo);
          }
        };
        compo_ensureTemplate = function(compo) {
          if (null == compo.nodes) {
            compo.nodes = getTemplateProp_(compo);
            return;
          }
          var behaviour = compo.meta.template;
          if (null == behaviour || 'replace' === behaviour) {
            return;
          }
          var template = getTemplateProp_(compo);
          if (null == template) {
            return;
          }
          if ('merge' === behaviour) {
            compo.nodes = mask_merge(template, compo.nodes, compo);
            return;
          }
          if ('join' === behaviour) {
            compo.nodes = [ template, compo.nodes ];
            return;
          }
          log_error('Invalid meta.nodes behaviour', behaviour);
        };
        compo_attachDisposer = function(compo, disposer) {
          if (null == compo.dispose) {
            compo.dispose = disposer;
            return;
          }
          var prev = compo.dispose;
          compo.dispose = function() {
            disposer.call(this);
            prev.call(this);
          };
        };
        compo_attach = function(compo, name, fn) {
          var current = obj_getProperty(compo, name);
          if (is_Function(current)) {
            var wrapper = function() {
              var args = _Array_slice.call(arguments);
              fn.apply(compo, args);
              current.apply(compo, args);
            };
            obj_setProperty(compo, name, wrapper);
            return;
          }
          if (null == current) {
            obj_setProperty(compo, name, fn);
            return;
          }
          throw Error('Cann`t attach ' + name + ' to not a Function');
        };
        compo_removeElements = function(compo) {
          if (compo.$) {
            compo.$.remove();
            return;
          }
          var els = compo.elements;
          if (els) {
            var i = -1, imax = els.length;
            while (++i < imax) {
              if (els[i].parentNode) {
                els[i].parentNode.removeChild(els[i]);
              }
            }
            return;
          }
          var compos = compo.components;
          if (compos) {
            i = -1, imax = compos.length;
            while (++i < imax) {
              compo_removeElements(compos[i]);
            }
          }
        };
        compo_cleanElements = function(compo) {
          var els = compo.$ || compo.elements;
          if (null == els || 0 === els.length) {
            return;
          }
          var x = els[0];
          var parent = compo.parent;
          for (parent = compo.parent; null != parent; parent = parent.parent) {
            var arr = parent.$ || parent.elements;
            if (null == arr) {
              continue;
            }
            var i = coll_indexOf(arr, x);
            if (-1 === i) {
              break;
            }
            arr.splice(i, 1);
            if (els.length > 1) {
              var cursor = 1;
              for (var j = i; j < arr.length; j++) {
                if (arr[j] === els[cursor]) {
                  arr.splice(j, 1);
                  j--;
                  cursor++;
                }
              }
            }
          }
        };
        compo_prepairAsync = function(dfr, compo, ctx) {
          var resume = CompoStaticsAsync.pause(compo, ctx);
          dfr.then(resume, onError);
          function onError(error) {
            compo_errored(compo, error);
            error_withCompo(error, compo);
            resume();
          }
        };
        compo_errored = function(compo, error) {
          var msg = '[%] Failed.'.replace('%', compo.compoName || compo.tagName);
          if (error) {
            var desc = error.message || error.statusText || String(error);
            if (desc) {
              msg += ' ' + desc;
            }
          }
          compo.nodes = reporter_createErrorNode(msg);
          compo.renderEnd = compo.render = compo.renderStart = null;
        };
        function getTemplateProp_(compo) {
          var template = compo.template;
          if (null == template) {
            var attr = compo.attr;
            if (null == attr) {
              return null;
            }
            template = attr.template;
            if (null == template) {
              return null;
            }
            delete compo.attr.template;
          }
          if ('object' === typeof template) {
            return template;
          }
          if (is_String(template)) {
            if (35 === template.charCodeAt(0) && /^#[\w\d_-]+$/.test(template)) {
              // #
              var node = document.getElementById(template.substring(1));
              if (null == node) {
                log_warn('Template not found by id:', template);
                return null;
              }
              template = node.innerHTML;
            }
            return parser_parse(template);
          }
          log_warn('Invalid template', typeof template);
          return null;
        }
      })();
      var KeyboardHandler;
      (function() {
        var CODES, MODS;
        var IComb;
        (function() {
          (function() {
            CODES = {
              backspace: 8,
              tab: 9,
              return: 13,
              enter: 13,
              shift: 16,
              ctrl: 17,
              control: 17,
              alt: 18,
              option: 18,
              fn: 255,
              pause: 19,
              capslock: 20,
              esc: 27,
              escape: 27,
              space: 32,
              pageup: 33,
              pagedown: 34,
              end: 35,
              home: 36,
              start: 36,
              left: 37,
              up: 38,
              right: 39,
              down: 40,
              insert: 45,
              ins: 45,
              del: 46,
              numlock: 144,
              scroll: 145,
              f1: 112,
              f2: 113,
              f3: 114,
              f4: 115,
              f5: 116,
              f6: 117,
              f7: 118,
              f8: 119,
              f9: 120,
              f10: 121,
              f11: 122,
              f12: 123,
              ';': 186,
              '=': 187,
              '*': 106,
              '+': 107,
              plus: 107,
              '-': 109,
              minus: 109,
              '.': 190,
              '/': 191,
              ',': 188,
              '`': 192,
              '[': 219,
              '\\': 220,
              ']': 221,
              '\'': 222
            };
            MODS = {
              16: 'shiftKey',
              17: 'ctrlKey',
              18: 'altKey'
            };
          })();
          IComb = function(set) {
            this.set = set;
          };
          IComb.parse = function(str) {
            var parts = str.split(','), combs = [], imax = parts.length, i = 0;
            for (;i < imax; i++) {
              combs[i] = parseSingle(parts[i]);
            }
            return combs;
          };
          IComb.create = function(def, type, fn, ctx) {
            var codes = IComb.parse(def);
            var comb = Key.create(codes);
            if (null == comb) {
              comb = new KeySequance(codes);
            }
            comb.init(type, fn, ctx);
            return comb;
          };
          IComb.prototype = {
            type: null,
            ctx: null,
            set: null,
            fn: null,
            init: function(type, fn, ctx) {
              this.type = type;
              this.ctx = ctx;
              this.fn = fn;
            },
            tryCall: null
          };
          function parseSingle(str) {
            var x, code, keys = str.split('+'), imax = keys.length, i = 0, out = [];
            for (;i < imax; i++) {
              x = keys[i].trim();
              code = CODES[x];
              if (void 0 === code) {
                if (1 !== x.length) {
                  throw Error('Unexpected sequence. Neither a predefined key, nor a char: ' + x);
                }
                code = x.toUpperCase().charCodeAt(0);
              }
              out[i] = code;
            }
            return {
              last: out[imax - 1],
              keys: out.sort()
            };
          }
        })();
        var Key_MATCH_OK, Key_MATCH_FAIL, Key_MATCH_WAIT, Key_MATCH_NEXT, KeySequance;
        (function() {
          Key_MATCH_OK = 1;
          Key_MATCH_FAIL = 2;
          Key_MATCH_WAIT = 3;
          Key_MATCH_NEXT = 4;
          KeySequance = class_create(IComb, {
            index: 0,
            tryCall: function(event, codes, lastCode) {
              var matched = this.check_(codes, lastCode);
              if (matched === Key_MATCH_OK) {
                this.index = 0;
                this.fn.call(this.ctx, event);
              }
              return matched;
            },
            fail_: function() {
              this.index = 0;
              return Key_MATCH_FAIL;
            },
            check_: function(codes, lastCode) {
              var current = this.set[this.index], keys = current.keys, last = current.last;
              var l = codes.length;
              if (l < keys.length) {
                return Key_MATCH_WAIT;
              }
              if (l > keys.length) {
                return this.fail_();
              }
              if (last !== lastCode) {
                return this.fail_();
              }
              while (--l > -1) {
                if (keys[l] !== codes[l]) {
                  return this.fail_();
                }
              }
              if (this.index < this.set.length - 1) {
                this.index++;
                return Key_MATCH_NEXT;
              }
              this.index = 0;
              return Key_MATCH_OK;
            }
          });
        })();
        var Key;
        (function() {
          Key = class_create(IComb, {
            constructor: function(set, key, mods) {
              this.key = key;
              this.mods = mods;
            },
            tryCall: function(event, codes, lastCode) {
              if (event.type !== this.type || lastCode !== this.key) {
                return Key_MATCH_FAIL;
              }
              for (var key in this.mods) {
                if (event[key] !== this.mods[key]) {
                  return Key_MATCH_FAIL;
                }
              }
              this.fn.call(this.ctx, event);
              return Key_MATCH_OK;
            }
          });
          Key.create = function(set) {
            if (1 !== set.length) {
              return null;
            }
            var keys = set[0].keys, i = keys.length, mods = {
              shiftKey: false,
              ctrlKey: false,
              altKey: false
            };
            var key;
            while (--i > -1) {
              if (false === MODS.hasOwnProperty(keys[i])) {
                if (null != key) {
                  return null;
                }
                key = keys[i];
                continue;
              }
              mods[MODS[keys[i]]] = true;
              true;
            }
            return new Key(set, key, mods);
          };
        })();
        var event_bind, event_getCode;
        (function() {
          event_bind = function(el, type, mix) {
            el.addEventListener(type, mix, false);
          };
          event_getCode = function(event) {
            var code = event.keyCode || event.which;
            if (code >= 96 && code <= 105) {
              // numpad digits
              return code - 48;
            }
            return code;
          };
        })();
        var filter_skippedInput, filter_isKeyboardInput;
        (function() {
          filter_skippedInput = function(event, code) {
            if (event.ctrlKey || event.altKey) {
              return false;
            }
            return filter_isKeyboardInput(event.target);
          };
          filter_isKeyboardInput = function(el) {
            var tag = el.tagName;
            if ('TEXTAREA' === tag) {
              return true;
            }
            if ('INPUT' !== tag) {
              return false;
            }
            return -1 === TYPELESS_INPUT.indexOf(' ' + el.type + ' ');
          };
          var TYPELESS_INPUT = ' button submit checkbox file hidden image radio range reset ';
        })();
        var CombHandler;
        (function() {
          CombHandler = function() {
            this.keys = [];
            this.combs = [];
          };
          CombHandler.prototype = {
            keys: null,
            combs: null,
            attach: function(comb) {
              this.combs.push(comb);
            },
            off: function(fn) {
              var imax = this.combs.length, i = 0;
              for (;i < imax; i++) {
                if (this.combs[i].fn === fn) {
                  this.combs.splice(i, 1);
                  return true;
                }
              }
              return false;
            },
            handle: function(type, code, event) {
              if (0 === this.combs.length) {
                return;
              }
              if (this.filter_(event, code)) {
                if ('keyup' === type && this.keys.length > 0) {
                  this.remove_(code);
                }
                return;
              }
              if ('keydown' === type) {
                if (this.add_(code)) {
                  this.emit_(type, event, code);
                }
                return;
              }
              if ('keyup' === type) {
                this.emit_(type, event, code);
                this.remove_(code);
              }
            },
            handleEvent: function(event) {
              var code = event_getCode(event), type = event.type;
              this.handle(type, code, event);
            },
            reset: function() {
              this.keys.length = 0;
            },
            add_: function(code) {
              var x, imax = this.keys.length, i = 0;
              for (;i < imax; i++) {
                x = this.keys[i];
                if (x === code) {
                  return false;
                }
                if (x > code) {
                  this.keys.splice(i, 0, code);
                  return true;
                }
              }
              this.keys.push(code);
              return true;
            },
            remove_: function(code) {
              var i = this.keys.length;
              while (--i > -1) {
                if (this.keys[i] === code) {
                  this.keys.splice(i, 1);
                  return;
                }
              }
            },
            emit_: function(type, event, lastCode) {
              var x, stat, combs = this.combs, imax = combs.length, i = 0;
              for (;i < imax; i++) {
                x = combs[i];
                if (x.type !== type) {
                  continue;
                }
                stat = x.tryCall(event, this.keys, lastCode);
                if (Key_MATCH_OK === stat || stat === Key_MATCH_NEXT) {
                  event.preventDefault();
                }
                if (stat === Key_MATCH_WAIT || stat === Key_MATCH_NEXT) {
                  true;
                }
              }
            },
            filter_: function(event, code) {
              return filter_skippedInput(event, code);
            }
          };
        })();
        var Hotkey;
        (function() {
          Hotkey = {
            on: function(combDef, fn, compo) {
              if (null == handler) {
                init();
              }
              var comb = IComb.create(combDef, 'keydown', fn, compo);
              handler.attach(comb);
            },
            off: function(fn) {
              handler.off(fn);
            },
            handleEvent: function(event) {
              handler.handle(event.type, event_getCode(event), event);
            },
            reset: function() {
              handler.reset();
            }
          };
          var handler;
          function init() {
            handler = new CombHandler();
            event_bind(window, 'keydown', Hotkey);
            event_bind(window, 'keyup', Hotkey);
            event_bind(window, 'focus', Hotkey.reset);
          }
        })();
        KeyboardHandler = {
          supports: function(event, param) {
            if (null == param) {
              return false;
            }
            switch (event) {
             case 'press':
             case 'keypress':
             case 'keydown':
             case 'keyup':
             case 'hotkey':
             case 'shortcut':
              return true;
            }
            return false;
          },
          on: function(el, type, def, fn) {
            if ('keypress' === type || 'press' === type) {
              type = 'keydown';
            }
            var comb = IComb.create(def, type, fn);
            if (comb instanceof Key) {
              event_bind(el, type, function(event) {
                var code = event_getCode(event);
                var r = comb.tryCall(event, null, code);
                if (r === Key_MATCH_OK) {
                  event.preventDefault();
                }
              });
              return;
            }
            var handler = new CombHandler();
            event_bind(el, 'keydown', handler);
            event_bind(el, 'keyup', handler);
            handler.attach(comb);
          },
          hotkeys: function(compo, hotkeys) {
            var fn, comb;
            for (comb in hotkeys) {
              fn = hotkeys[comb];
              Hotkey.on(comb, fn, compo);
            }
            compo_attachDisposer(compo, function() {
              var comb;
              for (comb in hotkeys) {
                Hotkey.off(hotkeys[comb]);
              }
            });
          },
          attach: function(el, type, comb, fn, ctr) {
            if (filter_isKeyboardInput(el)) {
              this.on(el, type, comb, fn);
              return;
            }
            var x = ctr;
            while (x && null == x.slots) {
              x = x.parent;
            }
            if (null == x) {
              log_error('Slot-component not found:', comb);
              return;
            }
            var hotkeys = x.hotkeys;
            if (null == hotkeys) {
              hotkeys = x.hotkeys = {};
            }
            hotkeys[comb] = fn;
          }
        };
      })();
      (function() {
        (function() {
          // @param sender - event if sent from DOM Event or CONTROLLER instance
          _fire = function(ctr, slot, sender, args_, direction) {
            if (null == ctr) {
              return false;
            }
            var found = false, args = args_, fn = null != ctr.slots && ctr.slots[slot];
            if ('string' === typeof fn) {
              fn = ctr[fn];
            }
            if ('function' === typeof fn) {
              found = true;
              var isDisabled = null != ctr.slots.__disabled && ctr.slots.__disabled[slot];
              if (true !== isDisabled) {
                var result = null == args ? fn.call(ctr, sender) : fn.apply(ctr, [ sender ].concat(args));
                if (false === result) {
                  return true;
                }
                if (is_ArrayLike(result)) {
                  args = result;
                }
              }
            }
            if (-1 === direction && null != ctr.parent) {
              return _fire(ctr.parent, slot, sender, args, direction) || found;
            }
            if (1 === direction && null != ctr.components) {
              var compos = ctr.components, imax = compos.length, i = -1;
              while (++i < imax) {
                found = _fire(compos[i], slot, sender, args, direction) || found;
              }
            }
            return found;
          } // _fire()
          ;
          _hasSlot = function(ctr, slot, direction, isActive) {
            if (null == ctr) {
              return false;
            }
            var slots = ctr.slots;
            if (null != slots && null != slots[slot]) {
              if ('string' === typeof slots[slot]) {
                slots[slot] = ctr[slots[slot]];
              }
              if ('function' === typeof slots[slot]) {
                if (true === isActive) {
                  if (null == slots.__disabled || true !== slots.__disabled[slot]) {
                    return true;
                  }
                } else {
                  return true;
                }
              }
            }
            if (-1 === direction && null != ctr.parent) {
              return _hasSlot(ctr.parent, slot, direction);
            }
            if (1 === direction && null != ctr.components) {
              for (var i = 0, length = ctr.components.length; i < length; i++) {
                if (_hasSlot(ctr.components[i], slot, direction)) {
                  return true;
                }
              }
            }
            return false;
          };
        })();
        (function() {
          _toggle_all = function(ctr, slot, isActive) {
            var parent = ctr, previous = ctr;
            while (null != (parent = parent.parent)) {
              __toggle_slotState(parent, slot, isActive);
              if (null == parent.$ || 0 === parent.$.length) {
                // we track previous for changing elements :disable state
                continue;
              }
              previous = parent;
            }
            __toggle_slotStateWithChilds(ctr, slot, isActive);
            __toggle_elementsState(previous, slot, isActive);
          };
          _toggle_single = function(ctr, slot, isActive) {
            __toggle_slotState(ctr, slot, isActive);
            if (!isActive && (_hasSlot(ctr, slot, -1, true) || _hasSlot(ctr, slot, 1, true))) {
              // there are some active slots; do not disable elements;
              return;
            }
            __toggle_elementsState(ctr, slot, isActive);
          };
          function __toggle_slotState(ctr, slot, isActive) {
            var slots = ctr.slots;
            if (null == slots || false === slots.hasOwnProperty(slot)) {
              return;
            }
            var disabled = slots.__disabled;
            if (null == disabled) {
              disabled = slots.__disabled = {};
            }
            disabled[slot] = false === isActive;
          }
          function __toggle_slotStateWithChilds(ctr, slot, isActive) {
            __toggle_slotState(ctr, slot, isActive);
            var compos = ctr.components;
            if (null != compos) {
              var imax = compos.length, i = 0;
              for (;i < imax; i++) {
                __toggle_slotStateWithChilds(compos[i], slot, isActive);
              }
            }
          }
          function __toggle_elementsState(ctr, slot, isActive) {
            if (null == ctr.$) {
              log_warn('Controller has no elements to toggle state');
              return;
            }
            domLib().add(ctr.$.filter('[data-signals]')).add(ctr.$.find('[data-signals]')).each(function(index, node) {
              var signals = node.getAttribute('data-signals');
              if (null != signals && -1 !== signals.indexOf(slot)) {
                node[true === isActive ? 'removeAttribute' : 'setAttribute']('disabled', 'disabled');
              }
            });
          }
        })();
        (function() {
          _compound = function(ctr, slotExpression, cb) {
            var slots = ctr.slots;
            if (null == slots) {
              slots = ctr.slots = {};
            }
            var handler = new SlotExpression(slotExpression, cb);
            for (var i = 0; i < handler.slots.length; i++) {
              var name = handler.slots[i].name;
              compo_attach(ctr, 'slots.' + name, handler.signalDelegate(name));
            }
            return handler;
          };
          var SlotExpression = class_create({
            slots: null,
            flags: null,
            cb: null,
            expression: null,
            constructor: function(expression, cb) {
              var str = expression.replace(/\s+/g, '');
              var refs = expression_varRefs(str);
              this.cb = cb;
              this.slots = [];
              this.flags = {};
              this.expression = str;
              for (var i = 0; i < refs.length; i++) {
                var name = refs[i];
                this.flags[name] = 0;
                this.slots[i] = {
                  name: name,
                  action: str[str.indexOf(name) - 1],
                  index: i
                };
              }
            },
            signalDelegate: function(name) {
              var self = this;
              return function() {
                self.call(name);
              };
            },
            call: function(name) {
              var slot = this.findSlot(name);
              if ('^' !== slot.action) {
                this.flags[name] = 1;
                var state = expression_eval(this.expression, this.flags);
                if (state) {
                  this.cb();
                }
                return;
              }
              var prev = slot;
              do {
                prev = this.slots[prev.index - 1];
              } while (null != prev && '^' === prev.action);
              if (prev) {
                this.flags[prev.name] = 0;
              }
            },
            findSlot: function(name) {
              for (var i = 0; i < this.slots.length; i++) {
                var slot = this.slots[i];
                if (slot.name === name) {
                  return slot;
                }
              }
              return null;
            }
          });
        })();
        (function() {
          (function() {
            (function() {
              isTouchable = 'ontouchstart' in _global;
              event_bind = function(el, type, handler, opts) {
                el.addEventListener(type, handler, resolveOpts(opts));
              };
              event_unbind = function(el, type, handler, opts) {
                el.removeEventListener(type, handler, resolveOpts(opts));
              };
              event_trigger = function(el, type) {
                var event = new CustomEvent(type, {
                  cancelable: true,
                  bubbles: true
                });
                el.dispatchEvent(event);
              };
              var supportsCaptureOption = false;
              if (null != _global.document) {
                document.createElement('div').addEventListener('click', fn_doNothing, {
                  get capture() {
                    supportsCaptureOption = true;
                    return false;
                  }
                });
              }
              var opts_DEFAULT = supportsCaptureOption ? {
                passive: true,
                capture: false
              } : false;
              var resolveOpts = function(opts) {
                if (null == opts) {
                  return opts_DEFAULT;
                }
                if ('boolean' === typeof opts) {
                  if (false === opts) {
                    return opts_DEFAULT;
                  }
                  return supportsCaptureOption ? {
                    passive: true,
                    capture: true
                  } : true;
                }
                if (false === supportsCaptureOption) {
                  return Boolean(opts.capture);
                }
                return opts;
              };
            })();
            (function() {
              (function() {
                Touch = function(el, type, fn, opts) {
                  this.el = el;
                  this.fn = fn;
                  this.dismiss = 0;
                  event_bind(el, type, this, opts);
                  event_bind(el, MOUSE_MAP[type], this, opts);
                };
                var MOUSE_MAP = {
                  mousemove: 'touchmove',
                  mousedown: 'touchstart',
                  mouseup: 'touchend'
                };
                // var TOUCH_MAP = {
                //     'touchmove': 'mousemove',
                //     'touchstart': 'mousedown',
                //     'touchup': 'mouseup'
                // };
                                Touch.prototype = {
                  handleEvent: function(event) {
                    switch (event.type) {
                     case 'touchstart':
                     case 'touchmove':
                     case 'touchend':
                      this.dismiss++;
                      // event = prepairTouchEvent(event);
                                            this.fn(event);
                      break;

                     case 'mousedown':
                     case 'mousemove':
                     case 'mouseup':
                      if (--this.dismiss < 0) {
                        this.dismiss = 0;
                        this.fn(event);
                      }
                      break;
                    }
                  }
                };
                // function prepairTouchEvent(event){
                //     var touch = null,
                //         touches = event.changedTouches;
                //     if (touches && touches.length) {
                //         touch = touches[0];
                //     }
                //     if (touch == null && event.touches) {
                //         touch = event.touches[0];
                //     }
                //     if (touch == null) {
                //         return event;
                //     }
                //     return createMouseEvent(event, touch);
                // }
                // function createMouseEvent (event, touch) {
                //     var obj = Object.create(MouseEvent.prototype);
                //     for (var key in event) {
                //         obj[key] = event[key];
                //     }
                //     for (var key in PROPS) {
                //         obj[key] = touch[key];
                //     }
                //     return new MouseEvent(TOUCH_MAP[event.type], obj);
                // }
                // var PROPS = {
                //     clientX: 1,
                //     clientY: 1,
                //     pageX: 1,
                //     pageY: 1,
                //     screenX: 1,
                //     screenY: 1
                // };
                            })();
              (function() {
                FastClick = function(el, fn, opts) {
                  this.state = 0;
                  this.el = el;
                  this.fn = fn;
                  this.startX = 0;
                  this.startY = 0;
                  this.tStart = 0;
                  this.tEnd = 0;
                  this.dismiss = 0;
                  event_bind(el, 'touchstart', this, opts);
                  event_bind(el, 'touchend', this, opts);
                  event_bind(el, 'click', this, opts);
                };
                var threshold_TIME = 300, threshold_DIST = 10, timestamp_LastTouch = null;
                FastClick.prototype = {
                  handleEvent: function(event) {
                    var type = event.type;
                    switch (type) {
                     case 'touchmove':
                     case 'touchstart':
                     case 'touchend':
                      timestamp_LastTouch = event.timeStamp;
                      this[type](event);
                      break;

                     case 'touchcancel':
                      this.reset();
                      break;

                     case 'click':
                      this.click(event);
                      break;
                    }
                  },
                  touchstart: function(event) {
                    event_bind(document.body, 'touchmove', this);
                    var e = event.touches[0];
                    this.state = 1;
                    this.tStart = event.timeStamp;
                    this.startX = e.clientX;
                    this.startY = e.clientY;
                  },
                  touchend: function(event) {
                    this.tEnd = event.timeStamp;
                    if (1 === this.state) {
                      this.dismiss++;
                      if (this.tEnd - this.tStart <= threshold_TIME) {
                        this.call(event);
                        return;
                      }
                      event_trigger(this.el, 'taphold');
                      return;
                    }
                    this.reset();
                  },
                  click: function(event) {
                    if (null != timestamp_LastTouch) {
                      var dt = timestamp_LastTouch - event.timeStamp;
                      if (dt < 500) {
                        return;
                      }
                    }
                    if (--this.dismiss > -1) {
                      return;
                    }
                    if (0 !== this.tEnd) {
                      dt = event.timeStamp - this.tEnd;
                      if (dt < 400) {
                        return;
                      }
                    }
                    this.dismiss = 0;
                    this.call(event);
                  },
                  touchmove: function(event) {
                    var e = event.touches[0];
                    var dx = e.clientX - this.startX;
                    if (dx < 0) {
                      dx *= -1;
                    }
                    if (dx > threshold_DIST) {
                      this.reset();
                      return;
                    }
                    var dy = e.clientY - this.startY;
                    if (dy < 0) {
                      dy *= -1;
                    }
                    if (dy > threshold_DIST) {
                      this.reset();
                      return;
                    }
                  },
                  reset: function() {
                    this.state = 0;
                    event_unbind(document.body, 'touchmove', this);
                  },
                  call: function(event) {
                    this.reset();
                    this.fn(event);
                  }
                };
              })();
              TouchHandler = {
                supports: function(type) {
                  if (false === isTouchable) {
                    return false;
                  }
                  switch (type) {
                   case 'click':
                   case 'mousedown':
                   case 'mouseup':
                   case 'mousemove':
                    return true;
                  }
                  return false;
                },
                on: function(el, type, fn, opts) {
                  if ('click' === type) {
                    return new FastClick(el, fn, opts);
                  }
                  return new Touch(el, type, fn, opts);
                }
              };
            })();
            dom_addEventListener = function(el, event, fn, param, ctr) {
              var opts = !param ? void 0 : {
                capture: -1 !== param.indexOf('capture'),
                passive: -1 === param.indexOf('nopassive')
              };
              if (TouchHandler.supports(event)) {
                TouchHandler.on(el, event, fn, opts);
                return;
              }
              if (KeyboardHandler.supports(event, param)) {
                KeyboardHandler.attach(el, event, param, fn, ctr);
                return;
              }
              // allows custom events - in x-signal, for example
                            if (null != domLib) {
                if ('touchmove' !== event && 'touchstart' !== event && 'touchend' !== event && 'wheel' !== event && 'scroll' !== event) {
                  domLib(el).on(event, fn);
                  return;
                }
              }
              event_bind(el, event, fn, opts);
            };
            node_tryDispose = function(node) {
              if (node.hasAttribute('x-compo-id')) {
                var id = node.getAttribute('x-compo-id'), compo = Anchor.getByID(id);
                if (null != compo) {
                  if (null == compo.$ || 1 === compo.$.length) {
                    compo_dispose(compo);
                    compo_detachChild(compo);
                    return;
                  }
                  var i = _Array_indexOf.call(compo.$, node);
                  if (-1 !== i) {
                    _Array_splice.call(compo.$, i, 1);
                  }
                }
              }
              node_tryDisposeChildren(node);
            };
            node_tryDisposeChildren = function(node) {
              var child = node.firstChild;
              while (null != child) {
                if (1 === child.nodeType) {
                  node_tryDispose(child);
                }
                child = child.nextSibling;
              }
            };
          })();
          _create('signal');
          _createEvent('change');
          _createEvent('click');
          _createEvent('tap', 'click');
          _createEvent('keypress');
          _createEvent('keydown');
          _createEvent('keyup');
          _createEvent('mousedown');
          _createEvent('mouseup');
          _createEvent('press', 'keydown');
          _createEvent('shortcut', 'keydown');
          function _createEvent(name, type) {
            _create(name, type || name);
          }
          function _create(name, asEvent) {
            customAttr_register('x-' + name, 'client', function(node, attrValue, model, ctx, el, ctr) {
              var isSlot = node === ctr;
              _attachListener(el, ctr, attrValue, asEvent, isSlot);
            });
          }
          function _attachListener(el, ctr, definition, asEvent, isSlot) {
            var hasMany = -1 !== definition.indexOf(';'), signals = '', arr = hasMany ? definition.split(';') : null, i = hasMany ? arr.length : 1;
            while (-1 !== --i) {
              var signal = _handleDefinition(el, ctr, null == arr ? definition : arr[i], asEvent, isSlot);
              if (null != signal) {
                signals += ',' + signal + ',';
              }
            }
            if ('' !== signals) {
              var KEY = 'data-signals';
              var attr = el.getAttribute(KEY);
              if (null != attr) {
                signals = attr + signals;
              }
              el.setAttribute(KEY, signals);
            }
          }
          function _handleDefinition(el, ctr, definition, asEvent, isSlot) {
            var match = rgx_DEF.exec(definition);
            if (null == match) {
              log_error('Signal definition is not resolved ' + definition + '. The pattern is: (source((sourceArg))?:)?signal((expression))?');
              return null;
            }
            var source = match[2], sourceArg = match[4], signal = match[5], signalExpr = match[7];
            if (null != asEvent) {
              sourceArg = source;
              source = asEvent;
            }
            var fn = _createListener(ctr, signal, signalExpr);
            if (!source) {
              log_error('Signal: Eventname is not set', definition);
              return null;
            }
            if (!fn) {
              log_warn('Slot not found:', signal);
              return null;
            }
            if (isSlot) {
              compo_attach(ctr, 'slots.' + source, fn);
              return;
            }
            dom_addEventListener(el, source, fn, sourceArg, ctr);
            return signal;
          }
          function _createListener(ctr, slot, expr) {
            if (false === _hasSlot(ctr, slot, -1)) {
              return null;
            }
            return function(event) {
              var args;
              if (arguments.length > 1) {
                args = _Array_slice.call(arguments, 1);
              }
              if (null != expr) {
                var model, p = ctr;
                while (null != p && null == model) {
                  model = p.model;
                  p = p.parent;
                }
                var arr = expression_evalStatements(expr, model, null, ctr);
                args = null == args ? arr : args.concat(arr);
              }
              _fire(ctr, slot, event, args, -1);
            };
          }
          // click: fooSignal(barArg)
          // ctrl+enter: doSmth(arg, arg2)
                    var rgx_DEF = /^\s*(([\w\+\-_]+)(\s*\(\s*(\w+)\s*\))?\s*:)?\s*(\w+)(\s*\(([^)]+)\)\s*)?\s*$/;
        })();
        CompoSignals = {
          signal: {
            toggle: _toggle_all,
            // to parent
            emitOut: function(ctr, slot, sender, args) {
              var captured = _fire(ctr, slot, sender, args, -1);
              // if DEBUG
                            !captured && log_warn('Signal', slot, 'was not captured');
              // endif
                        },
            // to children
            emitIn: function(ctr, slot, sender, args) {
              _fire(ctr, slot, sender, args, 1);
            },
            enable: function(ctr, slot) {
              _toggle_all(ctr, slot, true);
            },
            disable: function(ctr, slot) {
              _toggle_all(ctr, slot, false);
            }
          },
          slot: {
            toggle: _toggle_single,
            enable: function(ctr, slot) {
              _toggle_single(ctr, slot, true);
            },
            disable: function(ctr, slot) {
              _toggle_single(ctr, slot, false);
            },
            invoke: function(ctr, slot, event, args) {
              var slots = ctr.slots;
              if (null == slots || 'function' !== typeof slots[slot]) {
                log_error('Slot not found', slot, ctr);
                return null;
              }
              if (null == args) {
                return slots[slot].call(ctr, event);
              }
              return slots[slot].apply(ctr, [ event ].concat(args));
            },
            attach: _compound
          }
        };
      })();
      var ani_requestFrame, ani_clearFrame, ani_updateAttr;
      (function() {
        var TweenManager;
        (function() {
          var Tween;
          (function() {
            Tween = /** @class */ function() {
              function Tween(key, prop, start, end, transition) {
                var parts = /(\d+m?s)\s*([\w\-]+)?/.exec(transition);
                this.duration = _toMs(parts[1], transition);
                this.timing = _toTimingFn(parts[2]);
                this.start = +start;
                this.end = +end;
                this.diff = this.end - this.start;
                this.key = key;
                this.prop = prop;
                this.animating = true;
              }
              Tween.prototype.tick = function(timestamp, parent) {
                if (null == this.startedAt) {
                  this.startedAt = timestamp;
                }
                var d = timestamp - this.startedAt;
                var x = this.timing(d, this.start, this.diff, this.duration);
                if (d >= this.duration) {
                  this.animating = false;
                  x = this.end;
                }
                parent.attr[this.key] = x;
                if (this.prop) {
                  parent[this.prop] = x;
                }
              };
              return Tween;
            }();
            /*2ms;3s*/            function _toMs(str, easing) {
              if (null == str) {
                log_error('Easing: Invalid duration in ' + easing);
                return 0;
              }
              var d = parseFloat(str);
              if (str.indexOf('ms') > -1) {
                return d;
              }
              if (str.indexOf('s') > -1) {
                return 1e3 * d;
              }
              throw Error('Unsupported duration:' + str);
            }
            function _toTimingFn(str) {
              if (null == str) {
                return Fns.linear;
              }
              var fn = Fns[str];
              if (false === is_Function(fn)) {
                log_error('Unsupported timing:' + str + '. Available:' + Object.keys(Fns).join(','));
                return Fns.linear;
              }
              return fn;
            }
            // Easing functions by Robert Penner
            // Source: http://www.robertpenner.com/easing/
            // License: http://www.robertpenner.com/easing_terms_of_use.html
                        var Fns = {
              // t: is the current time (or position) of the tween.
              // b: is the beginning value of the property.
              // c: is the change between the beginning and destination value of the property.
              // d: is the total time of the tween.
              // jshint eqeqeq: false, -W041: true
              linear: function(t, b, c, d) {
                return c * t / d + b;
              },
              linearEase: function(t, b, c, d) {
                return c * t / d + b;
              },
              easeInQuad: function(t, b, c, d) {
                return c * (t /= d) * t + b;
              },
              easeOutQuad: function(t, b, c, d) {
                return -c * (t /= d) * (t - 2) + b;
              },
              easeInOutQuad: function(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                  return c / 2 * t * t + b;
                }
                return -c / 2 * (--t * (t - 2) - 1) + b;
              },
              easeInCubic: function(t, b, c, d) {
                return c * (t /= d) * t * t + b;
              },
              easeOutCubic: function(t, b, c, d) {
                return c * ((t = t / d - 1) * t * t + 1) + b;
              },
              easeInOutCubic: function(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                  return c / 2 * t * t * t + b;
                }
                return c / 2 * ((t -= 2) * t * t + 2) + b;
              },
              easeInQuart: function(t, b, c, d) {
                return c * (t /= d) * t * t * t + b;
              },
              easeOutQuart: function(t, b, c, d) {
                return -c * ((t = t / d - 1) * t * t * t - 1) + b;
              },
              easeInOutQuart: function(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                  return c / 2 * t * t * t * t + b;
                }
                return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
              },
              easeInQuint: function(t, b, c, d) {
                return c * (t /= d) * t * t * t * t + b;
              },
              easeOutQuint: function(t, b, c, d) {
                return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
              },
              easeInOutQuint: function(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                  return c / 2 * t * t * t * t * t + b;
                }
                return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
              },
              easeInSine: function(t, b, c, d) {
                return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
              },
              easeOutSine: function(t, b, c, d) {
                return c * Math.sin(t / d * (Math.PI / 2)) + b;
              },
              easeInOutSine: function(t, b, c, d) {
                return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
              },
              easeInExpo: function(t, b, c, d) {
                return 0 == t ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
              },
              easeOutExpo: function(t, b, c, d) {
                return t == d ? b + c : c * (1 - Math.pow(2, -10 * t / d)) + b;
              },
              easeInOutExpo: function(t, b, c, d) {
                if (0 == t) {
                  return b;
                }
                if (t == d) {
                  return b + c;
                }
                if ((t /= d / 2) < 1) {
                  return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
                }
                return c / 2 * (2 - Math.pow(2, -10 * --t)) + b;
              },
              easeInCirc: function(t, b, c, d) {
                return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
              },
              easeOutCirc: function(t, b, c, d) {
                return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
              },
              easeInOutCirc: function(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                  return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
                }
                return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
              },
              easeInElastic: function(t, b, c, d) {
                var s = 1.70158;
                var p = 0;
                var a = c;
                if (0 == t) {
                  return b;
                }
                if (1 == (t /= d)) {
                  return b + c;
                }
                if (!p) {
                  p = .3 * d;
                }
                if (a < Math.abs(c)) {
                  a = c;
                  s = p / 4;
                } else {
                  s = p / (2 * Math.PI) * Math.asin(c / a);
                }
                return -a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) + b;
              },
              easeOutElastic: function(t, b, c, d) {
                var s = 1.70158;
                var p = 0;
                var a = c;
                if (0 == t) {
                  return b;
                }
                if (1 == (t /= d)) {
                  return b + c;
                }
                if (!p) {
                  p = .3 * d;
                }
                if (a < Math.abs(c)) {
                  a = c;
                  s = p / 4;
                } else {
                  s = p / (2 * Math.PI) * Math.asin(c / a);
                }
                return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
              },
              easeInOutElastic: function(t, b, c, d) {
                // jshint eqeqeq: false, -W041: true
                var s = 1.70158;
                var p = 0;
                var a = c;
                if (0 == t) {
                  return b;
                }
                if (2 == (t /= d / 2)) {
                  return b + c;
                }
                if (!p) {
                  p = d * (.3 * 1.5);
                }
                if (a < Math.abs(c)) {
                  a = c;
                  s = p / 4;
                } else {
                  s = p / (2 * Math.PI) * Math.asin(c / a);
                }
                if (t < 1) {
                  return a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * -.5 + b;
                }
                return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
              },
              easeInBack: function(t, b, c, d, s) {
                // jshint eqeqeq: false, -W041: true
                if (void 0 == s) {
                  s = 1.70158;
                }
                return c * (t /= d) * t * ((s + 1) * t - s) + b;
              },
              easeOutBack: function(t, b, c, d, s) {
                // jshint eqeqeq: false, -W041: true
                if (void 0 == s) {
                  s = 1.70158;
                }
                return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
              },
              easeInOutBack: function(t, b, c, d, s) {
                // jshint eqeqeq: false, -W041: true
                if (void 0 == s) {
                  s = 1.70158;
                }
                if ((t /= d / 2) < 1) {
                  return c / 2 * (t * t * ((1 + (s *= 1.525)) * t - s)) + b;
                }
                return c / 2 * ((t -= 2) * t * ((1 + (s *= 1.525)) * t + s) + 2) + b;
              },
              easeInBounce: function(t, b, c, d) {
                return c - Fns.easeOutBounce(d - t, 0, c, d) + b;
              },
              easeOutBounce: function(t, b, c, d) {
                if ((t /= d) < 1 / 2.75) {
                  return c * (7.5625 * t * t) + b;
                } else if (t < 2 / 2.75) {
                  return c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b;
                } else if (t < 2.5 / 2.75) {
                  return c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b;
                } else {
                  return c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b;
                }
              },
              easeInOutBounce: function(t, b, c, d) {
                if (t < d / 2) {
                  return .5 * Fns.easeInBounce(2 * t, 0, c, d) + b;
                }
                return .5 * Fns.easeOutBounce(2 * t - d, 0, c, d) + .5 * c + b;
              }
            };
          })();
          TweenManager = class_create({
            animating: false,
            frame: null,
            constructor: function(compo) {
              this.parent = compo;
              this.tweens = {};
              this.tick = this.tick.bind(this);
              compo_attachDisposer(compo, this.dispose.bind(this));
            },
            start: function(key, prop, start, end, easing) {
              // Tween is not disposable, as no resources are held. So if a tween already exists, it will be just overwritten.
              this.tweens[key] = new Tween(key, prop, start, end, easing);
              this.process();
            },
            process: function() {
              if (this.animating) {
                return;
              }
              this.animation = true;
              this.frame = ani_requestFrame.call(null, this.tick);
            },
            dispose: function() {
              ani_clearFrame.call(null, this.frame);
            },
            tick: function(timestamp) {
              var busy = false;
              for (var key in this.tweens) {
                var tween = this.tweens[key];
                if (null == tween) {
                  continue;
                }
                tween.tick(timestamp, this.parent);
                if (false === tween.animating) {
                  this.tweens[key] = null;
                  continue;
                }
                busy = true;
              }
              if (this.parent.onEnterFrame) {
                this.parent.onEnterFrame();
              }
              if (busy) {
                this.frame = ani_requestFrame.call(null, this.tick);
                return;
              }
              this.animating = false;
            }
          });
        })();
        ani_requestFrame = _global.requestAnimationFrame;
        ani_clearFrame = _global.cancelAnimationFrame;
        ani_updateAttr = function(compo, key, prop, val, meta) {
          var transition = compo.attr[key + '-transition'];
          if (null == transition && is_Object(meta)) {
            transition = meta.transition;
          }
          if (null == transition) {
            compo.attr[key] = val;
            if (null != prop) {
              compo[prop] = val;
            }
            _refresh(compo);
            return;
          }
          var tweens = compo.__tweens;
          if (null == tweens) {
            tweens = compo.__tweens = new TweenManager(compo);
          }
          var start = compo[prop];
          var end = val;
          tweens.start(key, prop, start, end, transition);
        };
        function _refresh(compo) {
          if (null == compo.onEnterFrame) {
            return;
          }
          if (null != compo.__frame) {
            ani_clearFrame.call(null, compo.__frame);
          }
          compo.__frame = ani_requestFrame.call(null, compo.onEnterFrame);
        }
      })();
      var dfr_isBusy;
      (function() {
        dfr_isBusy = function(dfr) {
          if (null == dfr || 'function' !== typeof dfr.then) {
            return false;
            // Class.Deferred
                    }
          if (is_Function(dfr.isBusy)) {
            return dfr.isBusy();
            // jQuery Deferred
                    }
          if (is_Function(dfr.state)) {
            return 'pending' === dfr.state();
          }
          if (dfr instanceof Promise) {
            return true;
          }
          log_warn('Class, jQuery or native promise expected');
          return false;
        };
        var Promise = _global.Promise;
      })();
      var selector_parse, selector_match;
      (function() {
        selector_parse = function(selector, type, direction) {
          if (null == selector) {
            log_error('<compo>selector is undefined', type);
          }
          if ('object' === typeof selector) {
            return selector;
          }
          var key, prop, nextKey;
          if (null == key) {
            switch (selector[0]) {
             case '#':
              key = 'id';
              selector = selector.substring(1);
              prop = 'attr';
              break;

             case '.':
              key = 'class';
              selector = sel_hasClassDelegate(selector.substring(1));
              prop = 'attr';
              break;

             case '[':
              var matches = /(\w+)\s*=([^\]]+)/.exec(selector);
              if (null == matches) {
                throw Error('Invalid attributes selector: ' + selector);
              }
              key = matches[1];
              selector = matches[2].trim();
              prop = 'attr';
              break;

             default:
              key = type === Dom.SET ? 'tagName' : 'compoName';
              break;
            }
          }
          if ('up' === direction) {
            nextKey = 'parent';
          } else {
            nextKey = type === Dom.SET ? 'nodes' : 'components';
          }
          return {
            key: key,
            prop: prop,
            selector: selector,
            nextKey: nextKey
          };
        };
        selector_match = function(node, selector, type) {
          if (null == node) {
            return false;
          }
          if (is_String(selector)) {
            if (null == type) {
              type = Dom[node.compoName ? 'CONTROLLER' : 'SET'];
            }
            selector = selector_parse(selector, type);
          }
          var obj = selector.prop ? node[selector.prop] : node;
          if (null == obj) {
            return false;
          }
          if (is_Function(selector.selector)) {
            return selector.selector(obj[selector.key]);
            // regexp
                    }
          if ('string' !== typeof selector.selector && null != selector.selector.test) {
            return selector.selector.test(obj[selector.key]);
            // string | int
            /* jshint eqeqeq: false */          }
          return obj[selector.key] == selector.selector;
          /* jshint eqeqeq: true */        }
        // PRIVATE
        ;
        function sel_hasClassDelegate(matchClass) {
          return function(className) {
            return sel_hasClass(className, matchClass);
          };
        }
        // [perf] http://jsperf.com/match-classname-indexof-vs-regexp/2
                function sel_hasClass(className, matchClass, index) {
          if ('string' !== typeof className) {
            return false;
          }
          if (null == index) {
            index = 0;
          }
          index = className.indexOf(matchClass, index);
          if (-1 === index) {
            return false;
          }
          if (index > 0 && className.charCodeAt(index - 1) > 32) {
            return sel_hasClass(className, matchClass, index + 1);
          }
          var class_Length = className.length, match_Length = matchClass.length;
          if (index < class_Length - match_Length && className.charCodeAt(index + match_Length) > 32) {
            return sel_hasClass(className, matchClass, index + 1);
          }
          return true;
        }
      })();
      var find_findSingle, find_findChildren, find_findChild, find_findAll;
      (function() {
        find_findSingle = function(node, matcher) {
          if (null == node) {
            return null;
          }
          if (is_Array(node)) {
            var arr = node, imax = arr.length, i = -1;
            while (++i < imax) {
              var x = find_findSingle(node[i], matcher);
              if (null != x) {
                return x;
              }
            }
            return null;
          }
          if (selector_match(node, matcher)) {
            return node;
          }
          node = node[matcher.nextKey];
          return null == node ? null : find_findSingle(node, matcher);
        };
        find_findChildren = function(node, matcher) {
          if (null == node) {
            return null;
          }
          var arr = node[matcher.nextKey];
          if (null == arr) {
            return null;
          }
          if (is_Array(arr)) {
            var imax = arr.length, i = -1, out = [];
            while (++i < imax) {
              if (selector_match(arr[i], matcher)) {
                out.push(arr[i]);
              }
            }
            return out;
          }
        };
        find_findChild = function(node, matcher) {
          if (null == node) {
            return null;
          }
          var arr = node[matcher.nextKey];
          if (null == arr) {
            return null;
          }
          if (is_Array(arr)) {
            var imax = arr.length, i = -1;
            while (++i < imax) {
              if (selector_match(arr[i], matcher)) {
                return arr[i];
              }
            }
            return null;
          }
        };
        find_findAll = function(node, matcher, out) {
          if (null == out) {
            out = [];
          }
          if (is_Array(node)) {
            var imax = node.length, i = 0;
            for (;i < imax; i++) {
              find_findAll(node[i], matcher, out);
            }
            return out;
          }
          if (selector_match(node, matcher)) {
            out.push(node);
          }
          node = node[matcher.nextKey];
          return null == node ? out : find_findAll(node, matcher, out);
        };
      })();
      (function() {
        compo_find = function(compo, selector) {
          return find_findSingle(compo, selector_parse(selector, Dom.CONTROLLER, 'down'));
        };
        compo_findAll = function(compo, selector) {
          return find_findAll(compo, selector_parse(selector, Dom.CONTROLLER, 'down'));
        };
        compo_closest = function(compo, selector) {
          return find_findSingle(compo, selector_parse(selector, Dom.CONTROLLER, 'up'));
        };
        compo_children = function(compo, selector) {
          return find_findChildren(compo, selector_parse(selector, Dom.CONTROLLER));
        };
        compo_child = function(compo, selector) {
          return find_findChild(compo, selector_parse(selector, Dom.CONTROLLER));
        };
      })();
      var Events_;
      (function() {
        (function() {
          /**
					 *	Combine .filter + .find
					 */
          domLib_find = function($set, selector) {
            return $set.filter(selector).add($set.find(selector));
          };
          domLib_on = function($set, type, selector, fn) {
            if (null == selector) {
              return $set.on(type, fn);
            }
            if (KeyboardHandler.supports(type, selector)) {
              return $set.each(function(i, el) {
                KeyboardHandler.on(el, type, selector, fn);
              });
            }
            return $set.on(type, selector, fn).filter(selector).on(type, fn);
          };
        })();
        Events_ = {
          on: function(component, events, $el) {
            if (null == $el) {
              $el = component.$;
            }
            var isarray = events instanceof Array, length = isarray ? events.length : 1;
            for (var x, i = 0; isarray ? i < length : i < 1; i++) {
              x = isarray ? events[i] : events;
              if (x instanceof Array) {
                // generic jQuery .on Arguments
                if (null != EventDecorator) {
                  x[0] = EventDecorator(x[0]);
                }
                $el.on.apply($el, x);
                continue;
              }
              for (var key in x) {
                var type, selector, fn = 'string' === typeof x[key] ? component[x[key]] : x[key], semicolon = key.indexOf(':');
                if (-1 !== semicolon) {
                  type = key.substring(0, semicolon);
                  selector = key.substring(semicolon + 1).trim();
                } else {
                  type = key;
                }
                if (null != EventDecorator) {
                  type = EventDecorator(type);
                }
                domLib_on($el, type, selector, fn_proxy(fn, component));
              }
            }
          },
          setEventDecorator: function(x) {
            EventDecorator = x;
          }
        };
        var EventDecorator = null;
      })();
      var Children_;
      (function() {
        (function() {
          (function() {
            domLib_initialize = function() {
              if (null == domLib || null == domLib.fn) {
                return;
              }
              domLib.fn.compo = function(selector) {
                if (0 === this.length) {
                  return null;
                }
                var compo = Anchor.resolveCompo(this[0], true);
                return null == selector ? compo : find_findSingle(compo, selector_parse(selector, Dom.CONTROLLER, 'up'));
              };
              domLib.fn.model = function(selector) {
                var compo = this.compo(selector);
                if (null == compo) {
                  return null;
                }
                var model = compo.model;
                while (null == model && compo.parent) {
                  compo = compo.parent;
                  model = compo.model;
                }
                return model;
              };
              // insert
              (function() {
                var jQ_Methods = [ 'append', 'prepend', 'before', 'after' ];
                [ 'appendMask', 'prependMask', 'beforeMask', 'afterMask' ].forEach(function(method, index) {
                  domLib.fn[method] = function(template, model, ctr, ctx) {
                    if (0 === this.length) {
                      return this;
                    }
                    if (this.length > 1) {}
                    if (null == ctr) {
                      ctr = index < 2 ? this.compo() : this.parent().compo();
                    }
                    var isUnsafe = false;
                    if (null == ctr) {
                      ctr = {};
                      isUnsafe = true;
                    }
                    if (null == ctr.components) {
                      ctr.components = [];
                    }
                    var compos = ctr.components, i = compos.length, fragment = renderer_render(template, model, ctx, null, ctr);
                    var self = this[jQ_Methods[index]](fragment), imax = compos.length;
                    for (;i < imax; i++) {
                      CompoSignals.signal.emitIn(compos[i], 'domInsert');
                    }
                    if (isUnsafe && 0 !== imax) {
                      // if DEBUG
                      log_warn('$.', method, '- parent controller was not found in Elements DOM.', 'This can lead to memory leaks.');
                      log_warn('Specify the controller directly, via $.', method, '(template[, model, controller, ctx])');
                      // endif
                                        }
                    return self;
                  };
                });
              })();
              // remove
              (function() {
                var jq_remove = domLib.fn.remove, jq_empty = domLib.fn.empty;
                domLib.fn.removeAndDispose = function() {
                  this.each(each_tryDispose);
                  return jq_remove.call(this);
                };
                domLib.fn.emptyAndDispose = function() {
                  this.each(each_tryDisposeChildren);
                  return jq_empty.call(this);
                };
                function each_tryDispose(i, el) {
                  node_tryDispose(el);
                }
                function each_tryDisposeChildren(i, el) {
                  node_tryDisposeChildren(el);
                }
              })();
            }
            // try to initialize the dom lib, or is then called from `setDOMLibrary`
            ;
            domLib_initialize();
          })();
          (function() {
            var hasTouch = function() {
              if ('undefined' === typeof document || null == document) {
                return false;
              }
              if ('createTouch' in document) {
                return true;
              }
              try {
                return !!document.createEvent('TouchEvent').initTouchEvent;
              } catch (error) {
                return false;
              }
            }();
            EventsDeco = {
              touch: function(type) {
                if (false === hasTouch) {
                  return type;
                }
                if ('click' === type) {
                  return 'touchend';
                }
                if ('mousedown' === type) {
                  return 'touchstart';
                }
                if ('mouseup' === type) {
                  return 'touchend';
                }
                if ('mousemove' === type) {
                  return 'touchmove';
                }
                return type;
              }
            };
          })();
          CompoConfig = {
            selectors: {
              $: function(compo, selector) {
                var r = domLib_find(compo.$, selector);
                return r;
              },
              compo: function(compo, selector) {
                var r = compo_find(compo, selector);
                return r;
              }
            },
            /**
					     *	@default, global $ is used
					     *	IDOMLibrary = {
					     *	{fn}(elements) - create dom-elements wrapper,
					     *	on(event, selector, fn) - @see jQuery 'on'
					     *	}
					     */
            setDOMLibrary: function(lib) {
              if (domLib === lib) {
                return;
              }
              setDomLib(lib);
              domLib_initialize();
            },
            getDOMLibrary: function() {
              return domLib;
            },
            eventDecorator: function(mix) {
              if ('function' === typeof mix) {
                Events_.setEventDecorator(mix);
                return;
              }
              if ('string' === typeof mix) {
                console.error('EventDecorators are not used. Touch&Mouse support is already integrated');
                Events_.setEventDecorator(EventsDeco[mix]);
                return;
              }
              if ('boolean' === typeof mix && false === mix) {
                Events_.setEventDecorator(null);
                return;
              }
            }
          };
        })();
        Children_ = {
          /**
				    *	Component children. Example:
				    *
				    *	Class({
				    *		Base: Compo,
				    *		Construct: function(){
				    *			this.compos = {
				    *				panel: '$: .container',  // querying with DOMLib
				    *				timePicker: 'compo: timePicker', // querying with Compo selector
				    *				button: '#button' // querying with querySelector***
				    *			}
				    *		}
				    *	});
				    *
				    */
          select: function(component, compos) {
            for (var name in compos) {
              var data = compos[name], events = null, selector = null;
              if (data instanceof Array) {
                console.error('obsolete');
                selector = data[0];
                events = data.splice(1);
              }
              if ('string' === typeof data) {
                selector = data;
              }
              if (null == data || null == selector) {
                log_error('Unknown component child', name, compos[name]);
                log_warn('Is this object shared within multiple compo classes? Define it in constructor!');
                return;
              }
              var index = selector.indexOf(':');
              var engine = CompoConfig.selectors[selector.substring(0, index)];
              if (null == engine) {
                var $els = component.$;
                var el = void 0;
                for (var i = 0; i < $els.length; i++) {
                  var x = $els[i];
                  el = x.querySelector(selector);
                  if (null != el) {
                    break;
                  }
                  if (x.matches(selector)) {
                    el = x;
                    break;
                  }
                }
                component.compos[name] = el;
              } else {
                selector = selector.substring(++index).trim();
                component.compos[name] = engine(component, selector);
              }
              var element = component.compos[name];
              if (null != events) {
                if (null != element.$) {
                  element = element.$;
                }
                Events_.on(component, events, element);
              }
            }
          },
          selectSelf: function(self, refs) {
            var compos = refs.compos;
            if (compos) {
              for (var prop in compos) {
                self[prop] = CompoConfig.selectors.compo(self, compos[prop]);
              }
            }
            var q = refs.queries;
            if (q) {
              for (var prop in q) {
                self[prop] = CompoConfig.selectors.$(self, q[prop]);
              }
            }
            var els = refs.elements;
            if (els) {
              for (var prop in els) {
                self[prop] = self.$[0].querySelector(els[prop]);
              }
            }
          }
        };
      })();
      CompoProto = {
        type: Dom.CONTROLLER,
        __constructed: false,
        __resource: null,
        __frame: null,
        __tweens: null,
        ID: null,
        $: null,
        tagName: null,
        compoName: null,
        parent: null,
        node: null,
        nodes: null,
        components: null,
        expression: null,
        attr: null,
        model: null,
        scope: null,
        slots: null,
        pipes: null,
        compos: null,
        events: null,
        hotkeys: null,
        async: false,
        await: null,
        resume: null,
        meta: null,
        getAttribute: function(key) {
          var _a;
          var def = null === (_a = this.meta.attributes) || void 0 === _a ? void 0 : _a[key];
          if (null == def) {
            return this.attr[key];
          }
          var prop = compo_meta_toAttributeKey(key, def);
          return this[prop];
        },
        setAttribute: function(key, val) {
          var _a, _b;
          var prop = null;
          var def = null === (_a = this.meta.attributes) || void 0 === _a ? void 0 : _a[key];
          if (null != def) {
            prop = compo_meta_toAttributeKey(key, def);
          } else {
            def = null === (_b = this.meta.properties) || void 0 === _b ? void 0 : _b[key];
            if (null != def) {
              prop = key;
            }
          }
          ani_updateAttr(this, key, prop, val, def);
          if (this.onAttributeSet) {
            this.onAttributeSet(key, val);
          }
        },
        onAttributeSet: null,
        onRenderStart: null,
        onRenderStartClient: null,
        onRenderEnd: null,
        onRenderEndServer: null,
        onEnterFrame: null,
        render: null,
        renderStart: function(model, ctx, container) {
          compo_ensureTemplate(this);
          if (is_Function(this.onRenderStart)) {
            var x = this.onRenderStart(model, ctx, container);
            if (void 0 !== x && dfr_isBusy(x)) {
              compo_prepairAsync(x, this, ctx);
            }
          }
        },
        renderStartClient: function(model, ctx, container) {
          if (is_Function(this.onRenderStartClient)) {
            var x = this.onRenderStartClient(model, ctx, container);
            if (void 0 !== x && dfr_isBusy(x)) {
              compo_prepairAsync(x, this, ctx);
            }
          }
        },
        renderEnd: function(elements, model, ctx, container) {
          var _a;
          Anchor.create(this);
          this.$ = domLib(elements);
          if (null != this.events) {
            Events_.on(this, this.events);
          }
          if (null != this.compos) {
            Children_.select(this, this.compos);
          }
          if (null != (null === (_a = this.meta) || void 0 === _a ? void 0 : _a.refs)) {
            Children_.selectSelf(this, this.meta.refs);
          }
          if (null != this.hotkeys) {
            KeyboardHandler.hotkeys(this, this.hotkeys);
          }
          if (is_Function(this.onRenderEnd)) {
            this.onRenderEnd(elements, model, ctx, container);
          }
          if (is_Function(this.onEnterFrame)) {
            this.onEnterFrame = this.onEnterFrame.bind(this);
            this.onEnterFrame();
          }
        },
        appendTo: function(el) {
          this.$.appendTo(el);
          this.emitIn('domInsert');
          return this;
        },
        append: function(template, model, selector) {
          if (null == this.$) {
            var ast = is_String(template) ? parser_parse(template) : template;
            var parent = this;
            if (selector) {
              parent = find_findSingle(this, selector_parse(selector, Dom.CONTROLLER, 'down'));
              if (null == parent) {
                log_error('Compo::append: Container not found');
                return this;
              }
            }
            parent.nodes = [ parent.nodes, ast ];
            return this;
          }
          var frag = renderer_render(template, model, null, null, this);
          parent = selector ? this.$.find(selector) : this.$;
          parent.append(frag);
          // @todo do not emit to created compos before
                    this.emitIn('domInsert');
          return this;
        },
        find: function(selector) {
          return compo_find(this, selector);
        },
        findAll: function(selector) {
          return compo_findAll(this, selector);
        },
        closest: function(selector) {
          return compo_closest(this, selector);
        },
        on: function() {
          var x = _Array_slice.call(arguments);
          if (arguments.length < 3) {
            log_error('Invalid Arguments Exception @use .on(type,selector,fn)');
            return this;
          }
          if (null != this.$) {
            Events_.on(this, [ x ]);
          }
          if (null == this.events) {
            this.events = [ x ];
          } else if (is_Array(this.events)) {
            this.events.push(x);
          } else {
            this.events = [ x, this.events ];
          }
          return this;
        },
        remove: function() {
          compo_cleanElements(this);
          compo_removeElements(this);
          compo_detachChild(this);
          compo_dispose(this);
          this.$ = null;
          return this;
        },
        slotState: function(slotName, isActive) {
          CompoSignals.slot.toggle(this, slotName, isActive);
          return this;
        },
        signalState: function(signalName, isActive) {
          CompoSignals.signal.toggle(this, signalName, isActive);
          return this;
        },
        emitOut: function(signalName, a1, a2, a3, a4) {
          CompoSignals.signal.emitOut(this, signalName, this, [ a1, a2, a3, a4 ]);
          return this;
        },
        emitIn: function(signalName, a1, a2, a3, a4) {
          CompoSignals.signal.emitIn(this, signalName, this, [ a1, a2, a3, a4 ]);
          return this;
        },
        $scope: function(path) {
          return expression_eval('$scope?.' + path, null, null, this);
        },
        $eval: function(expr, model, ctx) {
          return expression_eval(expr, model || this.model, ctx, this);
        },
        attach: function(name, fn) {
          compo_attach(this, name, fn);
        },
        serializeState: function() {
          if (this.scope) {
            return {
              scope: this.scope
            };
          }
        },
        deserializeState: function(bundle) {
          if (null != bundle && null != bundle.scope) {
            this.scope = obj_extend(this.scope, bundle.scope);
          }
        }
      };
    })();
    (function() {
      var compo_prepairProperties, compo_baseConstructor;
      (function() {
        (function() {
          var _collection = {};
          customAttr_register('x-pipe-signal', 'client', function(node, attrValue, model, ctx, element, ctr) {
            var x, arr = attrValue.split(';'), imax = arr.length, i = -1;
            while (++i < imax) {
              x = arr[i].trim();
              if ('' === x) {
                continue;
              }
              var pipe, signal, i_colon = x.indexOf(':'), event = x.substring(0, i_colon), handler = x.substring(i_colon + 1).trim(), dot = handler.indexOf('.');
              if (-1 === dot) {
                log_error('Pipe-slot is invalid: {0} Usage e.g. "click: pipeName.pipeSignal"', x);
                return;
              }
              pipe = handler.substring(0, dot);
              signal = handler.substring(++dot);
              // if DEBUG
                            !event && log_error('Pipe-slot is invalid. Event type is not set', attrValue);
              // endif
                            dom_addEventListener(element, event, _createListener(pipe, signal));
            }
          });
          function _createListener(pipe, signal) {
            return function(event) {
              new Pipe(pipe).emit(signal, event);
            };
          }
          function pipe_attach(pipeName, ctr) {
            if (null == ctr.pipes[pipeName]) {
              log_error('Controller has no pipes to be added to collection', pipeName, ctr);
              return;
            }
            if (null == _collection[pipeName]) {
              _collection[pipeName] = [];
            }
            _collection[pipeName].push(ctr);
          }
          function pipe_detach(pipeName, ctr) {
            var pipe = _collection[pipeName], i = pipe.length;
            while (--i > -1) {
              if (pipe[i] === ctr) {
                pipe.splice(i, 1);
              }
            }
          }
          function _removeController(ctr) {
            var pipes = ctr.pipes;
            for (var key in pipes) {
              pipe_detach(key, ctr);
            }
          }
          function _removeControllerDelegate(ctr) {
            return function() {
              _removeController(ctr);
              ctr = null;
            };
          }
          function _addController(ctr) {
            var pipes = ctr.pipes;
            // if DEBUG
                        if (null == pipes) {
              log_error('Controller has no pipes', ctr);
              return;
            }
            // endif
                        for (var key in pipes) {
              pipe_attach(key, ctr);
            }
            compo_attachDisposer(ctr, _removeControllerDelegate(ctr));
          }
          var Pipe = /** @class */ function() {
            function Pipe(name) {
              this.name = name;
            }
            Pipe.prototype.emit = function(signal, a, b, c) {
              var controllers = _collection[this.name], name = this.name, args = _Array_slice.call(arguments, 1);
              if (null == controllers) {
                //if DEBUG
                log_warn('Pipe.emit: No signals were bound to:', name);
                //endif
                                return;
              }
              var i = controllers.length, called = false;
              while (-1 !== --i) {
                var ctr = controllers[i];
                var slots = ctr.pipes[name];
                if (null == slots) {
                  continue;
                }
                var slot = slots[signal];
                if (null != slot) {
                  slot.apply(ctr, args);
                  called = true;
                }
              }
              // if DEBUG
                            if (false === called) {
                log_warn('Pipe `%s` has not slots for `%s`', name, signal);
                // endif
                            }
            };
            return Pipe;
          }();
          Pipe;
          function PipeCtor(name) {
            return new Pipe(name);
          }
          PipeCtor.addController = _addController;
          PipeCtor.removeController = _removeController;
          Pipes = {
            addController: _addController,
            removeController: _removeController,
            pipe: PipeCtor
          };
        })();
        // export function compo_create(arguments_: any[]) {
        //     var argLength = arguments_.length,
        //         Proto = arguments_[argLength - 1],
        //         Ctor,
        //         hasBase;
        //     if (argLength > 1)
        //         hasBase = compo_inherit(
        //             Proto,
        //             _Array_slice.call(arguments_, 0, argLength - 1)
        //         );
        //     if (Proto == null) Proto = {};
        //     var include = _resolve_External('include');
        //     if (include != null) Proto.__resource = include.url;
        //     compo_prepairProperties(Proto);
        //     Ctor = Proto.hasOwnProperty('constructor') ? Proto.constructor : null;
        //     Ctor = compo_createConstructor(Ctor, Proto, hasBase);
        //     obj_extendDefaults(Proto, CompoProto);
        //     Ctor.prototype = Proto;
        //     Proto = null;
        //     return Ctor;
        // }
                compo_prepairProperties = function(Proto) {
          for (var key in Proto.attr) {
            Proto.attr[key] = _mask_ensureTmplFn(Proto.attr[key]);
          }
          var slots = Proto.slots;
          for (var key in slots) {
            if ('string' === typeof slots[key]) {
              slots[key] = Proto[slots[key]];
            }
          }
          compo_meta_prepairAttributesHandler(Proto);
          compo_meta_prepairArgumentsHandler(Proto);
        }
        // export function compo_createConstructor(Ctor, proto, hasBaseAlready) {
        //     return function CompoBase(node, model, ctx, container, ctr) {
        //         if (Ctor != null) {
        //             var overriden = Ctor.call(this, node, model, ctx, container, ctr);
        //             if (overriden != null) return overriden;
        //         }
        //         if (hasBaseAlready === true) {
        //             return;
        //         }
        //         if (this.compos != null) {
        //             this.compos = obj_create(this.compos);
        //         }
        //         if (this.pipes != null) {
        //             Pipes.addController(this);
        //         }
        //         if (this.attr != null) {
        //             this.attr = obj_create(this.attr);
        //         }
        //         if (this.scope != null) {
        //             this.scope = obj_create(this.scope);
        //         }
        //     };
        // }
        ;
        compo_baseConstructor = function() {
          if (true === this.__constructed) {
            return;
          }
          this.__constructed = true;
          if (null != this.compos) {
            this.compos = obj_create(this.compos);
          }
          if (null != this.pipes) {
            Pipes.addController(this);
          }
          if (null != this.attr) {
            this.attr = obj_create(this.attr);
          }
          if (null != this.scope) {
            this.scope = obj_create(this.scope);
          }
        };
      })();
      (function() {
        (function() {
          (function(document) {
            if (null == document) {
              return;
            }
            DomLite = function(mix) {
              if (this instanceof DomLite === false) {
                return new DomLite(mix);
              }
              if ('string' === typeof mix) {
                mix = document.querySelectorAll(mix);
              }
              return this.add(mix);
            };
            if (null == domLib) {
              setDomLib(DomLite);
            }
            var Proto = DomLite.fn = {
              constructor: DomLite,
              length: 0,
              add: function(mix) {
                if (null == mix) {
                  return this;
                }
                if (true === is_Array(mix)) {
                  return each(mix, this.add, this);
                }
                var type = mix.nodeType;
                if (11 /* Node.DOCUMENT_FRAGMENT_NODE */ === type) {
                  return each(mix.childNodes, this.add, this);
                }
                if (null == type) {
                  if ('number' === typeof mix.length) {
                    return each(mix, this.add, this);
                  }
                  log_warn('Uknown domlite object');
                  return this;
                }
                this[this.length++] = mix;
                return this;
              },
              on: function() {
                return binder.call(this, on, delegate, arguments);
              },
              off: function() {
                return binder.call(this, off, undelegate, arguments);
              },
              find: function(sel) {
                return each(this, function(node) {
                  this.add(_$$.call(node, sel));
                }, new DomLite());
              },
              filter: function(sel) {
                return each(this, function(node, index) {
                  true === _is(node, sel) && this.add(node);
                }, new DomLite());
              },
              parent: function() {
                var x = this[0];
                return new DomLite(x && x.parentNode);
              },
              children: function(sel) {
                var set = each(this, function(node) {
                  this.add(node.childNodes);
                }, new DomLite());
                return null == sel ? set : set.filter(sel);
              },
              closest: function(selector) {
                var x = this[0], dom = new DomLite();
                while (null != x && null != x.parentNode) {
                  x = x.parentNode;
                  if (_is(x, selector)) {
                    return dom.add(x);
                  }
                }
                return dom;
              },
              next: function(selector) {
                var x = this[0], dom = new DomLite();
                while (null != x && null != x.nextElementSibling) {
                  x = x.nextElementSibling;
                  if (null == selector) {
                    return dom.add(x);
                  }
                  if (_is(x, selector)) {
                    return dom.add(x);
                  }
                }
                return dom;
              },
              remove: function() {
                return each(this, function(x) {
                  x.parentNode.removeChild(x);
                });
              },
              text: function(mix) {
                if (0 === arguments.length) {
                  return aggr('', this, function(txt, x) {
                    return txt + x.textContent;
                  });
                }
                return each(this, function(x) {
                  x.textContent = mix;
                });
              },
              html: function(mix) {
                if (0 === arguments.length) {
                  return aggr('', this, function(txt, x) {
                    return txt + x.innerHTML;
                  });
                }
                return each(this, function(x) {
                  x.innerHTML = mix;
                });
              },
              val: function(mix) {
                if (0 === arguments.length) {
                  return 0 === this.length ? null : this[0].value;
                }
                if (0 !== this.length) {
                  this[0].value = mix;
                }
                return this;
              },
              focus: function() {
                return each(this, function(x) {
                  x.focus && x.focus();
                });
              },
              get: function(i) {
                return this[i];
              },
              toArray: function() {
                return Array.from(this);
              }
            };
            (function() {
              each([ 'show', 'hide' ], function(method) {
                Proto[method] = function() {
                  return each(this, function(x) {
                    x.style.display = 'hide' === method ? 'none' : '';
                  });
                };
              });
            })();
            (function() {
              var Manip = {
                append: function(node, el) {
                  after_(node, node.lastChild, el);
                },
                prepend: function(node, el) {
                  before_(node, node.firstChild, el);
                },
                after: function(node, el) {
                  after_(node.parentNode, node, el);
                },
                before: function(node, el) {
                  before_(node.parentNode, node, el);
                }
              };
              each([ 'append', 'prepend', 'before', 'after' ], function(method) {
                var fn = Manip[method];
                Proto[method] = function(mix) {
                  var isArray = is_Array(mix);
                  return each(this, function(node) {
                    if (isArray) {
                      each(mix, function(el) {
                        fn(node, el);
                      });
                      return;
                    }
                    fn(node, mix);
                  });
                };
              });
              function before_(parent, anchor, el) {
                if (null == parent || null == el) {
                  return;
                }
                parent.insertBefore(el, anchor);
              }
              function after_(parent, anchor, el) {
                var next = null != anchor ? anchor.nextSibling : null;
                before_(parent, next, el);
              }
            })();
            function each(arr, fn, ctx) {
              if (null == arr) {
                return ctx || arr;
              }
              var imax = arr.length, i = -1;
              while (++i < imax) {
                fn.call(ctx || arr, arr[i], i);
              }
              return ctx || arr;
            }
            function aggr(seed, arr, fn, ctx) {
              each(arr, function(x, i) {
                seed = fn.call(ctx || arr, seed, arr[i], i);
              });
              return seed;
            }
            function indexOf(arr, fn, ctx) {
              if (null == arr) {
                return -1;
              }
              var imax = arr.length, i = -1;
              while (++i < imax) {
                if (true === fn.call(ctx || arr, arr[i], i)) {
                  return i;
                }
              }
              return -1;
            }
            var docEl = document.documentElement;
            var _$$ = docEl.querySelectorAll;
            var _is = function() {
              var matchesSelector = docEl.webkitMatchesSelector || docEl.mozMatchesSelector || docEl.msMatchesSelector || docEl.oMatchesSelector || docEl.matchesSelector;
              return function(el, selector) {
                return null == el || 1 !== el.nodeType ? false : matchesSelector.call(el, selector);
              };
            }();
            /* Events */            var binder, on, off, delegate, undelegate;
            (function() {
              binder = function(bind, bindSelector, args) {
                var fn, length = args.length;
                if (2 === length) {
                  fn = bind;
                }
                if (3 === length) {
                  fn = bindSelector;
                }
                if (null != fn) {
                  return each(this, function(node) {
                    fn.apply(DomLite(node), args);
                  });
                }
                log_error('`DomLite.on|off` - invalid arguments count');
                return this;
              };
              on = function(type, fn) {
                return run(this, _addEvent, type, fn);
              };
              off = function(type, fn) {
                return run(this, _remEvent, type, fn);
              };
              delegate = function(type, selector, fn) {
                function guard(event) {
                  var el = event.target, current = event.currentTarget;
                  if (current === el) {
                    return;
                  }
                  while (null != el && el !== current) {
                    if (_is(el, selector)) {
                      fn(event);
                      return;
                    }
                    el = el.parentNode;
                  }
                }
                (fn._guards || (fn._guards = [])).push(guard);
                return on.call(this, type, guard);
              };
              undelegate = function(type, selector, fn) {
                return each(fn._quards, function(guard) {
                  off.call(this, type, guard);
                }, this);
              };
              function run(set, handler, type, fn) {
                return each(set, function(node) {
                  handler.call(node, type, fn, false);
                });
              }
              var _addEvent = docEl.addEventListener, _remEvent = docEl.removeEventListener;
            })();
            /* class handler */
            (function() {
              var isClassListSupported = null != docEl.classList;
              var hasClass = true === isClassListSupported ? function(node, klass) {
                return node.classList.contains(klass);
              } : function(node, klass) {
                return -1 !== (' ' + node.className + ' ').indexOf(' ' + klass + ' ');
              };
              Proto['hasClass'] = function(klass) {
                return -1 !== indexOf(this, function(node) {
                  return hasClass(node, klass);
                });
              };
              var Shim;
              (function() {
                Shim = {
                  add: function(node, klass) {
                    if (false === hasClass(node, klass)) {
                      add(node, klass);
                    }
                  },
                  remove: function(node, klass) {
                    if (true === hasClass(node, klass)) {
                      remove(node, klass);
                    }
                  },
                  toggle: function(node, klass) {
                    var fn = true === hasClass(node, klass) ? remove : add;
                    fn(node, klass);
                  }
                };
                function add(node, klass) {
                  node.className += ' ' + klass;
                }
                function remove(node, klass) {
                  node.className = (' ' + node.className + ' ').replace(' ' + klass + ' ', ' ');
                }
              })();
              each([ 'add', 'remove', 'toggle' ], function(method) {
                var mutatorFn = false === isClassListSupported ? Shim[method] : function(node, klass) {
                  var classList = node.classList;
                  classList[method].call(classList, klass);
                };
                Proto[method + 'Class'] = function(klass) {
                  return each(this, function(node) {
                    mutatorFn(node, klass);
                  });
                };
              });
            })();
            // Events
            (function() {
              var createEvent = function(type) {
                var event = document.createEvent('Event');
                event.initEvent(type, true, true);
                return event;
              };
              var create = function(type, data) {
                if (null == data) {
                  return createEvent(type);
                }
                var event = document.createEvent('CustomEvent');
                event.initCustomEvent(type, true, true, data);
                return event;
              };
              var dispatch = function(node, event) {
                node.dispatchEvent(event);
              };
              Proto['trigger'] = function(type, data) {
                var event = create(type, data);
                return each(this, function(node) {
                  dispatch(node, event);
                });
              };
            })();
            // Attributes
            (function() {
              Proto['attr'] = function(name, val) {
                if (void 0 === val) {
                  return this[0] && this[0].getAttribute(name);
                }
                return each(this, function(node) {
                  node.setAttribute(name, val);
                });
              };
              Proto['removeAttr'] = function(name) {
                return each(this, function(node) {
                  node.removeAttribute(name);
                });
              };
            })();
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(Proto, Array.prototype);
            } else if (Proto.__proto__) {
              Proto.__proto__ = Array.prototype;
            }
            DomLite.prototype = Proto;
            domLib_initialize();
          })(_document);
        })();
        (function() {
          (function() {
            var ENV_CLASS = function() {
              try {
                new Function('class c{}')();
                return true;
              } catch (_a) {
                return false;
              }
            }();
            var ENV_SPREAD = function() {
              try {
                var x = new Function('x', 'return(function(...args){return args[0]}(x));return foo(x);')(1);
                return 1 === x;
              } catch (_a) {
                return false;
              }
            }();
            var class_overrideArgs = function() {
              if (false === ENV_CLASS) {
                return function(Ctor, innerFn) {
                  var Wrapped = function() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                      args[_i] = arguments[_i];
                    }
                    Ctor.apply(this, innerFn.apply(void 0, args));
                  };
                  Wrapped.prototype = Ctor.prototype;
                  return Wrapped;
                };
              }
              if (ENV_SPREAD) {
                return new Function('Ctor', 'innerFn', '\n            return class extends Ctor {\n                constructor (...args) {\n                    super(...innerFn(...args));\n                }\n            }\n        ');
              }
              return new Function('Ctor', 'innerFn', '\n        return class extends Ctor {\n            constructor () {\n                var x = innerFn.apply(null, arguments);\n                super(x[0], x[1], x[2], x[3], x[4], x[5]);\n            }\n        };\n    ');
            }();
            env_class_overrideArgs = class_overrideArgs;
            env_class_wrapCtors = function(Base, beforeFn, afterFn, middCtors) {
              if (null != middCtors) {
                for (var i = 0; i < middCtors.length; i++) {
                  middCtors[i] = ensureCallableSingle(middCtors[i]);
                }
              }
              return polyfill_class_wrap_inner(Base, beforeFn, afterFn, middCtors);
            };
            var polyfill_class_wrap_inner = function() {
              if (!ENV_CLASS) {
                return function(Base, beforeFn, afterFn, callCtors) {
                  var callBase = ensureCallableSingle(Base);
                  var Wrapped = function() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                      args[_i] = arguments[_i];
                    }
                    callBase(this, args);
                    if (null != beforeFn) {
                      beforeFn.apply(this, args);
                    }
                    if (null != callCtors) {
                      for (var i = callCtors.length - 1; i > -1; i--) {
                        callCtors[i](this, args);
                      }
                    }
                    if (null != afterFn) {
                      afterFn.apply(this, args);
                    }
                  };
                  obj_extend(Wrapped.prototype, Base.prototype);
                  return Wrapped;
                };
              }
              if (ENV_SPREAD) {
                return new Function('Base', 'beforeFn', 'afterFn', 'callCtors', '\n            return class extends Base {\n                constructor (...args) {\n                    super(...args);\n                    if (beforeFn != null) {\n                        beforeFn.apply(this, args);\n                    }\n                    if (callCtors != null) {\n                        for (var i = callCtors.length - 1; i > -1; i--) {\n                            callCtors[i](this, args);\n                        }\n                    }\n                    if (afterFn != null) {\n                        afterFn.apply(this, args);\n                    }\n                }\n            }\n        ');
              }
              return new Function('Base', 'beforeFn', 'afterFn', 'callCtors', '\n        return class extends Base {\n            constructor (a, b, c, d, e, f) {\n                super(a, b, c, d, e, f);\n                var args = Array.from(arguments);\n                if (beforeFn != null) {\n                    beforeFn.apply(this, args);\n                }\n                if (callCtors != null) {\n                    for (var i = callCtors.length - 1; i > -1; i--) {\n                        callCtors[i](this, args);\n                    }\n                }\n                if (afterFn != null) {\n                    afterFn.apply(this, args);\n                }\n            }\n        }\n    ');
            }();
            function ensureCallableSingle(fn) {
              var caller = directCaller;
              var safe = false;
              return function(self, args) {
                if (true === safe) {
                  caller(fn, self, args);
                  return;
                }
                try {
                  caller(fn, self, args);
                  safe = true;
                } catch (error) {
                  caller = newCaller;
                  safe = true;
                  caller(fn, self, args);
                }
              };
            }
            function directCaller(fn, self, args) {
              return fn.apply(self, args);
            }
            function newCaller(fn, self, args) {
              var x = new (fn.bind.apply(fn, [ null ].concat(args)))();
              obj_extend(self, x);
            }
          })();
          var protos = [];
          var getProtoOf = Object.getPrototypeOf;
          compo_createExt = function(Proto, Extends) {
            if (null == Extends || 0 === Extends.length) {
              return compo_createSingle(Proto);
            }
            var classes = [];
            for (var i = 0; i < Extends.length; i++) {
              if ('string' === typeof Extends[i]) {
                var x = Extends[i] = customTag_get(Extends[i]);
                if (null != x && 'Resolver' === x.name) {
                  log_error('Inheritance error: private component');
                  Extends[i] = {};
                }
              }
              if ('function' === typeof Extends[i]) {
                classes.push(Extends[i]);
              }
            }
            var ProtoCtor = Proto.hasOwnProperty('constructor') ? Proto.constructor : null;
            var Base = 0 === classes.length ? null : classes.pop();
            var beforeFn = compo_baseConstructor;
            var afterFn = ProtoCtor;
            if (null == Base) {
              Base = beforeFn;
              beforeFn = null;
            }
            var Ctor = env_class_wrapCtors(Base, beforeFn, afterFn, classes);
            var BaseProto = Base.prototype;
            protos.length = 0;
            for (i = 0; i < Extends.length; i++) {
              x = Extends[i];
              if (x === Base) {
                continue;
              }
              if ('function' === typeof x) {
                var proto = null == getProtoOf ? x.prototype : fillProtoHash(x.prototype, obj_create(null));
                protos.push(proto);
                continue;
              }
              protos.push(x);
            }
            var inheritMethods = obj_create(null);
            inheritBase_(Proto, BaseProto, inheritMethods);
            // merge prototype
                        for (i = protos.length - 1; i > -1; i--) {
              var source = protos[i];
              inheritMiddProto_(Proto, BaseProto, source, inheritMethods);
            }
            // inherit methods
                        for (var key in inheritMethods) {
              var outerFn = null;
              var l = protos.length;
              for (i = 0; i < l + 2; i++) {
                x = i < l ? protos[i] : null;
                if (i === l) {
                  x = BaseProto;
                }
                if (i === l + 1) {
                  x = Proto;
                }
                var fn = x[key];
                if (null == fn) {
                  continue;
                }
                if (null == outerFn) {
                  outerFn = fn;
                  continue;
                }
                outerFn = wrapInheritedFn(fn, outerFn);
              }
              Proto[key] = outerFn;
            }
            // merge templates
                        var template = null;
            for (i = protos.length - 1; i > -1; i--) {
              template = mergeNodes(protos[i], template);
            }
            template = mergeNodes(BaseProto, template);
            template = mergeNodes(Proto, template);
            if (null != template) {
              Proto.template = template;
              Proto.nodes = null;
              Ctor.prototype.nodes = null;
            }
            // do we need this?
                        var include = _resolve_External('include');
            if (null != include) {
              Proto.__resource = include.url;
            }
            compo_prepairProperties(Proto);
            obj_extendDefaults(Proto, CompoProto);
            var meta = Proto.meta;
            if (null == meta) {
              meta = Proto.meta = {};
            }
            if (null == meta.template) {
              meta.template = 'merge';
            }
            for (var key in Proto) {
              if ('constructor' === key) {
                continue;
              }
              var val = Proto[key];
              if (null != val) {
                Ctor.prototype[key] = Proto[key];
              }
            }
            return Ctor;
          };
          function compo_createSingle(Proto) {
            var ProtoCtor = Proto.hasOwnProperty('constructor') ? Proto.constructor : null;
            var Ctor = function CompoBase() {
              compo_baseConstructor.apply(this, arguments);
              if (ProtoCtor) {
                ProtoCtor.apply(this, arguments);
              }
            };
            var include = _resolve_External('include');
            if (null != include) {
              Proto.__resource = include.url;
            }
            compo_prepairProperties(Proto);
            Ctor.prototype = Proto;
            Ctor.prototype.constructor = Ctor;
            obj_extendDefaults(Ctor.prototype, CompoProto);
            return Ctor;
          }
          function inheritMiddProto_(Proto, BaseProto, source, inheritMethods) {
            for (var key in source) {
              if ('constructor' === key || 'template' === key || 'nodes' === key) {
                continue;
              }
              var targetVal = Proto[key];
              if (void 0 === targetVal) {
                targetVal = BaseProto[key];
              }
              var sourceVal = source[key];
              if (null == targetVal) {
                Proto[key] = sourceVal;
                continue;
              }
              if ('function' === typeof targetVal) {
                Proto.super = null;
              }
              var type = mergeProperty(Proto, key, targetVal, sourceVal, inheritMethods);
              if ('function' === type) {
                Proto.super = null;
              }
            }
          }
          function inheritBase_(Proto, BaseProto, inheritMethods) {
            for (var key in Proto) {
              if ('constructor' === key || 'template' === key || 'nodes' === key) {
                continue;
              }
              var baseProtoVal = BaseProto[key];
              if (null == baseProtoVal) {
                continue;
              }
              var protoVal = Proto[key];
              if (null == protoVal) {
                // Keep fields in base proto if not overriden
                continue;
              }
              var type = mergeProperty(Proto, key, protoVal, baseProtoVal, inheritMethods);
              if ('function' === type) {
                Proto.super = null;
              }
            }
          }
          function mergeProperty(target, key, targetVal, sourceVal, inheritMethods) {
            var type = typeof sourceVal;
            if ('function' === type) {
              switch (key) {
               case 'renderStart':
               case 'renderEnd':
               case 'emitIn':
               case 'emitOut':
               case 'components':
               case 'nodes':
               case 'template':
               case 'find':
               case 'closest':
               case 'on':
               case 'remove':
               case 'slotState':
               case 'signalState':
               case 'append':
               case 'appendTo':
                // is sealed
                return;

               case 'serializeState':
               case 'deserializeState':
                if (sourceVal !== CompoProto[key]) {
                  target[key] = sourceVal;
                }
                return;
              }
              if ('onRenderStart' === key || 'onRenderEnd' === key) {
                target[key] = wrapAutocallFn(targetVal, sourceVal);
                return;
              }
              inheritMethods[key] = 1;
              return type;
            }
            if ('object' !== type) {
              return null;
            }
            switch (key) {
             case 'slots':
             case 'pipes':
             case 'events':
             case 'attr':
              inheritInternals_(targetVal, sourceVal, key);
              return null;
            }
            defaults_(targetVal, sourceVal);
            return null;
          }
          function inheritInternals_(target, source, name) {
            if (null == target || null == source) {
              return;
            }
            for (var key in source) {
              var sourceVal = source[key];
              var targetVal = target[key];
              if (null == targetVal) {
                target[key] = sourceVal;
                continue;
              }
              if ('pipes' === name) {
                inheritInternals_(target[key], sourceVal, 'pipe');
                continue;
              }
              var type = typeof sourceVal;
              if ('function' === type) {
                var fnAutoCall = false;
                if ('slots' === name || 'events' === name || 'pipe' === name) {
                  fnAutoCall = true;
                }
                var wrapperFn = fnAutoCall ? wrapAutocallFn : wrapInheritedFn;
                target[key] = wrapperFn(target[key], sourceVal);
                continue;
              }
              if ('object' !== type) {
                continue;
              }
              defaults_(target[key], sourceVal);
            }
          }
          function defaults_(target, source) {
            var targetV, sourceV;
            for (var key in source) {
              targetV = target[key];
              sourceV = source[key];
              if (null == targetV) {
                target[key] = sourceV;
                continue;
              }
              if (is_rawObject(targetV) && is_rawObject(sourceV)) {
                defaults_(targetV, sourceV);
                continue;
              }
            }
          }
          function fillProtoHash(proto, hash) {
            if (null == getProtoOf) {
              return proto;
            }
            var keys = Object.getOwnPropertyNames(proto);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (null != hash[key]) {
                continue;
              }
              hash[key] = proto[key];
            }
            var next = getProtoOf(proto);
            if (null == next || next === Object.prototype) {
              return hash;
            }
            return fillProtoHash(next, hash);
          }
          function wrapInheritedFn(outerFn, innerFn) {
            return function() {
              this.super = innerFn;
              var x = fn_apply(outerFn, this, arguments);
              this.super = null;
              return x;
            };
          }
          function wrapAutocallFn(outerFn, innerFn) {
            if (null == outerFn) {
              return innerFn;
            }
            return function() {
              var x = fn_apply(innerFn, this, arguments);
              var y = fn_apply(outerFn, this, arguments);
              return void 0 === y ? x : y;
            };
          }
          function mergeNodes(target, baseTemplate) {
            var targetNodes = null == target ? null : target.template || target.nodes;
            return null == targetNodes || null == baseTemplate ? targetNodes || baseTemplate : mask_merge(baseTemplate, targetNodes, target, {
              extending: true
            });
          }
          function compo_prepairProperties(Proto) {
            for (var key in Proto.attr) {
              Proto.attr[key] = _mask_ensureTmplFn(Proto.attr[key]);
            }
            var slots = Proto.slots;
            for (var key in slots) {
              if ('string' === typeof slots[key]) {
                slots[key] = Proto[slots[key]];
              }
            }
            compo_meta_prepairAttributesHandler(Proto);
            compo_meta_prepairArgumentsHandler(Proto);
          }
        })();
        CompoStatics = {
          create: function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var Base = args.pop();
            return compo_createExt(Base, args);
          },
          createExt: function(Proto, args) {
            return compo_createExt(Proto, args);
          },
          createClass: function() {
            throw Error('@Obsolete: createClass');
          },
          initialize: function(mix, model, ctx, container, parent) {
            if (null == mix) {
              throw Error('Undefined is not a component');
            }
            if (null == container) {
              if (ctx && null != ctx.nodeType) {
                container = ctx;
                ctx = null;
              } else if (model && null != model.nodeType) {
                container = model;
                model = null;
              }
            }
            var node;
            function createNode(compo) {
              node = {
                controller: compo,
                type: Dom.COMPONENT
              };
            }
            if ('string' === typeof mix) {
              if (/^[^\s]+$/.test(mix)) {
                var compo = customTag_get(mix);
                if (null == compo) {
                  throw Error('Component not found: ' + mix);
                }
                createNode(compo);
              } else {
                createNode(compo_createExt({
                  template: mix
                }));
              }
            } else if ('function' === typeof mix) {
              createNode(mix);
            }
            if (null == parent && null != container) {
              parent = Anchor.resolveCompo(container);
            }
            if (null == parent) {
              parent = new Component();
            }
            var dom = renderer_render(node, model, ctx, null, parent), instance = parent.components[parent.components.length - 1];
            if (null != container) {
              container.appendChild(dom);
              CompoSignals.signal.emitIn(instance, 'domInsert');
            }
            return instance;
          },
          find: compo_find,
          findAll: compo_findAll,
          closest: compo_closest,
          children: compo_children,
          child: compo_child,
          dispose: compo_dispose,
          ensureTemplate: compo_ensureTemplate,
          attachDisposer: compo_attachDisposer,
          attach: compo_attach,
          gc: {
            using: function(compo, x) {
              if (null == x.dispose) {
                console.warn('Expects `disposable` instance');
                return x;
              }
              compo_attach(compo, 'dispose', function() {
                x && x.dispose();
                x = null;
              });
            },
            on: function(compo, emitter) {
              var args = [];
              for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
              }
              var fn = emitter.on || emitter.addListener || emitter.addEventListener || emitter.bind;
              var fin = emitter.off || emitter.removeListener || emitter.removeEventListener || emitter.unbind;
              if (null == fn || null === fin) {
                console.warn('Expects `emitter` instance with any of the methods: on, addListener, addEventListener, bind');
                return;
              }
              fn.apply(emitter, args);
              compo_attach(compo, 'dispose', function() {
                emitter && fin.apply(emitter, args);
                emitter = null;
              });
            },
            subscribe: function(compo, observable) {
              var args = [];
              for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
              }
              if (null == observable.subscribe) {
                console.warn('Expects `IObservable` instance with subscribe/unsubscribe methods');
                return;
              }
              var result = observable.apply(observable, args);
              if (null == observable.unsubscribe && (null == result || null == result.dispose)) {
                throw Error('Invalid subscription: don`t know how to unsubscribe');
              }
              compo_attach(compo, 'dispose', function() {
                if (null == observable) {
                  return;
                }
                if (result && result.dispose) {
                  result.dispose();
                  result = null;
                  observable = null;
                  return;
                }
                if (observable.unsubscribe) {
                  observable.unsubscribe(args[0]);
                  observable = null;
                  result = null;
                }
              });
            }
          },
          element: {
            getCompo: function(el) {
              return Anchor.resolveCompo(el, true);
            },
            getModel: function(el) {
              var compo = Anchor.resolveCompo(el, true);
              if (null == compo) {
                return null;
              }
              var model = compo.model;
              while (null == model && null != compo.parent) {
                compo = compo.parent;
                model = compo.model;
              }
              return model;
            }
          },
          config: CompoConfig,
          pipe: Pipes.pipe,
          resource: function(compo) {
            var owner = compo;
            while (null != owner) {
              if (owner.resource) {
                return owner.resource;
              }
              owner = owner.parent;
            }
            return include.instance();
          },
          plugin: function(source) {
            // if DEBUG
            eval(source);
            // endif
                    },
          Dom: {
            addEventListener: dom_addEventListener
          },
          signal: CompoSignals.signal,
          slot: CompoSignals.slot,
          DomLite: DomLite,
          pause: CompoStaticsAsync.pause,
          resume: CompoStaticsAsync.resume,
          await: CompoStaticsAsync.await
        };
      })();
      var deco_slot, deco_slotPrivate, deco_pipe, deco_event, deco_hotkey, deco_attr, deco_refCompo, deco_refElement, deco_refQuery;
      (function() {
        var __spreadArrays = this && this.__spreadArrays || function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
            s += arguments[i].length;
          }
          var r = Array(s), k = 0;
          for (i = 0; i < il; i++) {
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
              r[k] = a[j];
            }
          }
          return r;
        };
        deco_slot = function(mix) {
          return function(target, propertyKey, descriptor) {
            var _a, _b, _c, _d;
            var slots = (_a = target.slots, null !== _a && void 0 !== _a ? _a : target.slots = {});
            var name = 'string' === typeof mix ? mix : null === (_b = mix) || void 0 === _b ? void 0 : _b.name;
            var isPrivate = 'string' !== typeof mix ? (_d = null === (_c = mix) || void 0 === _c ? void 0 : _c.private, 
            null !== _d && void 0 !== _d ? _d : false) : false;
            var viaProperty = null == descriptor;
            var fn = viaProperty ? target[propertyKey] : descriptor.value;
            slots[null !== name && void 0 !== name ? name : propertyKey] = !isPrivate ? fn : function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              fn.call.apply(fn, __spreadArrays([ this ], args));
              return false;
            };
            return descriptor;
          };
        };
        deco_slotPrivate = function(name) {
          return deco_slot({
            name: name,
            private: true
          });
        };
        /** Tip: use constants instead string literals for arguments */        deco_pipe = function(pipeName, signalName) {
          return function(target, propertyKey, descriptor) {
            var _a, _b;
            var pipes = (_a = target.pipes, null !== _a && void 0 !== _a ? _a : target.pipes = {});
            var stream = (_b = pipes[pipeName], null !== _b && void 0 !== _b ? _b : pipes[pipeName] = {});
            var viaProperty = null == descriptor;
            var fn = viaProperty ? target[propertyKey] : descriptor.value;
            stream[null !== name && void 0 !== name ? name : propertyKey] = fn;
            return descriptor;
          };
        };
        /**
				 * @param selector event or delegated event - "click: .some"
				 */        deco_event = function(selector) {
          return function(target, propertyKey, descriptor) {
            var _a;
            var events = (_a = target.events, null !== _a && void 0 !== _a ? _a : target.events = {});
            var viaProperty = null == descriptor;
            var fn = viaProperty ? target[propertyKey] : descriptor.value;
            events[selector] = fn;
            return descriptor;
          };
        };
        /**
				 * @param selector event or delegated event - "click: .some"
				 */        deco_hotkey = function(hotkey) {
          return function(target, propertyKey, descriptor) {
            var _a;
            var hotkeys = (_a = target.hotkeys, null !== _a && void 0 !== _a ? _a : target.hotkeys = {});
            var viaProperty = null == descriptor;
            var fn = viaProperty ? target[propertyKey] : descriptor.value;
            hotkeys[hotkey] = fn;
            return descriptor;
          };
        };
        deco_attr = function(opts) {
          return function(target, propertyKey, descriptor) {
            var _a;
            var attr = ensureMeta(target, 'attributes');
            var name = null === (_a = opts) || void 0 === _a ? void 0 : _a.name;
            if (null == name) {
              name = propertyKey[0] + propertyKey.substring(1).replace(/[A-Z]/g, function(c) {
                return '_' + c.toLowerCase();
              });
            }
            attr[name] = obj_extend(opts, {
              name: propertyKey
            });
          };
        };
        deco_refCompo = function(selector) {
          return function(target, propertyKey, descriptor) {
            ensureRef(target, propertyKey, selector, 'compos');
          };
        };
        deco_refElement = function(selector) {
          return function(target, propertyKey, descriptor) {
            ensureRef(target, propertyKey, selector, 'elements');
          };
        };
        deco_refQuery = function(selector) {
          return function(target, propertyKey, descriptor) {
            ensureRef(target, propertyKey, selector, 'queries');
          };
        };
        function ensureMeta(proto, name) {
          var _a;
          var _b;
          var m = proto.meta;
          if (null == m) {
            m = proto.meta = (_a = {}, _a[name] = {}, _a);
          }
          return _b = m[name], null !== _b && void 0 !== _b ? _b : m[name] = {};
        }
        function ensureRef(proto, key, selector, refName) {
          var _a;
          var refs = ensureMeta(proto, 'refs');
          var ref = (_a = refs[refName], null !== _a && void 0 !== _a ? _a : refs[refName] = {});
          ref[key] = selector;
        }
      })();
      var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function(d, b) {
            d.__proto__ = b;
          } || function(d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) {
                d[p] = b[p];
              }
            }
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      Component = /** @class */ function(_super) {
        __extends(Component, _super);
        function Component() {
          var _this = _super.call(this) || this;
          if (true !== _this.__constructed) {
            _this.__constructed = true;
            compo_prepairProperties(_this);
          }
          if (null != _this.pipes) {
            CompoStatics.pipe.addController(_this);
          }
          if (null != _this.compos) {
            _this.compos = obj_create(_this.compos);
          }
          if (null != _this.attr) {
            _this.attr = obj_create(_this.attr);
          }
          if (null != _this.scope) {
            _this.scope = obj_create(_this.scope);
          }
          return _this;
        }
        Component.create = CompoStatics.create;
        Component.createExt = CompoStatics.createExt;
        Component.createClass = CompoStatics.createClass;
        Component.initialize = CompoStatics.initialize;
        Component.find = CompoStatics.find;
        Component.findAll = CompoStatics.findAll;
        Component.closest = CompoStatics.closest;
        Component.children = CompoStatics.children;
        Component.child = CompoStatics.child;
        Component.dispose = CompoStatics.dispose;
        Component.ensureTemplate = CompoStatics.ensureTemplate;
        Component.attachDisposer = CompoStatics.attachDisposer;
        Component.attach = CompoStatics.attach;
        Component.gc = CompoStatics.gc;
        Component.element = CompoStatics.element;
        Component.config = CompoStatics.config;
        Component.pipe = CompoStatics.pipe;
        Component.resource = CompoStatics.resource;
        Component.plugin = CompoStatics.plugin;
        Component.Dom = CompoStatics.Dom;
        Component.signal = CompoStatics.signal;
        Component.slot = CompoStatics.slot;
        Component.DomLite = CompoStatics.DomLite;
        Component.pause = CompoStatics.pause;
        Component.resume = CompoStatics.resume;
        Component.await = CompoStatics.await;
        Component.deco = {
          pipe: deco_pipe,
          slot: deco_slot,
          slotPrivate: deco_slotPrivate,
          attr: deco_attr,
          event: deco_event,
          hotkey: deco_hotkey,
          refCompo: deco_refCompo,
          refElement: deco_refElement,
          refQuery: deco_refQuery
        };
        return Component;
      }(class_create(CompoProto));
    })();
    (function() {
      Compo = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this instanceof Compo) {
          // used in Class({Base: Compo})
          return;
        }
        var Base = args.pop();
        return compo_createExt(Base, args);
      };
      Compo.prototype = CompoProto;
      obj_extend(Compo, CompoStatics);
    })();
  })();
  var builder_resumeDelegate, builder_buildSVG, builder_build, BuilderData, builder_Ctx;
  (function() {
    var builder_buildFactory, builder_findAndRegisterCompo, builder_setCompoModel, builder_setCompoAttributes, builder_setCompoProps, build_manyFactory, build_nodeFactory, build_compoFactory, build_textNode, decorators_buildFactory, builder_buildDelegate;
    (function() {
      builder_Ctx = class_create(class_Dfr, {
        constructor: function(data) {
          obj_extend(this, data);
        },
        // Is true, if some of the components in a ctx is async
        async: false,
        // List of busy components
        defers: null /*Array*/ ,
        // NodeJS
        // Track components ID
        _id: null,
        // ModelsBuilder for HTML serialization
        _models: null,
        // ModulesBuilder fot HTML serialization
        _modules: null,
        _redirect: null,
        _rewrite: null
      });
      builder_Ctx.clone = function(ctx) {
        var data = {};
        for (var key in ctx) {
          if (void 0 === builder_Ctx.prototype[key]) {
            data[key] = ctx[key];
          }
        }
        return new builder_Ctx(data);
      };
    })();
    (function() {
      BuilderData = {
        id: 1
      };
    })();
    (function() {
      (function() {
        (function() {
          (function() {
            builder_findAndRegisterCompo = function(ctr, name) {
              for (var compo = ctr; null != compo; compo = compo.parent) {
                if (null == compo.handlers) {
                  continue;
                }
                var Ctor = compo.handlers[name];
                if (null == Ctor) {
                  continue;
                }
                customTag_registerScoped(compo, name, Ctor);
                return true;
              }
              return false;
            };
            builder_setCompoModel = function(compo, model, ctx, ctr) {
              var readModel = null != compo.meta && compo.meta.readArguments || null;
              var argsModel = null == readModel ? null : readModel(compo.expression, model, ctx, ctr);
              if (null != compo.model) {
                return obj_extend(compo.model, argsModel);
              }
              return compo.model = argsModel || model;
            };
            builder_setCompoAttributes = function(compo, node, model, ctx, container) {
              var ownAttr = compo.attr;
              var attr = node.attr;
              if (null == attr) {
                attr = {};
              } else {
                attr = obj_create(attr);
                for (var key in attr) {
                  var fn = attr[key];
                  if ('function' === typeof fn) {
                    attr[key] = fn('compo-attr', model, ctx, container, compo, key);
                  }
                }
              }
              compo.attr = attr;
              if (null != compo.meta) {
                if (null != compo.meta.readAttributes) {
                  compo.meta.readAttributes(compo, attr, model, container);
                }
                if (null != compo.meta.readProperties) {
                  compo.meta.readProperties(compo, attr, model, container);
                }
              }
              for (var key in ownAttr) {
                var current = attr[key], val = null;
                if (null == current || 'class' === key) {
                  var x = ownAttr[key];
                  val = is_Function(x) ? x('compo-attr', model, ctx, container, compo, key) : x;
                }
                if ('class' === key) {
                  attr[key] = null == current ? val : current + ' ' + val;
                  continue;
                }
                if (null != current) {
                  continue;
                }
                attr[key] = val;
              }
              return attr;
            };
            builder_setCompoProps = function(compo, node, model, ctx, container) {
              var props = node.props;
              if (null == props) {
                return;
              }
              for (var key in props) {
                var val = props[key];
                var x = is_Function(val) ? val('compo-prop', model, ctx, container, compo, key) : val;
                obj_setProperty(compo, key, x);
              }
            };
          })();
          (function() {
            (function() {
              decorators_buildFactory = function(build) {
                return function decorators_build(decorators, node, model, ctx, el, ctr, els) {
                  var type = Decorator.getDecoType(node);
                  if (null == type) {
                    error_withNode('Unsupported node to decorate', node);
                    return build(node, model, ctx, el, ctr, els);
                  }
                  if ('NODE' === type) {
                    var builder = Decorator.wrapNodeBuilder(decorators, build, model, ctx, ctr);
                    return builder(node, model, ctx, el, ctr, els);
                  }
                  if ('COMPO' === type) {
                    builder = Decorator.wrapCompoBuilder(decorators, build, model, ctx, ctr);
                    return builder(node, model, ctx, el, ctr, els);
                  }
                  if ('METHOD' === type) {
                    Decorator.wrapMethodNode(decorators, node, model, ctx, ctr);
                    return build(node, model, ctx, el, ctr, els);
                  }
                };
              };
            })();
            build_manyFactory = function(build) {
              var decorators_build = decorators_buildFactory(build);
              return function build_many(nodes, model, ctx, el, ctr, els) {
                if (null == nodes) {
                  return;
                }
                var imax = nodes.length;
                for (var i = 0; i < imax; i++) {
                  var x = nodes[i];
                  if (16 === x.type) {
                    var start = i;
                    i = Decorator.goToNode(nodes, i, imax);
                    var decos = nodes.slice(start, i);
                    decorators_build(decos, nodes[i], model, ctx, el, ctr, els);
                    continue;
                  }
                  build(x, model, ctx, el, ctr, els);
                }
              };
            };
          })();
          (function() {
            build_nodeFactory = function(config) {
              var el_create;
              (function(doc, factory) {
                el_create = function(name) {
                  return factory(name, doc);
                };
              })('undefined' === typeof document ? null : document, config.create);
              return function build_node(node, model, ctx, container, ctr, children) {
                var el = el_create(node.tagName);
                if (null == el) {
                  return;
                }
                if (null != children) {
                  children.push(el);
                  var id = ctr.ID;
                  if (null != id) {
                    el.setAttribute('x-compo-id', id);
                  }
                }
                // ++ insert el into container before setting attributes, so that in any
                // custom util parentNode is available. This is for mask.node important
                // http://jsperf.com/setattribute-before-after-dom-insertion/2
                                if (null != container) {
                  container.appendChild(el);
                }
                var attr = node.attr;
                if (null != attr) {
                  el_writeAttributes(el, node, attr, model, ctx, container, ctr);
                }
                var props = node.props;
                if (null != props) {
                  el_writeProps(el, node, props, model, ctx, container, ctr);
                }
                return el;
              };
            };
            var el_writeAttributes;
            var el_writeProps;
            (function() {
              el_writeAttributes = function(el, node, attr, model, ctx, container, ctr) {
                for (var key in attr) {
                  var mix = attr[key], val = is_Function(mix) ? getValByFn('attr', mix, key, model, ctx, el, ctr) : mix;
                  if (null == val) {
                    continue;
                  }
                  /** When not setting empty string as value to option tag, the inner text is used for value*/                  if ('' === val && 'value' !== key) {
                    continue;
                  }
                  var fn = custom_Attributes[key];
                  if (null != fn) {
                    fn(node, val, model, ctx, el, ctr, container);
                  } else {
                    el.setAttribute(key, val);
                  }
                }
              };
              el_writeProps = function(el, node, props, model, ctx, container, ctr) {
                for (var key in props) {
                  // if (key.indexOf('style.') === 0) {
                  // 	key = prepairStyleProperty(el, key)
                  // }
                  var mix = props[key], val = is_Function(mix) ? getValByFn('prop', mix, key, model, ctx, el, ctr) : mix;
                  if (null == val) {
                    continue;
                  }
                  obj_setProperty(el, key, val);
                }
              };
              function getValByFn(type, fn, key, model, ctx, el, ctr) {
                var result = fn(type, model, ctx, el, ctr, key);
                if (null == result) {
                  return null;
                }
                if ('string' === typeof result) {
                  return result;
                }
                if (is_ArrayLike(result)) {
                  if (0 === result.length) {
                    return null;
                  }
                  return result.join('');
                }
                return result;
              }
            })();
          })();
          (function() {
            (function() {
              compo_addChild = function(ctr, compo) {
                compo_addChildren(ctr, compo);
              };
              compo_addChildren = function(ctr) {
                var compos = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  compos[_i - 1] = arguments[_i];
                }
                var arr = ctr.components;
                if (null == arr) {
                  ctr.components = compos;
                  return;
                }
                arr.push.apply(arr, compos);
              };
              compo_renderElements = function(nodes, model, ctx, el, ctr, children) {
                if (null == nodes) {
                  return null;
                }
                var arr = [];
                builder_build(nodes, model, ctx, el, ctr, arr);
                if (is_Array(children)) {
                  children.push.apply(children, arr);
                }
                return arr;
              };
              compo_emitInserted = function(ctr) {
                Component.signal.emitIn(ctr, 'domInsert');
              };
            })();
            build_compoFactory = function(build) {
              return function build_compo(node, model, ctx, container, ctr, children) {
                var Handler, compoName = node.tagName;
                if (null != node.controller) {
                  Handler = node.controller;
                }
                if (null == Handler) {
                  Handler = custom_Tags[compoName];
                }
                if (null == Handler && builder_findAndRegisterCompo(ctr, compoName)) {
                  Handler = custom_Tags[compoName];
                }
                if (null == Handler) {
                  return build_NodeAsCompo(node, model, ctx, container, ctr, children);
                }
                var handler, isStatic = false;
                if ('function' === typeof Handler) {
                  handler = new Handler(node, model, ctx, container, ctr);
                } else {
                  handler = Handler;
                  isStatic = true;
                }
                var fn = isStatic ? build_Static : build_Component;
                return fn(handler, node, model, ctx, container, ctr, children);
              };
              // PRIVATE
                            function build_Component(compo, node, model_, ctx, container, ctr, children) {
                compo.ID = ++BuilderData.id;
                compo.parent = ctr;
                compo.expression = node.expression;
                compo.node = node;
                if (null == compo.compoName) {
                  compo.compoName = node.tagName;
                }
                if (null == compo.nodes) {
                  compo.nodes = node.nodes;
                }
                builder_setCompoAttributes(compo, node, model_, ctx, container);
                builder_setCompoProps(compo, node, model_, ctx, container);
                listeners_emit('compoCreated', compo, model, ctx, container, node);
                var model = builder_setCompoModel(compo, model_, ctx, ctr);
                if (is_Function(compo.renderStart)) {
                  compo.renderStart(model, ctx, container);
                }
                compo_addChild(ctr, compo);
                if (true === compo.async) {
                  var resume = builder_resumeDelegate(compo, model, ctx, container, children, compo.renderEnd);
                  compo.await(resume);
                  return null;
                }
                if (null != compo.tagName) {
                  compo.nodes = {
                    tagName: compo.tagName,
                    attr: compo.attr,
                    nodes: compo.nodes,
                    type: 1
                  };
                }
                if ('function' === typeof compo.render) {
                  compo.render(compo.model, ctx, container, ctr, children);
                  // Overriden render behaviour - do not render subnodes
                                    return null;
                }
                return compo;
              }
              function build_Static(static_, node, model, ctx, container, ctr, children) {
                var elements, compo, clone, Ctor = static_.__Ctor, wasRendered = false;
                if (null != Ctor) {
                  clone = new Ctor(node, ctr);
                } else {
                  clone = static_;
                  for (var key in node) {
                    clone[key] = node[key];
                  }
                  clone.parent = ctr;
                }
                var attr = clone.attr;
                if (null != attr) {
                  for (var key in attr) {
                    if ('function' === typeof attr[key]) {
                      attr[key] = attr[key]('attr', model, ctx, container, ctr, key);
                    }
                  }
                }
                if (is_Function(clone.renderStart)) {
                  clone.renderStart(model, ctx, container, ctr, children);
                }
                clone.ID = ++BuilderData.id;
                compo_addChild(ctr, clone);
                var i = ctr.components.length - 1;
                if (is_Function(clone.render)) {
                  wasRendered = true;
                  elements = clone.render(model, ctx, container, ctr, children);
                  arr_pushMany(children, elements);
                  if (is_Function(clone.renderEnd)) {
                    compo = clone.renderEnd(elements, model, ctx, container, ctr);
                    if (null != compo) {
                      // overriden
                      ctr.components[i] = compo;
                      compo.components = null == clone.components ? ctr.components.splice(i + 1) : clone.components;
                    }
                  }
                }
                return true === wasRendered ? null : clone;
              }
              function build_NodeAsCompo(node, model, ctx, container, ctr, childs) {
                node.ID = ++BuilderData.id;
                compo_addChild(ctr, node);
                if (null == node.model) {
                  node.model = model;
                }
                var els = node.elements = [];
                if (node.render) {
                  node.render(node.model, ctx, container, ctr, els);
                } else {
                  build(node.nodes, node.model, ctx, container, node, els);
                }
                if (null != childs && 0 !== els.length) {
                  arr_pushMany(childs, els);
                }
                return null;
              }
            };
          })();
          (function() {
            build_textNode = function(node, model, ctx, el, ctr) {
              var content = node.content;
              if (is_Function(content)) {
                var result = content('node', model, ctx, el, ctr, null, node);
                if ('string' === typeof result) {
                  append_textNode(el, result);
                  return;
                }
                // result is array with some htmlelements
                                var x, text = '', jmax = result.length, j = 0;
                for (;j < jmax; j++) {
                  x = result[j];
                  if ('object' === typeof x) {
                    // In this casee result[j] should be any HTMLElement
                    if ('' !== text) {
                      append_textNode(el, text);
                      text = '';
                    }
                    if (null == x.nodeType) {
                      text += x.toString();
                      continue;
                    }
                    el.appendChild(x);
                    continue;
                  }
                  text += x;
                }
                if ('' !== text) {
                  append_textNode(el, text);
                }
                return;
              }
              append_textNode(el, content);
            };
            function append_textNode(el, text) {
              el.appendChild(document.createTextNode(text));
            }
          })();
          /**
					 * @param {MaskNode} node
					 * @param {*} model
					 * @param {object} ctx
					 * @param {IAppendChild} container
					 * @param {object} controller
					 * @param {Array} children - @out
					 * @returns {IAppendChild} container
					 * @memberOf mask
					 * @method build
					 */          builder_buildFactory = function(config) {
            var build_node = build_nodeFactory(config);
            var build_many = build_manyFactory(build);
            var build_compo = build_compoFactory(build);
            function build(node, model_, ctx, container_, ctr_, children_) {
              if (null == node) {
                return container;
              }
              var elements, ctr = ctr_, model = model_, children = children_, container = container_, type = node.type;
              if (null == ctr) {
                ctr = new Dom.Component();
              }
              if (null == ctx) {
                ctx = new builder_Ctx();
              }
              if (null == type) {
                // in case if node was added manually, but type was not set
                if (is_ArrayLike(node)) {
                  // Dom.FRAGMENT
                  type = 10;
                } else if (null != node.tagName) {
                  type = 1;
                } else if (null != node.content) {
                  type = 2;
                }
              }
              var tagName = node.tagName;
              if ('else' === tagName) {
                return container;
              }
              if (1 === type && null != custom_Tags[tagName]) {
                // check if custom ctr exists
                type = 4;
              }
              if (1 === type && null != custom_Statements[tagName]) {
                // check if custom statement exists
                type = 15;
              }
              if (null == container && 1 !== type) {
                container = document.createDocumentFragment();
              }
              // Dom.TEXTNODE
                            if (2 === type) {
                build_textNode(node, model, ctx, container, ctr);
                return container;
              }
              // Dom.SET
                            if (10 === type) {
                build_many(node, model, ctx, container, ctr, children);
                return container;
              }
              // Dom.STATEMENT
                            if (15 === type) {
                var Handler = custom_Statements[tagName];
                if (null == Handler) {
                  if (null != custom_Tags[tagName] || builder_findAndRegisterCompo(ctr, tagName)) {
                    // Dom.COMPONENT
                    type = 4;
                  } else {
                    log_error('<mask: statement is undefined>', tagName);
                    return container;
                  }
                }
                if (15 === type) {
                  Handler.render(node, model, ctx, container, ctr, children);
                  return container;
                }
              }
              // Dom.NODE
                            if (1 === type) {
                container = build_node(node, model, ctx, container, ctr, children);
                children = null;
              }
              // Dom.COMPONENT
                            if (4 === type) {
                ctr = build_compo(node, model, ctx, container, ctr, children);
                if (null == ctr) {
                  return container;
                }
                elements = [];
                node = ctr;
                if (ctr.model !== model && null != ctr.model) {
                  model = ctr.model;
                }
              }
              var nodes = node.nodes;
              if (null != nodes) {
                if (null != children && null == elements) {
                  elements = children;
                }
                if (is_ArrayLike(nodes)) {
                  build_many(nodes, model, ctx, container, ctr, elements);
                } else {
                  build(nodes, model, ctx, container, ctr, elements);
                }
              }
              if (4 === type) {
                // use or override custom attr handlers
                // in Compo.handlers.attr object
                // but only on a component, not a tag ctr
                if (null == node.tagName) {
                  var attrFn, val, key, attrHandlers = node.handlers && node.handlers.attr;
                  for (key in node.attr) {
                    val = node.attr[key];
                    if (null == val) {
                      continue;
                    }
                    attrFn = null;
                    if (null != attrHandlers && is_Function(attrHandlers[key])) {
                      attrFn = attrHandlers[key];
                    }
                    if (null == attrFn && null != custom_Attributes[key]) {
                      attrFn = custom_Attributes[key];
                    }
                    if (null != attrFn) {
                      attrFn(node, val, model, ctx, elements[0], ctr);
                    }
                  }
                }
                if (is_Function(node.renderEnd)) {
                  node.renderEnd(elements, model, ctx, container);
                }
              }
              if (null != children && null != elements && children !== elements) {
                arr_pushMany(children, elements);
              }
              return container;
            }
            return build;
          };
        })();
        builder_buildDelegate = function(opts) {
          return builder_buildFactory(opts);
        };
      })();
      builder_build = builder_buildDelegate({
        create: function(name, doc) {
          return doc.createElement(name);
        }
      });
    })();
    (function() {
      builder_resumeDelegate = function(ctr, model, ctx, container, children, finilizeFn) {
        var anchor = document.createComment('');
        container.appendChild(anchor);
        if (null != children) {
          children.push(anchor);
        }
        return function() {
          return _resume(ctr, model, ctx, anchor, children, finilizeFn);
        };
      };
      function _resume(ctr, model, ctx, anchorEl, children, finilize) {
        if (null != ctr.tagName && ctr.tagName !== ctr.compoName) {
          ctr.nodes = {
            tagName: ctr.tagName,
            attr: ctr.attr,
            nodes: ctr.nodes,
            type: 1
          };
        }
        if (null != ctr.model) {
          model = ctr.model;
        }
        var nodes = ctr.nodes, elements = [];
        if (null != nodes) {
          var fragment = document.createDocumentFragment();
          builder_build(nodes, model, ctx, fragment, ctr, elements);
          anchorEl.parentNode.insertBefore(fragment, anchorEl);
        }
        if (null != children && elements.length > 0) {
          var args = [ 0, 1 ].concat(elements);
          var i = coll_indexOf(children, anchorEl);
          if (i > -1) {
            args[0] = i;
            children.splice.apply(children, args);
          }
          var parent = ctr.parent;
          while (null != parent) {
            var arr = parent.$ || parent.elements;
            if (null != arr) {
              i = coll_indexOf(arr, anchorEl);
              if (-1 === i) {
                break;
              }
              args[0] = i;
              arr.splice.apply(arr, args);
            }
            parent = parent.parent;
          }
        }
        // use or override custom attr handlers
        // in Compo.handlers.attr object
        // but only on a component, not a tag ctr
                if (null == ctr.tagName) {
          var attrFn, key, attrHandlers = ctr.handlers && ctr.handlers.attr;
          for (key in ctr.attr) {
            attrFn = null;
            if (attrHandlers && is_Function(attrHandlers[key])) {
              attrFn = attrHandlers[key];
            }
            if (null == attrFn && is_Function(custom_Attributes[key])) {
              attrFn = custom_Attributes[key];
            }
            if (null != attrFn) {
              attrFn(anchorEl, ctr.attr[key], model, ctx, elements[0], ctr);
            }
          }
        }
        if (is_Function(finilize)) {
          finilize.call(ctr, elements, model, ctx, anchorEl.parentNode);
        }
      }
    })();
    (function() {
      builder_buildSVG = builder_buildDelegate({
        create: function(name, doc) {
          return doc.createElementNS(SVG_NS, name);
        }
      });
      var SVG_NS = 'http://www.w3.org/2000/svg';
    })();
  })();
  var __cfg, mask_config;
  (function() {
    /**
		 * Configuration Options
		 * @type {object}
		 * @typedef Configuration
		 */
    __cfg = {
      /**
		     * Relevant for NodeJS only. Disable/Enable compo caching.
		     * @default true
		     */
      allowCache: true,
      /**
		     * Style and Script preprocessors
		     * @type {object}
		     * @memberOf Configuration
		     */
      preprocessor: {
        /**
		         * Transform style before using in `style` tag
		         * @type {function}
		         * @param {string} style
		         * @returns {string}
		         * @memberOf Configuration
		         */
        style: null,
        /**
		         * Transform script before using in `function,script,event,slot` tags
		         * @type {function}
		         * @param {string} source
		         * @returns {string}
		         * @memberOf Configuration
		         */
        script: null
      },
      /**
		     * Base path for modules
		     * @default null
		     * @memberOf Configuration
		     */
      base: null,
      modules: 'default',
      /**
		     * Define custom function for getting files content by path
		     * @param {string} path
		     * @returns {Promise}
		     * @memberOf Configuration
		     */
      getFile: null,
      /**
		     * Define custom function for getting script
		     * @param {string} path
		     * @returns {Promise} Fulfill with exports
		     * @memberOf Configuration
		     */
      getScript: null,
      /**
		     * Define custom function for getting styles
		     * @param {string} path
		     * @returns {Promise} Fulfill with exports
		     * @memberOf Configuration
		     */
      getStyle: null,
      /**
		     * Define custom function for getting jsons
		     * @param {string} path
		     * @returns {Promise} Fulfill with exports
		     * @memberOf Configuration
		     */
      getData: null,
      getJson: null,
      /**
		     * Define custom function to build/combine styles
		     * @param {string} path
		     * @param {object} options
		     * @returns {Promise} Fulfill with {string} content
		     * @memberOf Configuration
		     */
      buildStyle: null,
      /**
		     * Define custom function to build/combine scripts
		     * @param {string} path
		     * @param {object} options
		     * @returns {Promise} Fulfill with {string} content
		     * @memberOf Configuration
		     */
      buildScript: null,
      /**
		     * Define custom function to build/combine jsons
		     * @param {string} path
		     * @param {object} options
		     * @returns {Promise} Fulfill with {string} content
		     * @memberOf Configuration
		     */
      buildData: null
    };
    /**
		 * Get or Set configuration settings
		 * - 1 `(name)`
		 * - 2 `(name, value)`
		 * - 3 `(object)`
		 * @see @{link MaskOptions} for all options
		 * @memberOf mask
		 * @method config
		 */    mask_config = function(a, b, c) {
      var args = arguments, length = args.length;
      if (0 === length) {
        return __cfg;
      }
      if (1 === length) {
        var x = args[0];
        if (is_Object(x)) {
          obj_extend(__cfg, x);
          listeners_emit('config', x);
          return;
        }
        if (is_String(x)) {
          return obj_getProperty(__cfg, x);
        }
      }
      if (2 === length) {
        var prop = args[0];
        if (false === obj_hasProperty(__cfg, prop)) {
          log_warn('Unknown configuration property', prop);
        }
        x = {};
        obj_setProperty(x, prop, args[1]);
        obj_setProperty(__cfg, prop, args[1]);
        listeners_emit('config', x);
        return;
      }
    };
  })();
  var cursor_groupEnd, parser_ObjectLexer, parser_parse, mask_stringify, parser_defineContentTag, parser_parseHtml, parser_ensureTemplateFunction, parser_setInterpolationQuotes;
  (function() {
    var cursor_refEnd, cursor_tokenEnd, cursor_quoteEnd, cursor_skipWhitespace, cursor_skipWhitespaceBack, cursor_goToWhitespace;
    (function() {
      cursor_groupEnd = function(str, i, imax, startCode, endCode) {
        var c, count = 0, start = i;
        for (;i < imax; i++) {
          c = str.charCodeAt(i);
          if (34 === c || 39 === c) {
            // "|'
            i = cursor_quoteEnd(str, i + 1, imax, 34 === c ? '"' : '\'');
            continue;
          }
          if (c === startCode) {
            count++;
            continue;
          }
          if (c === endCode) {
            if (-1 === --count) {
              return i;
            }
          }
        }
        parser_warn('Group was not closed', str, start);
        return imax;
      };
      cursor_refEnd = function(str, i, imax) {
        var c;
        while (i < imax) {
          c = str.charCodeAt(i);
          if (36 === c || 95 === c) {
            // $ _
            i++;
            continue;
          }
          if (48 <= c && c <= 57 || // 0-9
          65 <= c && c <= 90 || // A-Z
          97 <= c && c <= 122) {
            // a-z
            i++;
            continue;
          }
          break;
        }
        return i;
      };
      cursor_tokenEnd = function(str, i, imax) {
        var c;
        while (i < imax) {
          c = str.charCodeAt(i);
          if (36 === c || 95 === c || 58 === c) {
            // $ _ :
            i++;
            continue;
          }
          if (48 <= c && c <= 57 || // 0-9
          65 <= c && c <= 90 || // A-Z
          97 <= c && c <= 122) {
            // a-z
            i++;
            continue;
          }
          break;
        }
        return i;
      };
      cursor_quoteEnd = function(str, i, imax, char_) {
        var start = i;
        while (-1 !== (i = str.indexOf(char_, i))) {
          if (92 /*\*/ !== str.charCodeAt(i - 1)) {
            return i;
          }
          i++;
        }
        parser_warn('Quote was not closed', str, start - 1);
        return imax;
      };
      cursor_skipWhitespace = function(str, i_, imax) {
        for (var i = i_; i < imax; i++) {
          if (str.charCodeAt(i) > 32) {
            return i;
          }
        }
        return i;
      };
      cursor_skipWhitespaceBack = function(str, i) {
        for (;i > 0; i--) {
          if (str.charCodeAt(i) > 32) {
            return i;
          }
        }
        return i;
      };
      cursor_goToWhitespace = function(str, i, imax) {
        for (;i < imax; i++) {
          if (str.charCodeAt(i) < 33) {
            return i;
          }
        }
        return i;
      };
    })();
    var interp_START, interp_code_START, interp_code_OPEN, interp_code_CLOSE, go_tag, go_up, go_attrVal, go_propVal, go_attrHeadVal, state_tag, state_attr, state_prop, state_literal;
    (function() {
      interp_START = '~';
      // ~
      interp_code_START = 126;
      // [
            interp_code_OPEN = 91;
      // ]
            interp_code_CLOSE = 93;
      go_tag = 10;
      go_up = 11;
      go_attrVal = 12;
      go_propVal = 13;
      go_attrHeadVal = 14;
      state_tag = 3;
      state_attr = 4;
      state_prop = 5;
      state_literal = 6;
      parser_setInterpolationQuotes = function(start, end) {
        if (!start || 2 !== start.length) {
          log_error('Interpolation Start must contain 2 Characters');
          return;
        }
        if (!end || 1 !== end.length) {
          log_error('Interpolation End must be of 1 Character');
          return;
        }
        interp_code_START = start.charCodeAt(0);
        interp_code_OPEN = start.charCodeAt(1);
        interp_code_CLOSE = end.charCodeAt(0);
        interp_START = start[0];
        start[1];
        end;
      };
    })();
    var parser_cfg_ContentTags;
    (function() {
      parser_cfg_ContentTags = {
        script: 1,
        style: 1,
        template: 1,
        markdown: 1
      };
      parser_defineContentTag = function(name) {
        parser_cfg_ContentTags[name] = 1;
      };
    })();
    var parser_parseAttr, parser_parseAttrObject;
    (function() {
      parser_parseAttr = function(str, start, end) {
        var key, c, attr = {}, i = start;
        while (i < end) {
          i = cursor_skipWhitespace(str, i, end);
          if (i === end) {
            break;
          }
          start = i;
          for (;i < end; i++) {
            c = str.charCodeAt(i);
            if (61 === c || c < 33) {
              break;
            }
          }
          key = str.substring(start, i);
          i = cursor_skipWhitespace(str, i, end);
          if (i === end) {
            attr[key] = key;
            break;
          }
          if (61 /*=*/ !== str.charCodeAt(i)) {
            attr[key] = key;
            continue;
          }
          i = start = cursor_skipWhitespace(str, i + 1, end);
          c = str.charCodeAt(i);
          if (34 === c || 39 === c) {
            // "|'
            i = cursor_quoteEnd(str, i + 1, end, 39 === c ? '\'' : '"');
            attr[key] = str.substring(start + 1, i);
            i++;
            continue;
          }
          i = cursor_goToWhitespace(str, i, end);
          attr[key] = str.substring(start, i);
        }
        return attr;
      };
      parser_parseAttrObject = function(str, i, imax, attr) {
        var token, index, key, c, state_KEY = 1, state_VAL = 2, state_END = 3, state = state_KEY;
        outer: while (i < imax) {
          i = cursor_skipWhitespace(str, i, imax);
          if (i === imax) {
            break;
          }
          index = i;
          c = str.charCodeAt(i);
          switch (c) {
           case 61 /* = */ :
            i++;
            state = state_VAL;
            continue outer;

           case 123:
           case 59:
           case 62:
           case 47:
            // {;>/
            state = state_END;
            break;

           case 40:
            //()
            i = cursor_groupEnd(str, ++index, imax, 40, 41);
            if (null != key) {
              attr[key] = key;
            }
            key = 'expression';
            token = str.substring(index, i);
            i++;
            state = state_VAL;
            break;

           case 39:
           case 34:
            //'"
            i = cursor_quoteEnd(str, ++index, imax, 39 === c ? '\'' : '"');
            token = str.substring(index, i);
            i++;
            break;

           default:
            i++;
            for (;i < imax; i++) {
              c = str.charCodeAt(i);
              if (c < 33 || 61 === c || 123 === c || 59 === c || 62 === c || 47 === c) {
                // ={;>/
                break;
              }
            }
            token = str.substring(index, i);
            break;
          }
          if (state === state_VAL) {
            attr[key] = token;
            state = state_KEY;
            key = null;
            continue;
          }
          if (null != key) {
            attr[key] = key;
            key = null;
          }
          if (state === state_END) {
            break;
          }
          key = token;
        }
        return i;
      };
    })();
    (function() {
      /**
			 * Parse **Mask** template to the AST tree
			 * @param {string} template - Mask Template
			 * @returns {MaskNode}
			 * @memberOf mask
			 * @method parse
			 */
      parser_parse = function(template, filename) {
        var classNames, token, tokenIndex, key, value, next, c, // charCode
        start, sourceIndex, current = new Dom.Fragment(), fragment = current, state = go_tag, last = state_tag, index = 0, length = template.length;
        fragment.source = template;
        fragment.filename = filename;
        outer: while (true) {
          while (index < length && (c = template.charCodeAt(index)) < 33) {
            index++;
          }
          // COMMENTS
                    if (47 === c) {
            // /
            nextC = template.charCodeAt(index + 1);
            if (47 === nextC) {
              // inline (/)
              index++;
              while (10 !== c && 13 !== c && index < length) {
                // goto newline
                c = template.charCodeAt(++index);
              }
              continue;
            }
            if (42 === nextC) {
              // block (*)
              index = template.indexOf('*/', index + 2) + 2;
              if (1 === index) {
                // if DEBUG
                parser_warn('Block comment has no ending', template, index);
                // endif
                                index = length;
              }
              continue;
            }
          }
          if (last === state_attr) {
            if (null != classNames) {
              current.attr['class'] = parser_ensureTemplateFunction(classNames);
              classNames = null;
            }
            if (null != key) {
              current.attr[key] = key;
              key = null;
              token = null;
            }
          }
          if (null != token) {
            if (state === state_attr) {
              if (null == key) {
                key = token;
              } else {
                value = token;
              }
              if (null != key && null != value) {
                if ('class' !== key) {
                  current.attr[key] = value;
                } else {
                  classNames = null == classNames ? value : classNames + ' ' + value;
                }
                key = null;
                value = null;
              }
            } else if (state === go_propVal) {
              if (null == key || null == token) {
                parser_warn('Unexpected property value state', template, index, c, state);
              }
              if (null == current.props) {
                current.props = {};
              }
              current.props[key] = token;
              state = state_attr;
              last = go_propVal;
              token = null;
              key = null;
              continue;
            } else if (last === state_tag) {
              //next = custom_Tags[token] != null
              //	? new Component(token, current, custom_Tags[token])
              //	: new Node(token, current);
              var parser = custom_Parsers[token];
              if (null != parser) {
                // Parser should return: [ parsedNode, nextIndex, nextState ]
                var tuple = parser(template, index, length, current);
                var node = tuple[0], nextState = tuple[2];
                index = tuple[1];
                state = 0 === nextState ? go_tag : nextState;
                if (null != node) {
                  node.sourceIndex = tokenIndex;
                  var transform = custom_Parsers_Transform[token];
                  if (null != transform) {
                    var x = transform(current, node);
                    if (null != x) {
                      // make the current node single, to exit this and the transformed node on close
                      current.__single = true;
                      current = x;
                    }
                  }
                  current.appendChild(node);
                  if (0 !== nextState) {
                    current = node;
                  } else if (true === current.__single) {
                    do {
                      current = current.parent;
                    } while (null != current && null != current.__single);
                  }
                }
                token = null;
                continue;
              }
              next = new Dom.Node(token, current);
              next.sourceIndex = tokenIndex;
              current.appendChild(next);
              current = next;
              state = state_attr;
            } else if (last === state_literal) {
              next = new Dom.TextNode(token, current);
              next.sourceIndex = sourceIndex;
              current.appendChild(next);
              if (true === current.__single) {
                do {
                  current = current.parent;
                } while (null != current && null != current.__single);
              }
              state = go_tag;
            }
            token = null;
          }
          if (index >= length) {
            if (state === state_attr) {
              if (null != classNames) {
                current.attr['class'] = parser_ensureTemplateFunction(classNames);
              }
              if (null != key) {
                current.attr[key] = key;
              }
            }
            c = null;
            break;
          }
          if (state === go_up) {
            current = current.parent;
            while (null != current && null != current.__single) {
              current = current.parent;
            }
            if (null == current) {
              current = fragment;
              parser_warn('Unexpected tag closing', template, cursor_skipWhitespaceBack(template, index - 1));
            }
            state = go_tag;
          }
          switch (c) {
           case 60 /*<*/ :
            if (state !== go_tag) {
              break;
            }
            tuple = parser_parseHtmlPartial(template, index, true);
            node = tuple[0];
            node.sourceIndex = index;
            index = tuple[1];
            state = go_tag;
            token = null;
            current.appendChild(node);
            if (true === current.__single) {
              do {
                current = current.parent;
              } while (null != current && null != current.__single);
            }
            continue;

           case 123:
            // {
            last = state;
            state = go_tag;
            index++;
            continue;

           case 62:
            // >
            last = state;
            state = go_tag;
            index++;
            current.__single = true;
            continue;

           case 59:
            // ;
            if (null != current.nodes) {
              // skip ; , when node is not a single tag (else goto 125)
              index++;
              continue;
            }

            /* falls through */           case 125:
            // ;}
            if (125 === c && (state === state_tag || state === state_attr)) {
              // single tag was not closed with `;` but closing parent
              index--;
            }
            index++;
            last = state;
            state = go_up;
            continue;

           case 39:
           case 34:
            // '"
            // Literal - could be as textnode or attribute value
            if (state === go_attrVal) {
              state = state_attr;
            } else if (state !== go_propVal) {
              last = state = state_literal;
            }
            index++;
            var isEscaped = false, isUnescapedBlock = false, _char = 39 === c ? '\'' : '"';
            sourceIndex = start = index;
            while ((index = template.indexOf(_char, index)) > -1) {
              if (92 /*'\\'*/ !== template.charCodeAt(index - 1)) {
                break;
              }
              isEscaped = true;
              index++;
            }
            if (-1 === index) {
              parser_warn('Literal has no ending', template, start - 1);
              index = length;
            }
            if (index === start) {
              nextC = template.charCodeAt(index + 1);
              if (124 === nextC || nextC === c) {
                // | (obsolete) or triple quote
                isUnescapedBlock = true;
                start = index + 2;
                index = template.indexOf((124 === nextC ? '|' : _char) + _char + _char, start);
                if (-1 === index) {
                  index = length;
                }
              }
            }
            tokenIndex = start;
            token = template.substring(start, index);
            if (true === isEscaped) {
              token = token.replace(__rgxEscapedChar[_char], _char);
            }
            if (state !== state_attr || 'class' !== key) {
              token = parser_ensureTemplateFunction(token);
            }
            index += isUnescapedBlock ? 3 : 1;
            continue;
          }
          if (state === go_tag) {
            last = state_tag;
            state = state_tag;
            if (46 /* . */ === c || 35 /* # */ === c) {
              tokenIndex = index;
              token = 'div';
              continue;
            }
            if (91 /*[*/ === c) {
              start = index + 1;
              index = cursor_groupEnd(template, start, length, c, 93 /* ] */);
              if (0 === index) {
                parser_warn('Attribute not closed', template, start - 1);
                index = length;
                continue;
              }
              var expr = template.substring(start, index);
              var deco = new Dom.DecoratorNode(expr, current);
              deco.sourceIndex = start;
              current.appendChild(deco);
              index = cursor_skipWhitespace(template, index + 1, length);
              if (index !== length) {
                c = template.charCodeAt(index);
                if (46 === c || 35 === c || 91 === c || c >= 65 && c <= 122 || 36 === c || 95 === c) {
                  // .#[A-z$_
                  last = state = go_tag;
                  continue;
                }
                parser_error('Unexpected char after decorator. Tag is expected', template, index, c, state);
                break outer;
              }
            }
          } else if (state === state_attr) {
            if (46 === c) {
              // .
              index++;
              key = 'class';
              state = go_attrHeadVal;
            } else if (35 === c) {
              // #
              index++;
              key = 'id';
              state = go_attrHeadVal;
            } else if (61 === c) {
              // =;
              index++;
              state = go_attrVal;
              if (last === state_tag && null == key) {
                parser_warn('Unexpected tag assignment', template, index, c, state);
              }
              continue;
            } else if (40 === c) {
              // (
              start = 1 + index;
              index = 1 + cursor_groupEnd(template, start, length, c, 41 /* ) */);
              current.expression = template.substring(start, index - 1);
              current.type = Dom.STATEMENT;
              continue;
            } else if (91 /*[*/ === c) {
              ++index;
              key = token = null;
              state = state_prop;
              continue;
            } else if (null != key) {
              tokenIndex = index;
              token = key;
              continue;
            }
          }
          if (state === go_attrVal || state === go_attrHeadVal) {
            last = state;
            state = state_attr;
          }
          /* TOKEN */          if (state === state_prop) {
            tokenIndex = start = index;
            while (index < length) {
              index = cursor_refEnd(template, index, length);
              if (index === start) {
                parser_error('Invalid char in property', template, index, c, state);
                break outer;
              }
              c = template.charCodeAt(index);
              if (46 /*.*/ === c) {
                start = ++index;
                continue;
              }
              key = template.substring(tokenIndex, index);
              if (c <= 32) {
                index = cursor_skipWhitespace(template, index, length);
                c = template.charCodeAt(index);
              }
              if (93 /*]*/ !== c) {
                parser_error('Property not closed', template, index, c, state);
                break outer;
              }
              c = template.charCodeAt(++index);
              if (c <= 32) {
                index = cursor_skipWhitespace(template, index, length);
                c = template.charCodeAt(index);
              }
              if (61 /*=*/ !== c) {
                parser_error('Property should have assign char', template, index, c, state);
                break outer;
              }
              index++;
              state = go_propVal;
              continue outer;
            }
          }
          var isInterpolated = false;
          start = index;
          while (index < length) {
            c = template.charCodeAt(index);
            if (c === interp_code_START) {
              var nextC = template.charCodeAt(index + 1);
              if (nextC === interp_code_OPEN) {
                isInterpolated = true;
                index = 1 + cursor_groupEnd(template, index + 2, length, interp_code_OPEN, interp_code_CLOSE);
                c = template.charCodeAt(index);
              } else if (nextC >= 65 && nextC <= 122 || 36 === nextC || 95 === nextC) {
                //A-z$_
                isInterpolated = true;
              }
            }
            if (64 === c && 91 === template.charCodeAt(index + 1)) {
              //@[
              index = cursor_groupEnd(template, index + 2, length, 91, 93) + 1;
              c = template.charCodeAt(index);
            }
            // if DEBUG
                        if (39 === c || 34 === c || 47 === c || 60 === c || 44 === c) {
              // '"/<,
              parser_error('Unexpected char', template, index, c, state);
              break outer;
            }
            // endif
                        if (last !== go_attrVal && (46 === c || 35 === c)) {
              // .#
              // break on .# only if parsing attribute head values
              break;
            }
            if (c < 33 || 61 === c || 62 === c || 59 === c || 40 === c || 123 === c || 125 === c) {
              // =>;({}
              break;
            }
            index++;
          }
          token = template.substring(start, index);
          tokenIndex = start;
          if ('' === token) {
            parser_warn('String expected', template, index, c, state);
            break;
          }
          if (true === isInterpolated) {
            if (state === state_tag) {
              parser_warn('Invalid interpolation (in tag name)', template, index, token, state);
              break;
            }
            if (state === state_attr) {
              if ('id' === key || last === go_attrVal) {
                token = parser_ensureTemplateFunction(token);
              } else if ('class' !== key) {
                // interpolate class later
                parser_warn('Invalid interpolation (in attr name)', template, index, token, state);
                break;
              }
            }
          }
        }
        if (c !== c) {
          parser_warn('IndexOverflow', template, index, c, state);
        }
        // if DEBUG
                var parent = current.parent;
        if (null != parent && parent !== fragment && true !== parent.__single && null != current.nodes && 'imports' !== parent.tagName) {
          parser_warn('Tag was not closed: ' + current.tagName, template);
        }
        // endif
                var nodes = fragment.nodes;
        return null != nodes && 1 === nodes.length ? nodes[0] : fragment;
      };
    })();
    (function() {
      var obj_getPropertyEx;
      (function() {
        obj_getPropertyEx = function(path, model, ctx, ctr) {
          if ('.' === path) {
            return model;
          }
          var props = path.split('.');
          var imax = props.length;
          var key = props[0];
          if ('$c' === key || '$' === key) {
            reporter_deprecated('accessor.compo', 'Use `this` instead of `$c` or `$`');
            key = '$';
          }
          if ('$u' === key) {
            reporter_deprecated('accessor.util', 'Use `_` instead of `$u`');
            key = '_';
          }
          if ('this' === key) {
            return getFromCompo_(ctr, props, 1, imax);
          }
          if ('$a' === key) {
            return getProperty_(ctr && ctr.attr, props, 1, imax);
          }
          if ('_' === key) {
            return getProperty_(customUtil_$utils, props, 1, imax);
          }
          if ('$ctx' === key) {
            return getProperty_(ctx, props, 1, imax);
          }
          if ('$scope' === key) {
            return getFromScope_(ctr, props, 1, imax);
          }
          if ('global' === key) {
            return getProperty_(_global, props, 0, imax);
          }
          var x = getProperty_(model, props, 0, imax);
          if (null != x) {
            return x;
          }
          return getFromScope_(ctr, props, 0, imax);
        };
        // = private
        function getProperty_(obj, props, startIndex, imax) {
          var i = startIndex, val = obj;
          while (i < imax && null != val) {
            val = val[props[i]];
            i++;
          }
          return val;
        }
        function getFromScope_(ctr_, props, startIndex, imax) {
          var ctr = ctr_;
          while (null != ctr) {
            var scope = ctr.scope;
            if (null != scope) {
              var x = getProperty_(scope, props, startIndex, imax);
              if (void 0 !== x) {
                return x;
              }
            }
            ctr = ctr.parent;
          }
          return null;
        }
        function getFromCompo_(ctr_, props, startIndex, imax) {
          var ctr = ctr_;
          while (null != ctr) {
            var x = getProperty_(ctr, props, startIndex, imax);
            if (void 0 !== x) {
              return x;
            }
            ctr = ctr.parent;
          }
          return null;
        }
      })();
      parser_ensureTemplateFunction = function(template) {
        var mix = _split(template);
        if (null == mix) {
          return template;
        }
        if ('string' === typeof mix) {
          return mix;
        }
        var array = mix;
        return function(type, model, ctx, element, ctr, name, node) {
          if (void 0 === type) {
            return template;
          }
          return _interpolate(array, type, model, ctx, element, ctr, name, node);
        };
      };
      function _split(template) {
        var index = -1, wasEscaped = false;
        /*
			     * - single char indexOf is much faster then '~[' search
			     * - function is divided in 2 parts: interpolation start lookup + interpolation parse
			     * for better performance
			     */        while (-1 !== (index = template.indexOf(interp_START, index))) {
          var nextC = template.charCodeAt(index + 1);
          var escaped = _char_isEscaped(template, index);
          if (true === escaped) {
            wasEscaped = true;
          }
          if (false === escaped) {
            if (nextC === interp_code_OPEN) {
              break;
            }
            if (_char_isSimpleInterp(nextC)) {
              break;
            }
          }
          index++;
        }
        if (-1 === index) {
          if (true === wasEscaped) {
            return _escape(template);
          }
          return null;
        }
        var end, length = template.length, array = [], lastIndex = 0, i = 0;
        while (true) {
          array[i++] = lastIndex === index ? '' : _slice(template, lastIndex, index);
          var nextI = index + 1;
          nextC = template.charCodeAt(nextI);
          if (nextC === interp_code_OPEN) {
            false;
            end = cursor_groupEnd(template, nextI + 1, length, interp_code_OPEN, interp_code_CLOSE);
            var str = template.substring(index + 2, end);
            array[i++] = new InterpolationModel(null, str);
            lastIndex = index = end + 1;
          } else if (_char_isSimpleInterp(nextC)) {
            true;
            end = _cursor_propertyAccessorEnd(template, nextI, length);
            str = template.substring(index + 1, end);
            array[i++] = new InterpolationModel(str, null);
            lastIndex = index = end;
          } else {
            array[i] += template[nextI];
            lastIndex = nextI;
          }
          while (-1 !== (index = template.indexOf(interp_START, index))) {
            nextC = template.charCodeAt(index + 1);
            escaped = _char_isEscaped(template, index);
            if (true === escaped) {
              wasEscaped = true;
            }
            if (false === escaped) {
              if (nextC === interp_code_OPEN) {
                break;
              }
              if (_char_isSimpleInterp(nextC)) {
                break;
              }
            }
            index++;
          }
          if (-1 === index) {
            break;
          }
        }
        if (lastIndex < length) {
          array[i] = true === wasEscaped ? _slice(template, lastIndex, length) : template.substring(lastIndex);
        }
        return array;
      }
      function _char_isSimpleInterp(c) {
        //A-z$_
        return c >= 65 && c <= 122 || 36 === c || 95 === c;
      }
      function _char_isEscaped(str, i) {
        if (0 === i) {
          return false;
        }
        var c = str.charCodeAt(--i);
        if (92 === c) {
          if (_char_isEscaped(str, c)) {
            return false;
          }
          return true;
        }
        return false;
      }
      function _slice(string, start, end) {
        var str = string.substring(start, end);
        var i = str.indexOf(interp_START);
        if (-1 === i) {
          return str;
        }
        return _escape(str);
      }
      function _escape(str) {
        return str.replace(/\\~/g, '~');
      }
      function InterpolationModel(prop, expr) {
        this.prop = prop;
        this.expr = expr;
      }
      InterpolationModel.prototype.process = function(model, ctx, el, ctr, name, type, node) {
        if (null != this.prop) {
          return obj_getPropertyEx(this.prop, model, ctx, ctr);
        }
        var util, expr = this.expr, index = expr.indexOf(':');
        if (-1 !== index) {
          if (0 === index) {
            expr = expr.substring(index + 1);
          } else {
            var match = rgx_UTIL.exec(expr);
            if (null != match) {
              util = match[1];
              expr = expr.substring(index + 1);
            }
          }
        }
        if (null == util || '' === util) {
          util = 'expression';
        }
        var fn = custom_Utils[util];
        if (null == fn) {
          log_error('Undefined custom util:', util);
          return null;
        }
        return fn(expr, model, ctx, el, ctr, name, type, node);
      };
      /**
			 * If we rendere interpolation in a TextNode, then custom util can return not only string values,
			 * but also any HTMLElement, then TextNode will be splitted and HTMLElements will be inserted within.
			 * So in that case we return array where we hold strings and that HTMLElements.
			 *
			 * If we interpolate the string in a components attribute and we have only one expression,
			 * then return raw value
			 *
			 * If custom utils returns only strings, then String will be returned by this function
			 * @returns {(array|string)}
			 */      function _interpolate(arr, type, model, ctx, el, ctr, name, node) {
        if (('compo-attr' === type || 'compo-prop' === type) && 2 === arr.length && '' === arr[0]) {
          return arr[1].process(model, ctx, el, ctr, name, type);
        }
        var imax = arr.length, i = -1, array = null, string = '', even = true;
        while (++i < imax) {
          if (true === even) {
            if (null == array) {
              string += arr[i];
            } else {
              array.push(arr[i]);
            }
          } else {
            var interp = arr[i], mix = interp.process(model, ctx, el, ctr, name, type, node);
            if (null != mix) {
              if ('object' === typeof mix && null == array) {
                array = [ string ];
              }
              if (null == array) {
                string += mix;
              } else {
                array.push(mix);
              }
            }
          }
          even = !even;
        }
        return null == array ? string : array;
      }
      function _cursor_propertyAccessorEnd(str, i, imax) {
        var c;
        while (i < imax) {
          c = str.charCodeAt(i);
          if (36 === c || 95 === c || 46 === c) {
            // $ _ .
            i++;
            continue;
          }
          if (48 <= c && c <= 57 || // 0-9
          65 <= c && c <= 90 || // A-Z
          97 <= c && c <= 122) {
            // a-z
            i++;
            continue;
          }
          break;
        }
        return i;
      }
      var rgx_UTIL = /^\s*(\w+):/;
    })();
    var parser_parseHtmlPartial;
    (function() {
      var state_closeTag = 21;
      var CDATA = '[CDATA[', DOCTYPE = 'DOCTYPE';
      /**
			 * Parse **Html** template to the AST tree
			 * @param {string} template - Html Template
			 * @returns {MaskNode}
			 * @memberOf mask
			 * @method parseHtml
			 */      parser_parseHtml = function(str) {
        var tripple = parser_parseHtmlPartial(str, 0, false);
        return tripple[0];
      };
      parser_parseHtmlPartial = function(str, index, exitEarly) {
        var token, c, // charCode
        start, current = new Dom.HtmlFragment(), fragment = current, state = go_tag, i = index, imax = str.length;
        outer: while (i <= imax) {
          if (state === state_literal && current === fragment && true === exitEarly) {
            return [ fragment, i, 0 ];
          }
          if (state === state_attr) {
            i = parser_parseAttrObject(str, i, imax, current.attr);
            if (i === imax) {
              break;
            }
            handleNodeAttributes(current);
            switch (char_(str, i)) {
             case 47:
              // /
              current = current.parent;
              i = until_(str, i, imax, 62);
              break;

             case 62:
              // >
              if (1 === SINGLE_TAGS[current.tagName.toLowerCase()]) {
                current = current.parent;
              }
              break;
            }
            i++;
            var tagName = current.tagName;
            if ('mask' === tagName || 1 === parser_cfg_ContentTags[tagName]) {
              var result = _extractContent(str, i, tagName);
              var txt = result[0];
              i = result[1];
              if ('mask' === tagName) {
                current.parent.nodes.pop();
                current = current.parent;
                var mix = parser_parse(txt);
                if (mix.type !== Dom.FRAGMENT) {
                  var maskFrag = new Dom.Fragment();
                  maskFrag.appendChild(mix);
                  mix = maskFrag;
                }
                current.appendChild(mix);
              } else {
                current.appendChild(new Dom.TextNode(result[0]));
                current = current.parent;
              }
            }
            state = state_literal;
            continue outer;
          }
          c = char_(str, i);
          if (60 === c) {
            //<
            c = char_(str, ++i);
            if (33 /*!*/ === c) {
              if (45 === char_(str, i + 1) && 45 === char_(str, i + 2)) {
                //-- COMMENT
                i = str.indexOf('--\x3e', i + 3) + 3;
                if (2 === i) {
                  i = imax;
                }
                state = state_literal;
                continue outer;
              }
              if (str.substring(i + 1, i + 1 + CDATA.length).toUpperCase() === CDATA) {
                // CDATA
                start = i + 1 + CDATA.length;
                i = str.indexOf(']]>', start);
                if (-1 === i) {
                  i = imax;
                }
                current.appendChild(new Dom.TextNode(str.substring(start, i)));
                i += 3;
                state = state_literal;
                continue outer;
              }
              if (str.substring(i + 1, i + 1 + DOCTYPE.length).toUpperCase() === DOCTYPE) {
                // DOCTYPE
                var doctype = new Dom.Node('!' + DOCTYPE, current);
                doctype.attr.html = 'html';
                current.appendChild(doctype);
                i = until_(str, i, imax, 62) + 1;
                state = state_literal;
                continue outer;
              }
            }
            if (36 === c || 95 === c || 58 === c || 43 === c || 47 === c || 65 <= c && c <= 90 || 97 <= c && c <= 122) {
              // $_:+/ A-Z a-z
              if (47 /*/*/ === c) {
                state = state_closeTag;
                i++;
                i = cursor_skipWhitespace(str, i, imax);
              }
              start = i;
              i = cursor_tokenEnd(str, i + 1, imax);
              token = str.substring(start, i);
              if (state === state_closeTag) {
                current = tag_Close(current, token.toLowerCase());
                state = state_literal;
                i = until_(str, i, imax, 62 /*>*/);
                i++;
                continue outer;
              }
              // open tag
                            current = tag_Open(token, current);
              state = state_attr;
              continue outer;
            }
            i--;
          }
          // LITERAL
                    start = i;
          token = '';
          while (i <= imax) {
            c = char_(str, i);
            if (60 /*<*/ === c) {
              // MAYBE NODE
              c = char_(str, i + 1);
              if (36 === c || 95 === c || 58 === c || 43 === c || 47 === c || 33 === c) {
                // $_:+/!
                break;
              }
              if (65 <= c && c <= 90 || // A-Z
              97 <= c && c <= 122) {
                // a-z
                break;
              }
            }
            if (38 /*&*/ === c) {
              // ENTITY
              var Char = null;
              var ent = null;
              ent = unicode_(str, i + 1, imax);
              if (null != ent) {
                Char = unicode_toChar(ent);
              } else {
                ent = entity_(str, i + 1, imax);
                if (null != ent) {
                  Char = entity_toChar(ent);
                }
              }
              if (null != Char) {
                token += str.substring(start, i) + Char;
                i = i + ent.length + 1 /*;*/;
                start = i + 1;
              }
            }
            i++;
          }
          token += str.substring(start, i);
          if ('' !== token) {
            token = parser_ensureTemplateFunction(token);
            current.appendChild(new Dom.TextNode(token, current));
          }
        }
        var nodes = fragment.nodes;
        result = null != nodes && 1 === nodes.length ? nodes[0] : fragment;
        return [ result, imax, 0 ];
      };
      function char_(str, i) {
        return str.charCodeAt(i);
      }
      function until_(str, i, imax, c) {
        for (;i < imax; i++) {
          if (c === char_(str, i)) {
            return i;
          }
        }
        return i;
      }
      function unicode_(str, i, imax) {
        var lim = 7, c = char_(str, i);
        if (35 /*#*/ !== c) {
          return null;
        }
        var start = i + 1;
        while (++i < imax) {
          if (0 === --lim) {
            return null;
          }
          c = char_(str, i);
          if (48 <= c && c <= 57 /*0-9*/) {
            continue;
          }
          if (65 <= c && c <= 70 /*A-F*/) {
            continue;
          }
          if (120 /*x*/ === c) {
            continue;
          }
          if (59 /*;*/ === c) {
            return str.substring(start, i);
          }
          break;
        }
        return null;
      }
      function unicode_toChar(unicode) {
        var num = Number('0' + unicode);
        if (num !== num) {
          parser_warn('Invalid Unicode Char', unicode);
          return '';
        }
        return String.fromCharCode(num);
      }
      function entity_(str, i, imax) {
        var lim = 10, start = i;
        for (;i < imax; i++, lim--) {
          if (0 === lim) {
            return null;
          }
          var c = char_(str, i);
          if (59 /*;*/ === c) {
            break;
          }
          if (48 <= c && c <= 57 || // 0-9
          65 <= c && c <= 90 || // A-Z
          97 <= c && c <= 122) {
            // a-z
            i++;
            continue;
          }
          return null;
        }
        return str.substring(start, i);
      }
      var entity_toChar = function(d) {
        //#if (BROWSER)
        if (null == d) {
          return;
        }
        var i = d.createElement('i');
        return function(ent) {
          i.innerHTML = '&' + ent + ';';
          return i.textContent;
        };
        //#endif
            }('undefined' === typeof document ? null : document);
      var SINGLE_TAGS = {
        area: 1,
        base: 1,
        br: 1,
        col: 1,
        embed: 1,
        hr: 1,
        img: 1,
        input: 1,
        keygen: 1,
        link: 1,
        menuitem: 1,
        meta: 1,
        param: 1,
        source: 1,
        track: 1,
        wbr: 1,
        '!doctype': 1
      };
      var IMPLIES_CLOSE;
      (function() {
        var formTags = {
          input: 1,
          option: 1,
          optgroup: 1,
          select: 1,
          button: 1,
          datalist: 1,
          textarea: 1
        };
        IMPLIES_CLOSE = {
          tr: {
            tr: 1,
            th: 1,
            td: 1
          },
          th: {
            th: 1
          },
          td: {
            thead: 1,
            td: 1
          },
          body: {
            head: 1,
            link: 1,
            script: 1
          },
          li: {
            li: 1
          },
          p: {
            p: 1
          },
          h1: {
            p: 1
          },
          h2: {
            p: 1
          },
          h3: {
            p: 1
          },
          h4: {
            p: 1
          },
          h5: {
            p: 1
          },
          h6: {
            p: 1
          },
          select: formTags,
          input: formTags,
          output: formTags,
          button: formTags,
          datalist: formTags,
          textarea: formTags,
          option: {
            option: 1
          },
          optgroup: {
            optgroup: 1
          }
        };
      })();
      function tag_Close(current, name) {
        if (1 === SINGLE_TAGS[name]) {
          // donothing
          return current;
        }
        var x = current;
        while (null != x) {
          if (null != x.tagName && x.tagName.toLowerCase() === name) {
            break;
          }
          x = x.parent;
        }
        if (null == x) {
          parser_warn('Unmatched closing tag', name);
          return current;
        }
        return x.parent || x;
      }
      function tag_Open(name, current) {
        var node = current;
        var TAGS = IMPLIES_CLOSE[name];
        if (null != TAGS) {
          while (null != node && null != node.tagName && 1 === TAGS[node.tagName.toLowerCase()]) {
            node = node.parent;
          }
        }
        var next = new Dom.Node(name, node);
        node.appendChild(next);
        return next;
      }
      function handleNodeAttributes(node) {
        var key, val, obj = node.attr;
        for (key in obj) {
          val = obj[key];
          if (null != val && val !== key) {
            obj[key] = parser_ensureTemplateFunction(val);
          }
        }
        if (null != obj.expression) {
          node.expression = obj.expression;
          node.type = Dom.STATEMENT;
        }
      }
      // function _appendMany(node, nodes) {
      // 	arr_each(nodes, function(x){
      // 		node.appendChild(x)
      // 	});
      // }
            var _extractContent;
      (function() {
        _extractContent = function(str, i, name) {
          var start = i, end = i;
          var match = rgxGet(name, i).exec(str);
          if (null == match) {
            end = i = str.length;
          } else {
            end = match.index;
            i = end + match[0].length;
          }
          return [ str.substring(start, end), i ];
        };
        var rgx = {};
        var rgxGet = function(name, i) {
          var r = rgx[name];
          if (null == r) {
            r = rgx[name] = new RegExp('<\\s*/' + name + '[^>]*>', 'gi');
          }
          r.lastIndex = i;
          return r;
        };
      })();
    })();
    var parser_parseLiteral;
    (function() {
      parser_parseLiteral = function(str, start, imax) {
        var i = cursor_skipWhitespace(str, start, imax);
        var c = str.charCodeAt(i);
        if (34 !== c && 39 !== c) {
          // "'
          parser_error('A quote is expected', str, i);
          return null;
        }
        var isEscaped = false, isUnescapedBlock = false, _char = 39 === c ? '\'' : '"';
        start = ++i;
        while ((i = str.indexOf(_char, i)) > -1) {
          if (92 /*'\\'*/ !== str.charCodeAt(i - 1)) {
            break;
          }
          isEscaped = true;
          i++;
        }
        if (-1 === i) {
          parser_warn('Literal has no ending', str, start - 1);
          i = imax;
        }
        if (i === start) {
          var nextC = str.charCodeAt(i + 1);
          if (nextC === c) {
            isUnescapedBlock = true;
            start = i + 2;
            i = str.indexOf(_char + _char + _char, start);
            if (-1 === i) {
              i = imax;
            }
          }
        }
        var token = str.substring(start, i);
        if (true === isEscaped) {
          token = token.replace(__rgxEscapedChar[_char], _char);
        }
        i += isUnescapedBlock ? 3 : 1;
        return [ token, i ];
      };
    })();
    var parser_cleanObject;
    (function() {
      parser_cleanObject = function(mix) {
        if (is_Array(mix)) {
          for (var i = 0; i < mix.length; i++) {
            parser_cleanObject(mix[i]);
          }
          return mix;
        }
        delete mix.parent;
        delete mix.__single;
        if (null != mix.nodes) {
          parser_cleanObject(mix.nodes);
        }
        return mix;
      };
    })();
    (function() {
      var _consume;
      (function() {
        _consume = function(tokens, str, index, length, out, isOptional) {
          var index_ = index;
          var token, start, imax = tokens.length, i = 0;
          for (;i < imax; i++) {
            token = tokens[i];
            start = index;
            index = token.consume(str, index, length, out);
            if (index === start) {
              if (true === token.optional) {
                continue;
              }
              if (true === isOptional) {
                return index_;
              }
              // global require is also not optional: throw error
                            var msg = 'Token of type `' + token.name + '`';
              if (token.token) {
                msg += ' Did you mean: `' + token.token + '`?';
              }
              parser_error(msg, str, index);
              return index_;
            }
          }
          return index;
        };
      })();
      var _compile;
      (function() {
        var token_Whitespace, token_Const, token_Var, token_ExtendedVar, token_CustomVar, token_CustomParser, token_String, token_Array, token_Punctuation, token_Group, token_OrGroup;
        (function() {
          token_Whitespace = create('Whitespace', {
            constructor: function(optional) {
              this.optional = optional;
            },
            consume: cursor_skipWhitespace
          });
          // To match the string and continue, otherwise stops current consumer
          // foo
                    token_Const = create('Const', {
            constructor: function(str) {
              this.token = str;
            },
            consume: function(str, i, imax) {
              var end = i + this.token.length;
              str = str.substring(i, end);
              return str === this.token ? end : i;
            }
          });
          // consume string (JS syntax) to the variable
          // $foo
                    token_Var = create('Var', {
            constructor: function(name) {
              this.token = name;
              this.setter = generateSetter(name);
            },
            consume: function(str, i, imax, out) {
              var end = cursor_tokenEnd(str, i, imax);
              if (end === i) {
                return i;
              }
              this.setter(out, str.substring(i, end));
              return end;
            }
          });
          /* consume string to the variable
					 * - by Regexp
					 *     $$foo(\w+)
					 * - rest of the string
					 *     $$foo(*)
					 * - inside a group of chars `()` `[]` `""` `''`, etc
					 *     $$foo(*())
					 */          token_ExtendedVar = create('ExtendedVar', {
            constructor: function(name, rgx) {
              this.token = rgx;
              this.setter = generateSetter(name);
              if (42 === rgx.charCodeAt(0)) {
                // *
                if ('*' === rgx) {
                  this.consume = this.consumeAll;
                  return;
                }
                if (3 === rgx.length) {
                  this.consume = this.consumeGroup;
                  return;
                }
                throw Error('`*` consumer expected group chars to parse');
              }
              this.rgx = new RegExp(rgx, 'g');
            },
            consumeAll: function(str, i, imax, out) {
              this.setter(out, str.substring(i));
              return imax;
            },
            consumeGroup: function(str, i, imax, out) {
              var start = this.token.charCodeAt(1), end = this.token.charCodeAt(2);
              if (str.charCodeAt(i) !== start) {
                return token_Var.prototype.consume.call(this, str, i, imax, out);
              }
              end = cursor_groupEnd(str, ++i, imax, start, end);
              if (end === i) {
                return i;
              }
              this.setter(out, str.substring(i, end));
              return end + 1;
            },
            consume: function(str, i, imax, out) {
              this.rgx.lastIndex = i;
              // @TODO: use sticky
                            var match = this.rgx.exec(str);
              if (null == match || match.index !== i) {
                return i;
              }
              var x = match[0];
              this.setter(out, x);
              return i + x.length;
            }
          });
          // Consume string with custom Stop/Continue Function to the variable
                    token_CustomVar = create('CustomVar', {
            constructor: function(name, consumer) {
              this.fn = Consumers[consumer];
              this.token = name;
              this.setter = generateSetter(name);
            },
            consume: function(str, i, imax, out) {
              var start = i;
              for (;i < imax; i++) {
                if (false === this.fn(str.charCodeAt(i))) {
                  break;
                }
              }
              if (i === start) {
                return i;
              }
              this.setter(out, str.substring(start, i));
              return i;
            }
          });
          var Consumers = {
            accessor: function(c) {
              if (true === Consumers.token(c)) {
                return true;
              }
              if (58 === c || 46 === c) {
                // : .
                return true;
              }
              return false;
            },
            token: function(c) {
              if (36 === c || 95 === c) {
                // $ _
                return true;
              }
              if (48 <= c && c <= 57 || // 0-9
              65 <= c && c <= 90 || // A-Z
              97 <= c && c <= 122) {
                // a-z
                return true;
              }
              return false;
            }
          };
          // Consume string with custom Stop/Continue Function to the variable
                    token_CustomParser = create('CustomParser', {
            constructor: function(name, param) {
              return new Parsers[name](param);
            }
          });
          var Parsers = {
            flags: class_create({
              name: 'Flags',
              token: '',
              // Index Map { key: Array<Min,Max> }
              flags: null,
              optional: true,
              constructor: function(param, isOptional) {
                this.optional = isOptional;
                this.flags = {};
                var parts = param.replace(/\s+/g, '').split(';'), imax = parts.length, i = -1;
                while (++i < imax) {
                  var flag = parts[i], index = flag.indexOf(':'), name = flag.substring(0, index), opts = flag.substring(index + 1);
                  var token = '|' + opts + '|';
                  var l = this.token.length;
                  this.flags[name] = [ l, l + token.length ];
                  this.token += token;
                }
              },
              consume: function(str, i_, imax, out) {
                var hasFlag = false;
                var i = i_;
                while (i < imax) {
                  i = cursor_skipWhitespace(str, i, imax);
                  var end = cursor_tokenEnd(str, i, imax);
                  if (end === i) {
                    break;
                  }
                  var token = str.substring(i, end);
                  var idx = this.token.indexOf('|' + token + '|') + 1;
                  if (0 === idx) {
                    break;
                  }
                  for (var key in this.flags) {
                    var range = this.flags[key];
                    var min = range[0];
                    if (min > idx) {
                      continue;
                    }
                    var max = range[1];
                    if (max < idx) {
                      continue;
                    }
                    out[key] = token;
                    hasFlag = true;
                    break;
                  }
                  i = end;
                }
                return hasFlag ? i : i_;
              }
            })
          };
          token_String = create('String', {
            constructor: function(tokens) {
              this.tokens = tokens;
            },
            consume: function(str, i, imax, out) {
              var c = str.charCodeAt(i);
              if (34 !== c && 39 !== c) {
                return i;
              }
              var end = cursor_quoteEnd(str, i + 1, imax, 34 === c ? '"' : '\'');
              if (1 === this.tokens.length) {
                var $var = this.tokens[0];
                out[$var.token] = str.substring(i + 1, end);
              } else {
                throw Error('Not implemented');
              }
              return ++end;
            }
          });
          token_Array = create('Array', {
            constructor: function(name, tokens, delim, optional) {
              this.token = name;
              this.delim = delim;
              this.tokens = tokens;
              this.optional = optional;
            },
            consume: function(str, i, imax, out) {
              var obj, end, arr;
              while (true) {
                obj = {};
                end = _consume(this.tokens, str, i, imax, obj, this.optional);
                if (i === end) {
                  if (null == arr) {
                    return i;
                  }
                  throw Error('Next item expected');
                }
                if (null == arr) {
                  arr = [];
                }
                arr.push(obj);
                i = end;
                end = this.delim.consume(str, i, imax);
                if (i === end) {
                  break;
                }
                i = end;
              }
              out[this.token] = arr;
              return i;
            }
          });
          token_Punctuation = create('Punc', {
            constructor: function(str) {
              this.before = new token_Whitespace(true);
              this.delim = new token_Const(str);
              this.after = new token_Whitespace(true);
              this.token = str;
            },
            consume: function(str, i, imax) {
              var start = this.before.consume(str, i, imax);
              var end = this.delim.consume(str, start, imax);
              if (start === end) {
                return i;
              }
              return this.after.consume(str, end, imax);
            }
          });
          token_Group = create('Group', {
            constructor: function(tokens, optional) {
              this.optional = optional;
              this.tokens = tokens;
            },
            consume: function(str, i, imax, out) {
              var start = cursor_skipWhitespace(str, i, imax);
              var end = _consume(this.tokens, str, start, imax, out, this.optional);
              return start === end ? i : end;
            }
          });
          token_OrGroup = create('OrGroup', {
            constructor: function(groups) {
              this.groups = groups, this.length = groups.length;
            },
            consume: function(str, i, imax, out) {
              var start = i, j = 0;
              for (;j < this.length; j++) {
                i = this.groups[j].consume(str, i, imax, out);
                if (i !== start) {
                  return i;
                }
              }
              return i;
            }
          });
          function generateSetter(name) {
            return new Function('obj', 'val', 'obj.' + name + '= val;');
          }
          function create(name, Proto) {
            var Ctor = Proto.constructor;
            Proto.name = name;
            Proto.optional = false;
            Proto.token = null;
            Ctor.prototype = Proto;
            return Ctor;
          }
        })();
        _compile = function(str, i, imax) {
          if (void 0 === i) {
            i = 0;
            imax = str.length;
          }
          var c, optional, conditional, start, tokens = [];
          outer: for (;i < imax; i++) {
            start = i;
            c = str.charCodeAt(i);
            optional = conditional = false;
            if (63 === c /* ? */) {
              optional = true;
              start = ++i;
              c = str.charCodeAt(i);
            }
            if (124 === c /* | */) {
              conditional = true;
              start = ++i;
              c = str.charCodeAt(i);
            }
            switch (c) {
             case 32 /* */ :
              tokens.push(new token_Whitespace(optional, i));
              continue;

             case 34:
             case 39 /*'"*/ :
              i = cursor_quoteEnd(str, i + 1, imax, 34 === c ? '"' : '\'');
              tokens.push(new token_String(_compile(str, start + 1, i)));
              continue;

             case 36 /*$*/ :
              start = ++i;
              var isExtended = false;
              if (c === str.charCodeAt(i)) {
                isExtended = true;
                start = ++i;
              }
              i = cursor_tokenEnd(str, i, imax);
              var name = str.substring(start, i);
              if (false === optional && false === isExtended) {
                tokens.push(new token_Var(name));
                i--;
                continue;
              }
              c = str.charCodeAt(i);
              if (91 /*[*/ === c) {
                i = compileArray(name, tokens, str, i, imax, optional);
                continue;
              }
              if (40 /*(*/ === c) {
                i = compileExtendedVar(name, tokens, str, i, imax);
                continue;
              }
              if (60 /*<*/ === c) {
                i = compileCustomVar(name, tokens, str, i, imax);
                continue;
              }
              if (123 /*{*/ === c) {
                i = compileCustomParser(name, tokens, str, i, imax);
                continue;
              }
              throw_('Unexpected extended type');
              continue;

             case 40 /*(*/ :
              if (true === optional || true === conditional) {
                i = compileGroup(optional, conditional, tokens, str, i, imax);
                continue;
              }

              /* fall through */             case 44 /*,*/ :
             case 41 /*)*/ :
             case 91 /*[*/ :
             case 93 /*]*/ :
             case 123 /*{*/ :
             case 125 /*}*/ :
              tokens.push(new token_Punctuation(String.fromCharCode(c)));
              continue;
            }
            while (i < imax) {
              c = str.charCodeAt(++i);
              if (c > 32 && 34 !== c && 39 !== c && 36 !== c && 44 !== c && 63 !== c && i !== imax) {
                continue;
              }
              tokens.push(new token_Const(str.substring(start, i)));
              --i;
              continue outer;
            }
          }
          var x, jmax = tokens.length, j = -1, orGroup = jmax > 1;
          while (true === orGroup && ++j < jmax) {
            x = tokens[j];
            if (x instanceof token_Group === false || true !== x.optional) {
              orGroup = false;
            }
          }
          if (0) {
            tokens = [ new token_OrGroup(tokens) ];
          }
          return tokens;
        };
        function compileArray(name, tokens, str, i, imax, optional) {
          var start = ++i;
          i = cursor_groupEnd(str, i, imax, 91, 93);
          var innerTokens = _compile(str, start, i);
          i++;
          if (40 /*(*/ !== str.charCodeAt(i)) {
            throw_('Punctuation group expected');
          }
          start = ++i;
          i = cursor_groupEnd(str, i, imax, 40, 41);
          var delimiter = str.substring(start, i);
          tokens.push(new token_Array(name, innerTokens, new token_Punctuation(delimiter), optional));
          return i;
        }
        function compileExtendedVar(name, tokens, str, i, imax) {
          var start = ++i;
          i = cursor_groupEnd(str, i, imax, 40, 41);
          tokens.push(new token_ExtendedVar(name, str.substring(start, i)));
          return i;
        }
        function compileCustomVar(name, tokens, str, i, imax) {
          var start = ++i;
          i = cursor_tokenEnd(str, i, imax);
          tokens.push(new token_CustomVar(name, str.substring(start, i)));
          return i;
        }
        function compileCustomParser(name, tokens, str, i, imax) {
          var start = ++i;
          i = cursor_groupEnd(str, i, imax, 123, 125);
          tokens.push(new token_CustomParser(name, str.substring(start, i)));
          return i;
        }
        function compileGroup(optional, conditional, tokens, str, i, imax) {
          var start = ++i;
          var Ctor = conditional ? token_OrGroup : token_Group;
          i = cursor_groupEnd(str, start, imax, 40, 41);
          tokens.push(new Ctor(_compile(str, start, i), optional));
          return i;
        }
        function throw_(msg) {
          throw Error('Lexer pattern: ' + msg);
        }
      })();
      parser_ObjectLexer = function(pattern, a, b, c, d, f) {
        if (1 === arguments.length && 'string' === typeof pattern) {
          return ObjectLexer_single(pattern);
        }
        return ObjectLexer_sequance(Array.prototype.slice.call(arguments));
      };
      function ObjectLexer_single(pattern) {
        var tokens = _compile(pattern);
        return function(str, i, imax, out, optional) {
          return _consume(tokens, str, i, imax, out, optional);
        };
      }
      var ObjectLexer_sequance;
      (function() {
        ObjectLexer_sequance = function ObjectLexer_sequance(args) {
          var jmax = args.length, j = -1;
          while (++j < jmax) {
            args[j] = __createConsumer(args[j]);
          }
          return function(str, i_, imax, out, optional) {
            var j = -1, i = i_;
            while (++j < jmax) {
              var start = i, x = args[j];
              i = __consume(x, str, i, imax, out, optional || x.optional);
              if (i === start && true !== x.optional) {
                return start;
              }
            }
            return i;
          };
        };
        function __consume(x, str, i, imax, out, optional) {
          switch (x.type) {
           case 'single':
            return x.consumer(str, i, imax, out, optional);

           case 'any':
            return __consumeOptionals(x.consumer, str, i, imax, out, optional);

           default:
            throw Error('Unknown sequence consumer type: ' + x.type);
          }
        }
        function __consumeOptionals(arr, str, i, imax, out, optional) {
          var start = i, jmax = arr.length, j = -1;
          while (++j < jmax) {
            i = arr[j](str, i, imax, out, true);
            if (start !== i) {
              return i;
            }
          }
          if (true !== optional) {
            // notify
            arr[0](str, start, imax, out, optional);
          }
          return start;
        }
        function __createConsumer(mix) {
          if ('string' === typeof mix) {
            return {
              type: 'single',
              optional: '?' === mix[0],
              consumer: ObjectLexer_single(mix)
            };
          }
          // else Array<string>
                    var i = mix.length;
          while (--i > -1) {
            mix[i] = ObjectLexer_single(mix[i]);
          }
          return {
            type: 'any',
            consumer: mix,
            optional: false
          };
        }
      })();
    })();
    (function() {
      var defaultOptions = {
        minify: true,
        indent: 4,
        indentChar: ' '
      };
      /**
			 * Serialize Mask AST to the Mask string (@analog to `JSON.stringify`)
			 * @param {MaskNode} node - MaskNode
			 * @param {(object|number)} [opts] - Indent count option or an object with options
			 * @param {number} [opts.indent=0] - Indent count, `0` for minimization
			 * @param {bool} [opts.minify=true]
			 * @param {bool} [opts.minimizeAttributes=true] - Remove quotes when possible
			 * @returns {string}
			 * @memberOf mask
			 * @method stringify
			 */      mask_stringify = function(input, opts) {
        if (null == input) {
          return '';
        }
        if ('string' === typeof input) {
          input = parser_parse(input);
        }
        if (null == opts) {
          opts = obj_create(defaultOptions);
        } else if ('number' === typeof opts) {
          var indent = opts;
          opts = obj_create(defaultOptions);
          opts.indent = indent;
          opts.minify = 0 === indent;
        } else {
          opts = obj_extendDefaults(opts, defaultOptions);
          if (opts.indent > 0) {
            opts.minify = false;
          }
          if (true === opts.minify) {
            opts.indent = 0;
          }
        }
        return new Stream(input, opts).toString();
      };
      (function(attr) {
        var str = '';
        for (var key in attr) {
          if (0 !== str.length) {
            str += ' ';
          }
          str += key;
          var x = getString(attr[key]);
          if (x !== key) {
            str += '=' + wrapString(x);
          }
        }
        return str;
      });
      var Stream = class_create({
        string: '',
        indent: 0,
        indentStr: '',
        minify: false,
        opts: null,
        ast: null,
        constructor: function(ast, opts) {
          this.opts = opts;
          this.ast = ast;
          this.minify = opts.minify;
          this.indentStr = doindent(opts.indent, opts.indentChar);
        },
        toString: function() {
          this.process(this.ast, this);
          return this.string;
        },
        process: function(mix) {
          if (mix.type === Dom.FRAGMENT) {
            if ('html' === mix.syntax) {
              // indent current
              this.write('');
              new HtmlStreamWriter(this).process(mix.nodes);
              return;
            }
            mix = mix.nodes;
          }
          if (is_ArrayLike(mix)) {
            var imax = mix.length, i = -1;
            while (++i < imax) {
              if (0 !== i) {
                this.newline();
              }
              this.processNode(mix[i]);
            }
            return;
          }
          this.processNode(mix);
        },
        processNode: function(node) {
          var stream = this;
          if (is_Function(node.stringify)) {
            var str = node.stringify(stream);
            if (null != str) {
              stream.write(str);
            }
            return;
          }
          if (is_String(node.content)) {
            stream.write(wrapString(node.content));
            return;
          }
          if (is_Function(node.content)) {
            stream.write(wrapString(node.content()));
            return;
          }
          if (node.type === Dom.FRAGMENT) {
            this.process(node);
            return;
          }
          this.processHead(node);
          if (isEmpty(node)) {
            stream.print(';');
            return;
          }
          if (isSingle(node)) {
            stream.openBlock('>');
            stream.processNode(getSingle(node));
            stream.closeBlock(null);
            return;
          }
          stream.openBlock('{');
          stream.process(node.nodes);
          stream.closeBlock('}');
        },
        processHead: function(node) {
          var id, cls, stream = this, str = '';
          var attr = node.attr;
          if (null != attr) {
            id = getString(attr['id']);
            cls = getString(attr['class']);
            if (null != id && -1 !== id.indexOf(' ')) {
              id = null;
            }
            if (null != id) {
              str += '#' + id;
            }
            if (null != cls) {
              str += format_Classes(cls);
            }
            for (var key in attr) {
              if ('id' === key && null != id) {
                continue;
              }
              if ('class' === key && null != cls) {
                continue;
              }
              var val = attr[key];
              if (null == val) {
                continue;
              }
              str += ' ' + key;
              if (val === key) {
                continue;
              }
              if (is_Function(val)) {
                val = val();
              }
              if (is_String(val)) {
                if (false === stream.minify || '' === val || /[^\w_$\-\.]/.test(val)) {
                  val = wrapString(val);
                }
              }
              str += '=' + val;
            }
          }
          var props = node.props;
          if (null != props) {
            for (var key in props) {
              val = props[key];
              if (null == val) {
                continue;
              }
              str += ' [' + key;
              if (is_Function(val)) {
                val = val();
              }
              if (is_String(val)) {
                if (false === stream.minify || /[^\w_$\-\.]/.test(val)) {
                  val = wrapString(val);
                }
              }
              str += '] = ' + val;
            }
          }
          if (false === isTagNameOptional(node, id, cls)) {
            str = node.tagName + str;
          }
          var expr = node.expression;
          if (null != expr) {
            if ('function' === typeof expr) {
              expr = expr();
            }
            if (false === stream.minify) {
              str += ' ';
            }
            str += '(' + expr + ')';
          }
          if (false === this.minify) {
            str = doindent(this.indent, this.indentStr) + str;
          }
          stream.print(str);
        },
        newline: function() {
          this.format('\n');
        },
        openBlock: function(c) {
          this.indent++;
          if (false === this.minify) {
            this.string += ' ' + c + '\n';
            return;
          }
          this.string += c;
        },
        closeBlock: function(c) {
          this.indent--;
          if (null != c) {
            this.newline();
            this.write(c);
          }
        },
        write: function(str) {
          if (true === this.minify) {
            this.string += str;
            return;
          }
          var prfx = doindent(this.indent, this.indentStr);
          this.string += str.replace(/^/gm, prfx);
        },
        print: function(str) {
          this.string += str;
        },
        format: function(str) {
          if (false === this.minify) {
            this.string += str;
          }
        },
        printArgs: function(args) {
          if (null == args || 0 === args.length) {
            return;
          }
          var imax = args.length, i = -1;
          while (++i < imax) {
            if (i > 0) {
              this.print(',');
              this.format(' ');
            }
            var arg = args[i];
            this.print(arg.prop);
            if (null != arg.type) {
              this.print(':');
              this.format(' ');
              this.print(arg.type);
            }
          }
        }
      });
      var HtmlStreamWriter = class_create({
        stream: null,
        constructor: function(stream) {
          this.stream = stream;
        },
        process: function(mix) {
          if (mix.type === Dom.FRAGMENT) {
            if ('html' !== mix.syntax) {
              var count = 0, p = mix;
              while (null != p) {
                if (p.type !== Dom.FRAGMENT) {
                  count++;
                }
                p = p.parent;
              }
              var stream = this.stream;
              stream.indent++;
              stream.print('<mask>\n');
              stream.indent += count;
              stream.process(mix);
              stream.print('\n');
              stream.indent--;
              stream.write('</mask>');
              stream.indent -= count;
              return;
            }
            mix = mix.nodes;
          }
          if (is_ArrayLike(mix)) {
            var imax = mix.length, i = -1;
            while (++i < imax) {
              this.processNode(mix[i]);
            }
            return;
          }
          this.processNode(mix);
        },
        processNode: function(node) {
          var stream = this.stream;
          if (is_Function(node.stringify)) {
            var str = node.stringify(stream);
            if (null != str) {
              stream.print('<mask>');
              stream.write(str);
              stream.print('</mask>');
            }
            return;
          }
          if (is_String(node.content)) {
            stream.print(node.content);
            return;
          }
          if (is_Function(node.content)) {
            stream.print(node.content());
            return;
          }
          if (node.type === Dom.FRAGMENT) {
            this.process(node);
            return;
          }
          stream.print('<' + node.tagName);
          this.processAttr(node);
          if (isEmpty(node)) {
            if (html_isVoid(node)) {
              stream.print('>');
              return;
            }
            if (html_isSemiVoid(node)) {
              stream.print('/>');
              return;
            }
            stream.print('></' + node.tagName + '>');
            return;
          }
          stream.print('>');
          this.process(node.nodes);
          stream.print('</' + node.tagName + '>');
        },
        processAttr: function(node) {
          var stream = this.stream, str = '';
          var attr = node.attr;
          if (null != attr) {
            for (var key in attr) {
              var val = attr[key];
              if (null == val) {
                continue;
              }
              str += ' ' + key;
              if (val === key) {
                continue;
              }
              if (is_Function(val)) {
                val = val();
              }
              if (is_String(val)) {
                if (false === stream.minify || /[^\w_$\-\.]/.test(val)) {
                  val = wrapString(val);
                }
              }
              str += '=' + val;
            }
          }
          var expr = node.expression;
          if (null != expr) {
            if ('function' === typeof expr) {
              expr = expr();
            }
            str += ' expression=' + wrapString(expr);
          }
          if ('' === str) {
            return;
          }
          stream.print(str);
        }
      });
      function doindent(count, c) {
        var output = '';
        while (count--) {
          output += c;
        }
        return output;
      }
      function isEmpty(node) {
        return null == node.nodes || is_ArrayLike(node.nodes) && 0 === node.nodes.length;
      }
      function isSingle(node) {
        var arr = node.nodes;
        if (null == arr) {
          return true;
        }
        var isArray = 'number' === typeof arr.length;
        if (isArray && arr.length > 1) {
          return false;
        }
        var x = isArray ? arr[0] : arr;
        return null == x.stringify && x.type !== Dom.FRAGMENT;
      }
      function isTagNameOptional(node, id, cls) {
        if (null == id && null == cls) {
          return false;
        }
        var tagName = node.tagName;
        if ('div' === tagName) {
          return true;
        }
        return false;
      }
      function getSingle(node) {
        if (is_ArrayLike(node.nodes)) {
          return node.nodes[0];
        }
        return node.nodes;
      }
      function wrapString(str) {
        if (-1 === str.indexOf('\'')) {
          return '\'' + str + '\'';
        }
        if (-1 === str.indexOf('"')) {
          return '"' + str + '"';
        }
        return '"' + str.replace(/"/g, '\\"') + '"';
      }
      function getString(mix) {
        return null == mix ? null : is_Function(mix) ? mix() : mix;
      }
      function format_Classes(cls) {
        if (-1 === cls.indexOf('[')) {
          return raw(cls);
        }
        var str = '', imax = cls.length, i = -1;
        while (++i < imax) {
          var start = i = cursor_skipWhitespace(cls, i, imax);
          for (;i < imax; i++) {
            var c = cls.charCodeAt(i);
            if (91 === c) {
              i = cursor_groupEnd(cls, i + 1, imax, 91 /*[*/ , 93 /*]*/);
            }
            if (cls.charCodeAt(i) < 33) {
              break;
            }
          }
          str += '.' + cls.substring(start, i);
        }
        return str;
      }
      function raw(str) {
        return '.' + str.trim().replace(/\s+/g, '.');
      }
      var html_isVoid, html_isSemiVoid;
      (function() {
        var _void = /^(!doctype)$/i, _semiVoid = /^(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
        html_isVoid = function(node) {
          return _void.test(node.tagName);
        };
        html_isSemiVoid = function(node) {
          return _semiVoid.test(node.tagName);
        };
      })();
    })();
    (function() {
      ({
        ensure: function(mix, ctx) {
          if ('string' !== typeof mix) {
            return mix;
          }
          if (_Object_hasOwnProp.call(_cache, mix)) {
            /* if Object doesnt contains property that check is faster
			            then "!=null" http://jsperf.com/not-in-vs-null/2 */
            return _cache[mix];
          }
          return _cache[mix] = parser_parse(mix, ctx.filename);
        }
      });
      var _cache = {};
    })();
    (function() {
      var Style;
      (function() {
        Style = {
          transform: function(body, attr, parent) {
            if (null != attr.self) {
              var style = parent.attr.style;
              parent.attr.style = parser_ensureTemplateFunction((style || '') + body);
              return null;
            }
            return body;
          }
        };
      })();
      var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function(d, b) {
            d.__proto__ = b;
          } || function(d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) {
                d[p] = b[p];
              }
            }
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      custom_Parsers['style'] = createParser('style', Style.transform);
      custom_Parsers['script'] = createParser('script');
      var ContentNode = /** @class */ function(_super) {
        __extends(ContentNode, _super);
        function ContentNode() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.content = null;
          _this.id = null;
          return _this;
        }
        ContentNode.prototype.stringify = function(stream) {
          stream.processHead(this);
          var body = this.content;
          if (null == body) {
            stream.print(';');
            return;
          }
          if (is_Function(body)) {
            body = body();
          }
          stream.openBlock('{');
          stream.print(body);
          stream.closeBlock('}');
          return;
        };
        return ContentNode;
      }(Dom.Node);
      var COUNTER = 0;
      var PRFX = '_cm_';
      function createParser(name, transform) {
        return function(str, i, imax, parent) {
          var end, attr, hasBody, body, c, start = i;
          while (i < imax) {
            c = str.charCodeAt(i);
            if (123 === c || 59 === c || 62 === c) {
              //{;>
              break;
            }
            i++;
          }
          attr = parser_parseAttr(str, start, i);
          for (var key in attr) {
            attr[key] = parser_ensureTemplateFunction(attr[key]);
          }
          if (62 === c) {
            var nextI = cursor_skipWhitespace(str, i + 1, imax);
            var nextC = str.charCodeAt(nextI);
            if (34 !== nextC && 39 !== nextC) {
              // "'
              var node_1 = new Dom.Node(name, parent);
              node_1.attr = attr;
              // `>` handle single without literal as generic mask node
                            return [ node_1, i, go_tag ];
            }
          }
          end = i;
          hasBody = 123 === c || 62 === c;
          if (hasBody) {
            i++;
            if (123 === c) {
              end = cursor_groupEnd(str, i, imax, 123, 125);
 //{}
                            body = str.substring(i, end);
            }
            if (62 === c) {
              var tuple = parser_parseLiteral(str, i, imax);
              if (null == tuple) {
                return null;
              }
              end = tuple[1];
              body = tuple[0];
              // move cursor one back to be consistance with the group
                            end -= 1;
            }
            if (null != transform) {
              body = transform(body, attr, parent);
              if (null == body) {
                return [ null, end + 1 ];
              }
            }
            body = preprocess(name, body);
            if ('script' !== name) {
              body = parser_ensureTemplateFunction(body);
            }
          }
          var node = new ContentNode(name, parent);
          node.content = body;
          node.attr = attr;
          node.id = PRFX + ++COUNTER;
          return [ node, end + 1, 0 ];
        };
      }
      function preprocess(name, body) {
        var fn = __cfg.preprocessor[name];
        if (null == fn) {
          return body;
        }
        var result = fn(body);
        if (null == result) {
          log_error('Preprocessor must return a string');
          return body;
        }
        return result;
      }
    })();
    (function() {
      (function() {
        createParser('define');
        createParser('let');
        function createParser(tagName) {
          custom_Parsers[tagName] = function(str, i, imax, parent) {
            var node = new DefineNode(tagName, parent);
            var end = lex_(str, i, imax, node);
            return [ node, end, go_tag ];
          };
        }
        var lex_ = parser_ObjectLexer('$name', '? ?(($$arguments[$$name<token>?(? :? $$type<accessor>)](,)))?(as $$as(*()))?(extends $$extends[$$compo<accessor>](,))', '{');
        var DefineNode = class_create(Dom.Node, {
          as: null,
          name: null,
          extends: null,
          arguments: null,
          stringify: function(stream) {
            var extends_ = this['extends'], args_ = this['arguments'], as_ = this['as'], str = '';
            if (null != args_ && 0 !== args_.length) {
              str += ' (';
              str += toCommaSeperated(args_, get_arg);
              str += ')';
            }
            if (null != as_ && 0 !== as_.length) {
              str += ' as (' + as_ + ')';
            }
            if (null != extends_ && 0 !== extends_.length) {
              str += ' extends ';
              str += toCommaSeperated(extends_, get_compo);
            }
            var head = this.tagName + ' ' + this.name + str;
            stream.write(head);
            stream.openBlock('{');
            stream.process(this.nodes);
            stream.closeBlock('}');
          }
        });
        function toCommaSeperated(arr, getter) {
          var imax = arr.length, i = -1, str = '';
          while (++i < imax) {
            str += getter(arr[i]);
            if (i < imax - 1) {
              str += ', ';
            }
          }
          return str;
        }
        function get_compo(x) {
          return x.compo;
        }
        function get_arg(x) {
          var arg = x.name;
          if (null != x.type) {
            arg += ': ' + x.type;
          }
          return arg;
        }
      })();
    })();
    (function() {
      var IMPORT = 'import';
      var IMPORTS = 'imports';
      custom_Parsers[IMPORT] = function(str, i, imax, parent) {
        var obj = {
          exports: null,
          alias: null,
          path: null,
          namespace: null,
          async: null,
          link: null,
          mode: null,
          moduleType: null,
          contentType: null,
          attr: null
        };
        var end = lex_(str, i, imax, obj);
        return [ new ImportNode(parent, obj), end, 0 ];
      };
      custom_Parsers_Transform[IMPORT] = function(current) {
        if (current.tagName === IMPORTS) {
          return null;
        }
        var imports = new ImportsNode('imports', current);
        current.appendChild(imports);
        return imports;
      };
      var default_LINK = 'static', default_MODE = 'both';
      var lex_ = parser_ObjectLexer('?($$async(async|sync) )', [ '"$path"', 'from |("$path"$$namespace<accessor>)', '* as $alias from |("$path"$$namespace<accessor>)', '$$exports[$name?(as $alias)](,) from |("$path"$$namespace<accessor>)' ], '?(is $$flags{link:dynamic|static;contentType:mask|script|style|json|text;mode:client|server|both})', '?(as $moduleType)', '?(($$attr[$key? =? "$value"]( )))');
      var ImportsNode = class_create(Dom.Node, {
        stringify: function(stream) {
          stream.process(this.nodes);
        }
      });
      var ImportNode = class_create({
        type: Dom.COMPONENT,
        tagName: IMPORT,
        contentType: null,
        moduleType: null,
        namespace: null,
        exports: null,
        alias: null,
        async: null,
        path: null,
        link: null,
        mode: null,
        constructor: function(parent, obj) {
          this.path = obj.path;
          this.alias = obj.alias;
          this.async = obj.async;
          this.exports = obj.exports;
          this.namespace = obj.namespace;
          this.moduleType = obj.moduleType;
          this.contentType = obj.contentType;
          this.attr = null == obj.attr ? null : this.toObject(obj.attr);
          this.link = obj.link || default_LINK;
          this.mode = obj.mode || default_MODE;
          this.parent = parent;
        },
        stringify: function() {
          var from = ' from ', importStr = IMPORT, type = this.contentType, link = this.link, mode = this.mode;
          if (null != this.path) {
            from += '\'' + this.path + '\'';
          }
          if (null != this.namespace) {
            from += this.namespace;
          }
          if (null != type || link !== default_LINK || mode !== default_MODE) {
            from += ' is';
            if (null != type) {
              from += ' ' + type;
            }
            if (link !== default_LINK) {
              from += ' ' + link;
            }
            if (mode !== default_MODE) {
              from += ' ' + mode;
            }
          }
          if (null != this.moduleType) {
            from += ' as ' + this.moduleType;
          }
          if (null != this.async) {
            importStr += ' ' + this.async;
          }
          if (null != this.attr) {
            var initAttr = '(', attr = initAttr;
            for (var key in this.attr) {
              if (attr !== initAttr) {
                attr += ' ';
              }
              attr += key + '=\'' + this.attr[key] + '\'';
            }
            attr += ')';
            from += ' ' + attr;
          }
          from += ';';
          if (null != this.alias) {
            return importStr + ' * as ' + this.alias + from;
          }
          if (null != this.exports) {
            var x, arr = this.exports, str = '', imax = arr.length, i = -1;
            while (++i < imax) {
              x = arr[i];
              str += x.name;
              if (x.alias) {
                str += ' as ' + x.alias;
              }
              if (i !== imax - 1) {
                str += ', ';
              }
            }
            return importStr + ' ' + str + from;
          }
          return importStr + from;
        },
        toObject: function(arr) {
          var obj = {}, i = arr.length;
          while (--i > -1) {
            obj[arr[i].key] = arr[i].value;
          }
          return obj;
        }
      });
    })();
    (function() {
      custom_Parsers['var'] = function(str, index, length, parent) {
        var start, c, node = new VarNode('var', parent);
        var key, go_varName = 1, go_assign = 2, go_value = 3, go_next = 4, state = go_varName;
        while (true) {
          if (index < length && (c = str.charCodeAt(index)) < 33) {
            index++;
            continue;
          }
          if (state === go_varName) {
            start = index;
            index = cursor_refEnd(str, index, length);
            key = str.substring(start, index);
            state = go_assign;
            continue;
          }
          if (state === go_assign) {
            if (61 !== c) {
              // =
              parser_error('Assignment expected', str, index, c, 'var');
              return [ node, index ];
            }
            state = go_value;
            index++;
            continue;
          }
          if (state === go_value) {
            start = index;
            index++;
            switch (c) {
             case 123:
             case 91:
              // { [
              index = cursor_groupEnd(str, index, length, c, c + 2);
              break;

             case 39:
             case 34:
              // ' "
              index = cursor_quoteEnd(str, index, length, 39 === c ? '\'' : '"');
              break;

             default:
              while (index < length) {
                c = str.charCodeAt(index);
                if (91 === c || 40 === c) {
                  // [ (
                  index = cursor_groupEnd(str, index + 1, length, c, 91 === c ? 93 : 41);
                  continue;
                }
                if (44 === c || 59 === c) {
                  //, ;
                  break;
                }
                index++;
              }
              index--;
              break;
            }
            index++;
            node.attr[key] = str.substring(start, index);
            state = go_next;
            continue;
          }
          if (state === go_next) {
            if (44 === c) {
              // ,
              state = go_varName;
              index++;
              continue;
            }
            break;
          }
        }
        return [ node, index, 0 ];
      };
      var VarNode = class_create(Dom.Node, {
        stringify: function() {
          var attr = this.attr;
          var str = 'var ';
          for (var key in attr) {
            if ('var ' !== str) {
              str += ',';
            }
            str += key + '=' + attr[key];
          }
          return str + ';';
        },
        getObject: function(model, ctx, ctr) {
          var key, obj = {}, attr = this.attr;
          for (key in attr) {
            obj[key] = expression_eval(attr[key], model, ctx, ctr);
          }
          return obj;
        }
      });
    })();
  })();
  var renderer_render, renderer_renderAsync, renderer_clearCache;
  (function() {
    /**
		 * Render the mask template to document fragment or single html node
		 * @param {(string|MaskDom)} template - Mask string template or Mask Ast to render from.
		 * @param {*} [model] - Model Object.
		 * @param {Object} [ctx] - Context can store any additional information, that custom handler may need
		 * @param {IAppendChild} [container]  - Container Html Node where template is rendered into
		 * @param {Object} [controller] - Component that should own this template
		 * @returns {(IAppendChild|Node|DocumentFragment)} container
		 * @memberOf mask
		 */
    renderer_render = function(mix, model, ctx, container, controller) {
      if (null == ctx || ctx.constructor !== builder_Ctx) {
        ctx = new builder_Ctx(ctx);
      }
      var template = mix;
      if ('string' === typeof mix) {
        if (_Object_hasOwnProp.call(__templates, mix)) {
          /* if Object doesnt contains property that check is faster
		                then "!=null" http://jsperf.com/not-in-vs-null/2 */
          template = __templates[mix];
        } else {
          template = __templates[mix] = parser_parse(mix, ctx.filename);
        }
      }
      return builder_build(template, model, ctx, container, controller);
    }
    /**
		 * Same to `mask.render` but returns the promise, which is resolved when all async components
		 * are resolved, or is in resolved state, when all components are synchronous.
		 * For the parameters doc @see {@link mask.render}
		 * @returns {Promise} Fullfills with (`IAppendChild|Node|DocumentFragment`, `Component`)
		 * @memberOf mask
		 */;
    renderer_renderAsync = function(template, model, ctx, container, ctr) {
      if (null == ctx || ctx.constructor !== builder_Ctx) {
        ctx = new builder_Ctx(ctx);
      }
      if (null == ctr) {
        ctr = new Component();
      }
      var dom = renderer_render(template, model, ctx, container, ctr), dfr = new class_Dfr();
      if (true === ctx.async) {
        ctx.done(function() {
          dfr.resolve(dom, ctr);
        });
      } else {
        dfr.resolve(dom, ctr);
      }
      return dfr;
    };
    renderer_clearCache = function(key) {
      if (0 === arguments.length) {
        __templates = {};
        return;
      }
      delete __templates[key];
    };
    var __templates = {};
  })();
  var jMask;
  (function() {
    var _mask_render, _mask_ensureTmplFn, jmask_filter, jmask_find, jmask_clone, jmask_deepest, jmask_getText, selector_parse, selector_match, selector_getNextKey, arr_eachAny, arr_unique;
    var Proto;
    (function() {
      (function() {
        (function() {
          arr_eachAny = function(mix, fn) {
            if (false === is_ArrayLike(mix)) {
              fn(mix);
              return;
            }
            var imax = mix.length, i = -1;
            while (++i < imax) {
              fn(mix[i], i);
            }
          };
          arr_unique = function(array) {
            hasDuplicate_ = false;
            array.sort(sort);
            if (false === hasDuplicate_) {
              return array;
            }
            var duplicates = [], i = 0, j = 0, imax = array.length - 1;
            while (i < imax) {
              if (array[i++] === array[i]) {
                duplicates[j++] = i;
              }
            }
            while (j--) {
              array.splice(duplicates[j], 1);
            }
            return array;
          };
          var hasDuplicate_ = false;
          function sort(a, b) {
            if (a === b) {
              hasDuplicate_ = true;
              return 0;
            }
            return 1;
          }
        })();
        (function() {
          selector_parse = function(selector, type, direction) {
            if (null == selector) {
              log_error('selector is null for the type', type);
            }
            var _type = typeof selector;
            if ('object' === _type || 'function' === _type) {
              return selector;
            }
            var nextKey, _key, _prop, _selector;
            var c, end, matcher, root, current, eq, slicer, index = 0, length = selector.length;
            if ('up' === direction) {
              nextKey = sel_key_UP;
            } else {
              nextKey = type === Dom.SET ? sel_key_MASK : sel_key_COMPOS;
            }
            while (index < length) {
              c = selector.charCodeAt(index);
              if (c < 33) {
                index++;
                continue;
              }
              if (62 /* > */ === c) {
                if (null == matcher) {
                  root = matcher = {
                    selector: '__scope__',
                    nextKey: nextKey,
                    filters: null,
                    next: {
                      type: 'children',
                      matcher: null
                    }
                  };
                } else {
                  matcher.next = {
                    type: 'children',
                    matcher: null
                  };
                }
                current = matcher;
                matcher = null;
                index++;
                continue;
              }
              end = selector_moveToBreak(selector, index + 1, length);
              if (46 /*.*/ === c) {
                _key = 'class';
                _prop = sel_key_ATTR;
                _selector = sel_hasClassDelegate(selector.substring(index + 1, end));
              } else if (35 /*#*/ === c) {
                _key = 'id';
                _prop = sel_key_ATTR;
                _selector = selector.substring(index + 1, end);
              } else if (91 /*[*/ === c) {
                eq = selector.indexOf('=', index);
                //if DEBUG
                                -1 === eq && console.error('Attribute Selector: should contain "="');
                // endif
                                _prop = sel_key_ATTR;
                _key = selector.substring(index + 1, eq);
                //slice out quotes if any
                                c = selector.charCodeAt(eq + 1);
                slicer = 34 === c || 39 === c ? 2 : 1;
                _selector = selector.substring(eq + slicer, end - slicer + 1);
                // increment, as cursor is on closed ']'
                                end++;
              } else if (58 /*:*/ === c && 58 === selector.charCodeAt(index + 1)) {
                index += 2;
                var name, expr, start = index;
                do {
                  c = selector.charCodeAt(index);
                } while (c >= 97 /*a*/ && c <= 122 /*z*/ && ++index < length);
                name = selector.substring(start, index);
                if (40 /*(*/ === c) {
                  start = ++index;
                  do {
                    c = selector.charCodeAt(index);
                  } while (41 /*)*/ !== c && ++index < length);
                  expr = selector.substring(start, index);
                  index++;
                }
                var pseudo = PseudoSelectors(name, expr);
                if (null == matcher) {
                  matcher = {
                    selector: '*',
                    nextKey: nextKey
                  };
                }
                if (null == root) {
                  root = matcher;
                }
                if (null == matcher.filters) {
                  matcher.filters = [];
                }
                matcher.filters.push(pseudo);
                continue;
              } else {
                if (null != matcher) {
                  matcher.next = {
                    type: 'any',
                    matcher: null
                  };
                  current = matcher;
                  matcher = null;
                }
                _prop = null;
                _key = type === Dom.SET ? 'tagName' : 'compoName';
                _selector = selector.substring(index, end);
              }
              index = end;
              if (null == matcher) {
                matcher = {
                  key: _key,
                  prop: _prop,
                  selector: _selector,
                  nextKey: nextKey,
                  filters: null
                };
                if (null == root) {
                  root = matcher;
                }
                if (null != current) {
                  current.next.matcher = matcher;
                }
                continue;
              }
              if (null == matcher.filters) {
                matcher.filters = [];
              }
              matcher.filters.push({
                key: _key,
                selector: _selector,
                prop: _prop
              });
            }
            if (current && current.next) {
              current.next.matcher = matcher;
            }
            return root;
          };
          selector_match = function(node, selector, type) {
            if ('string' === typeof selector) {
              if (null == type) {
                type = Dom[node.compoName ? 'CONTROLLER' : 'SET'];
              }
              selector = selector_parse(selector, type);
            }
            if ('function' === typeof selector) {
              return selector(node);
            }
            var obj = selector.prop ? node[selector.prop] : node, matched = false;
            if (null == obj) {
              return false;
            }
            if ('*' === selector.selector) {
              matched = true;
            } else if ('function' === typeof selector.selector) {
              matched = selector.selector(obj[selector.key]);
            } else if (null != selector.selector.test) {
              if (selector.selector.test(obj[selector.key])) {
                matched = true;
              }
            } else if (obj[selector.key] === selector.selector) {
              matched = true;
            }
            if (true === matched && null != selector.filters) {
              for (var x, i = 0, imax = selector.filters.length; i < imax; i++) {
                x = selector.filters[i];
                if ('function' === typeof x) {
                  matched = x(node, type);
                  if (false === matched) {
                    return false;
                  }
                  continue;
                }
                if (false === selector_match(node, x, type)) {
                  return false;
                }
              }
            }
            return matched;
          };
          selector_getNextKey = function(set) {
            return set.type === Dom.SET ? sel_key_MASK : sel_key_COMPOS;
          }
          // ==== private
          ;
          var sel_key_UP = 'parent', sel_key_MASK = 'nodes', sel_key_COMPOS = 'components', sel_key_ATTR = 'attr';
          function sel_hasClassDelegate(matchClass) {
            return function(className) {
              return sel_hasClass(className, matchClass);
            };
          }
          // [perf] http://jsperf.com/match-classname-indexof-vs-regexp/2
                    function sel_hasClass(className, matchClass, index) {
            if ('string' !== typeof className) {
              return false;
            }
            if (null == index) {
              index = 0;
            }
            index = className.indexOf(matchClass, index);
            if (-1 === index) {
              return false;
            }
            if (index > 0 && className.charCodeAt(index - 1) > 32) {
              return sel_hasClass(className, matchClass, index + 1);
            }
            var class_Length = className.length, match_Length = matchClass.length;
            if (index < class_Length - match_Length && className.charCodeAt(index + match_Length) > 32) {
              return sel_hasClass(className, matchClass, index + 1);
            }
            return true;
          }
          function selector_moveToBreak(selector, index, length) {
            var c, isInQuote = false, isEscaped = false;
            while (index < length) {
              c = selector.charCodeAt(index);
              if (34 === c || 39 === c) {
                // '"
                isInQuote = !isInQuote;
              }
              if (92 === c) {
                // [\]
                isEscaped = !isEscaped;
              }
              if (46 === c || 35 === c || 91 === c || 93 === c || 62 === c || c < 33) {
                // .#[]>
                if (true !== isInQuote && true !== isEscaped) {
                  break;
                }
              }
              index++;
            }
            return index;
          }
          var PseudoSelectors;
          (function() {
            PseudoSelectors = function(name, expr) {
              var fn = Fns[name];
              if (void 0 !== fn) {
                return fn;
              }
              var worker = Workers[name];
              if (void 0 !== worker) {
                return worker(expr);
              }
              throw new Error('Uknown pseudo selector:' + name);
            };
            var Fns = {
              text: function(node) {
                return node.type === Dom.TEXTNODE;
              },
              node: function(node) {
                return node.type === Dom.NODE;
              }
            };
            var Workers = {
              not: function(expr) {
                return function(node, type) {
                  return !selector_match(node, expr, type);
                };
              }
            };
          })();
        })();
        jmask_filter = function(mix, matcher) {
          if (null == matcher) {
            return mix;
          }
          var result = [];
          arr_eachAny(mix, function(node, i) {
            if (selector_match(node, matcher)) {
              result.push(node);
            }
          });
          return result;
        };
        /**
				 * - mix (Node | Array[Node])
				 */        jmask_find = function(mix, matcher, output, deep) {
          if (null == mix) {
            return output;
          }
          if (null == output) {
            output = [];
          }
          if (null == deep) {
            // is root and matchling like `> div` (childs only)
            if ('__scope__' === matcher.selector) {
              deep = false;
              matcher = matcher.next.matcher;
            } else {
              deep = true;
            }
          }
          arr_eachAny(mix, function(node) {
            if (false === selector_match(node, matcher)) {
              if (null == matcher.next && false !== deep) {
                jmask_find(node[matcher.nextKey], matcher, output, deep);
              }
              return;
            }
            if (null == matcher.next) {
              output.push(node);
              if (true === deep) {
                jmask_find(node[matcher.nextKey], matcher, output, deep);
              }
              return;
            }
            var next = matcher.next;
            deep = 'children' !== next.type;
            jmask_find(node[matcher.nextKey], next.matcher, output, deep);
          });
          return output;
        };
        jmask_clone = function(node, parent) {
          var clone = obj_create(node);
          var attr = node.attr;
          if (null != attr) {
            clone.attr = obj_create(attr);
          }
          var nodes = node.nodes;
          if (null != nodes) {
            if (false === is_ArrayLike(nodes)) {
              clone.nodes = [ jmask_clone(nodes, clone) ];
            } else {
              clone.nodes = [];
              var imax = nodes.length, i = 0;
              for (;i < imax; i++) {
                clone.nodes[i] = jmask_clone(nodes[i], clone);
              }
            }
          }
          return clone;
        };
        jmask_deepest = function(node) {
          var prev, current = node;
          while (null != current) {
            prev = current;
            current = current.nodes && current.nodes[0];
          }
          return prev;
        };
        jmask_getText = function(node, model, ctx, controller) {
          if (Dom.TEXTNODE === node.type) {
            if (is_Function(node.content)) {
              return node.content('node', model, ctx, null, controller);
            }
            return node.content;
          }
          var output = '';
          if (null != node.nodes) {
            for (var x, i = 0, imax = node.nodes.length; i < imax; i++) {
              x = node.nodes[i];
              output += jmask_getText(x, model, ctx, controller);
            }
          }
          return output;
        };
      })();
      (function() {
        _mask_render = renderer_render;
        var _mask_ensureTmplFnOrig = parser_ensureTemplateFunction;
        _mask_ensureTmplFn = function(value) {
          if ('string' !== typeof value) {
            return value;
          }
          return _mask_ensureTmplFnOrig(value);
        };
      })();
      Proto = {
        type: Dom.SET,
        length: 0,
        components: null,
        add: function(mix) {
          var i, length;
          if ('string' === typeof mix) {
            mix = parser_parse(mix);
          }
          if (is_ArrayLike(mix)) {
            for (i = 0, length = mix.length; i < length; i++) {
              this.add(mix[i]);
            }
            return this;
          }
          if ('function' === typeof mix && null != mix.prototype.type) {
            // assume this is a controller
            mix = {
              controller: mix,
              type: Dom.COMPONENT
            };
          }
          var type = mix.type;
          if (type === Dom.FRAGMENT) {
            var nodes = mix.nodes;
            for (i = 0, length = nodes.length; i < length; ) {
              this[this.length++] = nodes[i++];
            }
            return this;
          }
          if (type === Dom.CONTROLLER) {
            if (null != mix.nodes && mix.nodes.length) {
              for (i = mix.nodes.length; 0 !== i; ) {
                // set controller as parent, as parent is mask dom node
                mix.nodes[--i].parent = mix;
              }
            }
            if (null != mix.$) {
              this.type = Dom.CONTROLLER;
            }
          }
          this[this.length++] = mix;
          return this;
        },
        toArray: function() {
          return _Array_slice.call(this);
        },
        /**
			     *	render([model, cntx, container]) -> HTMLNode
			     * - model (Object)
			     * - cntx (Object)
			     * - container (Object)
			     * - returns (HTMLNode)
			     *
			     **/
        render: function(model, ctx, el, ctr) {
          this.components = [];
          if (1 === this.length) {
            return _mask_render(this[0], model, ctx, el, ctr || this);
          }
          if (null == el) {
            el = document.createDocumentFragment();
          }
          for (var i = 0, length = this.length; i < length; i++) {
            _mask_render(this[i], model, ctx, el, ctr || this);
          }
          return el;
        },
        prevObject: null,
        end: function() {
          return this.prevObject || this;
        },
        pushStack: function(nodes) {
          var next;
          next = jMask(nodes);
          next.prevObject = this;
          return next;
        },
        controllers: function() {
          if (null == this.components) {
            console.warn('Set was not rendered');
          }
          return this.pushStack(this.components || []);
        },
        mask: function(template) {
          if (0 !== arguments.length) {
            return this.empty().append(template);
          }
          return mask_stringify(this);
        },
        text: function(mix, ctx, ctr) {
          if ('string' === typeof mix && 1 === arguments.length) {
            var node = [ new Dom.TextNode(mix) ];
            for (var i = 0, imax = this.length; i < imax; i++) {
              this[i].nodes = node;
            }
            return this;
          }
          var str = '';
          for (i = 0, imax = this.length; i < imax; i++) {
            str += jmask_getText(this[i], mix, ctx, ctr);
          }
          return str;
        }
      };
      arr_each([ 'append', 'prepend' ], function(method) {
        Proto[method] = function(mix) {
          var arr, node, $mix = jMask(mix), i = 0, length = this.length;
          for (;i < length; i++) {
            node = this[i];
            // we create each iteration a new array to prevent collisions in future manipulations
                        arr = $mix.toArray();
            for (var j = 0, jmax = arr.length; j < jmax; j++) {
              arr[j].parent = node;
            }
            if (null == node.nodes) {
              node.nodes = arr;
              continue;
            }
            node.nodes = 'append' === method ? node.nodes.concat(arr) : arr.concat(node.nodes);
          }
          return this;
        };
      });
      arr_each([ 'appendTo' ], function(method) {
        Proto[method] = function(mix, model, cntx, ctr) {
          if (null == ctr) {
            ctr = this;
          }
          if (null != mix.nodeType && 'function' === typeof mix.appendChild) {
            mix.appendChild(this.render(model, cntx, null, ctr));
            Component.signal.emitIn(ctr, 'domInsert');
            return this;
          }
          jMask(mix).append(this);
          return this;
        };
      });
    })();
    var ManipAttr;
    (function() {
      ManipAttr = {
        removeAttr: function(key) {
          return coll_each(this, function(node) {
            node.attr[key] = null;
          });
        },
        attr: function(mix, val) {
          if (1 === arguments.length && is_String(mix)) {
            return 0 !== this.length ? this[0].attr[mix] : null;
          }
          function asString(node, key, val) {
            node.attr[key] = _mask_ensureTmplFn(val);
          }
          function asObject(node, obj) {
            for (var key in obj) {
              asString(node, key, obj[key]);
            }
          }
          var fn = is_String(mix) ? asString : asObject;
          return coll_each(this, function(node) {
            fn(node, mix, val);
          });
        },
        prop: function(key, val) {
          if (1 === arguments.length) {
            return 0 !== this.length ? this[0][key] : this[0].attr[key];
          }
          return coll_each(this, function(node) {
            node[key] = val;
          });
        },
        removeProp: function(key) {
          return coll_each(this, function(node) {
            node.attr[key] = null;
            node[key] = null;
          });
        },
        tag: function(name) {
          if (0 === arguments.length) {
            return this[0] && this[0].tagName;
          }
          return coll_each(this, function(node) {
            node.tagName = name;
          });
        },
        css: function(mix, val) {
          if (arguments.length <= 1 && 'string' === typeof mix) {
            if (null == this.length) {
              return null;
            }
            var style = this[0].attr.style;
            if (null == style) {
              return null;
            }
            var obj = css_parseStyle(style);
            return null == mix ? obj : obj[mix];
          }
          if (null == mix) {
            return this;
          }
          var stringify = 'object' === typeof mix ? css_stringify : css_stringifyKeyVal;
          var extend = 'object' === typeof mix ? obj_extend : css_extendKeyVal;
          return coll_each(this, function(node) {
            var style = node.attr.style;
            if (null == style) {
              node.attr.style = stringify(mix, val);
              return;
            }
            var css = css_parseStyle(style);
            extend(css, mix, val);
            node.attr.style = css_stringify(css);
          });
        }
      };
      function css_extendKeyVal(css, key, val) {
        css[key] = val;
      }
      function css_parseStyle(style) {
        var obj = {};
        style.split(';').forEach(function(x) {
          if ('' === x) {
            return;
          }
          var i = x.indexOf(':'), key = x.substring(0, i).trim(), val = x.substring(i + 1).trim();
          obj[key] = val;
        });
        return obj;
      }
      function css_stringify(css) {
        var key, str = '';
        for (key in css) {
          str += key + ':' + css[key] + ';';
        }
        return str;
      }
      function css_stringifyKeyVal(key, val) {
        return key + ':' + val + ';';
      }
    })();
    var ManipClass;
    (function() {
      ManipClass = {
        hasClass: function(klass) {
          return coll_find(this, function(node) {
            return has(node, klass);
          });
        }
      };
      var Mutator_ = {
        add: function(node, klass) {
          if (false === has(node, klass)) {
            add(node, klass);
          }
        },
        remove: function(node, klass) {
          if (true === has(node, klass)) {
            remove(node, klass);
          }
        },
        toggle: function(node, klass) {
          var fn = true === has(node, klass) ? remove : add;
          fn(node, klass);
        }
      };
      arr_each([ 'add', 'remove', 'toggle' ], function(method) {
        var fn = Mutator_[method];
        ManipClass[method + 'Class'] = function(klass) {
          return coll_each(this, function(node) {
            fn(node, klass);
          });
        };
      });
      function current(node) {
        var className = node.attr['class'];
        return 'string' === typeof className ? className : '';
      }
      function has(node, klass) {
        return -1 !== (' ' + current(node) + ' ').indexOf(' ' + klass + ' ');
      }
      function add(node, klass) {
        node.attr['class'] = (current(node) + ' ' + klass).trim();
      }
      function remove(node, klass) {
        node.attr['class'] = (' ' + current(node) + ' ').replace(' ' + klass + ' ', '').trim();
      }
    })();
    var ManipDom;
    (function() {
      ManipDom = {
        clone: function() {
          return jMask(coll_map(this, jmask_clone));
        },
        wrap: function(wrapper) {
          var $wrap = jMask(wrapper);
          if (0 === $wrap.length) {
            log_warn('Not valid wrapper', wrapper);
            return this;
          }
          var result = coll_map(this, function(x) {
            var node = $wrap.clone()[0];
            jmask_deepest(node).nodes = [ x ];
            if (null != x.parent) {
              var i = coll_indexOf(x.parent.nodes, x);
              if (-1 !== i) {
                x.parent.nodes.splice(i, 1, node);
              }
            }
            return node;
          });
          return jMask(result);
        },
        wrapAll: function(wrapper) {
          var $wrap = jMask(wrapper);
          if (0 === $wrap.length) {
            log_error('Not valid wrapper', wrapper);
            return this;
          }
          this.parent().mask($wrap);
          jmask_deepest($wrap[0]).nodes = this.toArray();
          return this.pushStack($wrap);
        }
      };
      arr_each([ 'empty', 'remove' ], function(method) {
        ManipDom[method] = function() {
          return coll_each(this, Methods_[method]);
        };
        var Methods_ = {
          remove: function(node) {
            if (null != node.parent) {
              coll_remove(node.parent.nodes, node);
            }
          },
          empty: function(node) {
            node.nodes = null;
          }
        };
      });
    })();
    var Traverse;
    (function() {
      Traverse = {
        each: function(fn, ctx) {
          for (var i = 0; i < this.length; i++) {
            fn.call(ctx || this, this[i], i);
          }
          return this;
        },
        map: function(fn, ctx) {
          var arr = [];
          for (var i = 0; i < this.length; i++) {
            arr.push(fn.call(ctx || this, this[i], i));
          }
          return this.pushStack(arr);
        },
        eq: function(i) {
          return -1 === i ? this.slice(i) : this.slice(i, i + 1);
        },
        get: function(i) {
          return i < 0 ? this[this.length - i] : this[i];
        },
        slice: function() {
          return this.pushStack(Array.prototype.slice.apply(this, arguments));
        }
      };
      arr_each([ 'filter', 'children', 'closest', 'parent', 'find', 'first', 'last' ], function(method) {
        Traverse[method] = function(selector) {
          var i, x, result = [], matcher = null == selector ? null : selector_parse(selector, this.type, 'closest' === method ? 'up' : 'down');
          switch (method) {
           case 'filter':
            return jMask(jmask_filter(this, matcher));

           case 'children':
            var nextKey = selector_getNextKey(this);
            for (i = 0; i < this.length; i++) {
              x = this[i];
              var arr = x[nextKey];
              if (null == arr) {
                continue;
              }
              result = result.concat(null == matcher ? arr : jmask_filter(arr, matcher));
            }
            break;

           case 'parent':
            for (i = 0; i < this.length; i++) {
              x = this[i].parent;
              if (!x || x.type === Dom.FRAGMENT || matcher && selector_match(x, matcher)) {
                continue;
              }
              result.push(x);
            }
            arr_unique(result);
            break;

           case 'closest':
           case 'find':
            if (null == matcher) {
              break;
            }
            for (i = 0; i < this.length; i++) {
              jmask_find(this[i][matcher.nextKey], matcher, result);
            }
            break;

           case 'first':
           case 'last':
            var index;
            for (i = 0; i < this.length; i++) {
              index = 'first' === method ? i : this.length - i - 1;
              x = this[index];
              if (null == matcher || selector_match(x, matcher)) {
                result[0] = x;
                break;
              }
            }
            break;
          }
          return this.pushStack(result);
        };
      });
    })();
    jMask = function(mix) {
      if (this instanceof jMask === false) {
        return new jMask(mix);
      }
      if (null == mix) {
        return this;
      }
      if (mix.type === Dom.SET) {
        return mix;
      }
      return this.add(mix);
    };
    obj_extendMany(Proto, ManipAttr, ManipClass, ManipDom, Traverse, {
      constructor: jMask
    });
    jMask.prototype = Proto;
  })();
  var mask_merge;
  (function() {
    (function() {
      attr_first = function(attr) {
        for (var key in attr) {
          return key;
        }
        return null;
      };
    })();
    /**
		 * Join two Mask templates or DOM trees
		 * @param {(string|MaskNode)} a - first template
		 * @param {(string|MaskNode)} b - second template
		 * @param {(MaskNode|Component)} [owner]
		 * @param {object} [opts]
		 * @param {bool} [opts.extending=false] - Clean the merged tree from all unused placeholders
		 * @param {obj} [stats] - Output holder, if merge info is requred
		 * @returns {MaskNode} New joined Mask DOM tree
		 * @memberOf mask
		 * @method merge
		 */    mask_merge = function(a, b, owner, opts, stats) {
      if ('string' === typeof a) {
        a = parser_parse(a);
      }
      if ('string' === typeof b) {
        b = parser_parse(b);
      }
      if (null == a || is_ArrayLike(a) && 0 === a.length) {
        return b;
      }
      var placeholders = _resolvePlaceholders(b, b, new Placeholders(null, b, opts));
      var out = _merge(a, placeholders, owner);
      if (null != stats) {
        stats.placeholders = placeholders;
      }
      var extra = placeholders.$extra;
      if (null != extra && 0 !== extra.length) {
        if (is_Array(out)) {
          return out.concat(extra);
        }
        return [ out ].concat(extra);
      }
      return out;
    };
    var tag_ELSE = '@else', tag_IF = '@if', tag_EACH = '@each', tag_PLACEHOLDER = '@placeholder', dom_NODE = Dom.NODE, dom_TEXTNODE = Dom.TEXTNODE, dom_FRAGMENT = Dom.FRAGMENT, dom_STATEMENT = Dom.STATEMENT, dom_COMPONENT = Dom.COMPONENT, dom_DECORATOR = Dom.DECORATOR;
    function _merge(node, placeholders, tmplNode, clonedParent) {
      if (null == node) {
        return null;
      }
      var fn;
      if (is_Array(node)) {
        fn = _mergeArray;
      } else {
        switch (node.type) {
         case dom_TEXTNODE:
          fn = _cloneTextNode;
          break;

         case dom_DECORATOR:
          fn = _cloneDecorator;
          break;

         case dom_NODE:
         case dom_STATEMENT:
          fn = _mergeNode;
          break;

         case dom_FRAGMENT:
          fn = _mergeFragment;
          break;

         case dom_COMPONENT:
          fn = _mergeComponent;
          break;
        }
      }
      if (void 0 !== fn) {
        return fn(node, placeholders, tmplNode, clonedParent);
      }
      log_warn('Unknown type', node.type);
      return null;
    }
    function _mergeArray(nodes, placeholders, tmplNode, clonedParent) {
      if (null == nodes) {
        return null;
      }
      var x, node, fragment = [], imax = nodes.length, i = -1;
      while (++i < imax) {
        node = nodes[i];
        if (node.tagName === tag_ELSE) {
          // check previous
          if (null != x) {
            continue;
          }
          if (node.expression && !eval_(node.expression, placeholders, tmplNode)) {
            continue;
          }
          x = _merge(nodes[i].nodes, placeholders, tmplNode, clonedParent);
        } else {
          x = _merge(node, placeholders, tmplNode, clonedParent);
        }
        appendAny(fragment, x);
      }
      return fragment;
    }
    function _mergeFragment(frag, placeholders, tmplNode, clonedParent) {
      var fragment = new Dom.Fragment();
      fragment.parent = clonedParent;
      fragment.nodes = _mergeArray(frag.nodes, placeholders, tmplNode, fragment);
      return fragment;
    }
    function _mergeComponent(node, placeholders, tmplNode, clonedParent) {
      if (null == node.nodes) {
        return node;
      }
      var cloned = new Dom.Component();
      obj_extend(cloned, node);
      cloned.nodes = _merge(cloned.nodes, placeholders, tmplNode, clonedParent);
      return cloned;
    }
    function _mergeNode(node, placeholders, tmplNode, clonedParent) {
      var tagName = node.tagName;
      if (64 !== tagName.charCodeAt(0)) {
        // @
        return _cloneNode(node, placeholders, tmplNode, clonedParent);
      }
      placeholders.$isEmpty = false;
      var parentIsCompo = clonedParent && null != placeholders.$compos[clonedParent.tagName];
      if (parentIsCompo) {
        var isSimpleNode = null == node.nodes || 0 === node.nodes.length;
        if (false === isSimpleNode) {
          // Interpolate component slots
          return _cloneNode(node, placeholders, tmplNode, clonedParent);
        }
      }
      var id = node.attr.id;
      if (tagName === tag_PLACEHOLDER && null == id) {
        if (null != tmplNode) {
          var tagName_ = tmplNode.tagName;
          if (null != tagName_ && 64 /*@*/ === tmplNode.tagName.charCodeAt(0)) {
            return tmplNode.nodes;
          }
        }
        id = '$root';
        placeholders.$extra = null;
      }
      if (tag_EACH === tagName) {
        var x, arr = placeholders.$getNode(node.expression);
        if (null == arr) {
          if (null == node.attr.optional) {
            error_withNode('No template node: @' + node.expression, node);
          }
          return null;
        }
        if (false === is_Array(arr)) {
          x = arr;
          return _merge(node.nodes, _resolvePlaceholders(x.nodes, x.nodes, new Placeholders(placeholders)), x, clonedParent);
        }
        var fragment = new Dom.Fragment(), imax = arr.length, i = -1;
        while (++i < imax) {
          x = arr[i];
          appendAny(fragment, _merge(node.nodes, _resolvePlaceholders(x, x, new Placeholders(placeholders)), x, clonedParent));
        }
        return fragment;
      }
      if (tag_IF === tagName) {
        var val = eval_(node.expression, placeholders, tmplNode);
        return val ? _merge(node.nodes, placeholders, tmplNode, clonedParent) : null;
      }
      if (null == id) {
        id = tagName.substring(1);
      }
      var content = placeholders.$getNode(id, node.expression);
      if (null == content) {
        if (true === placeholders.opts.extending || parentIsCompo) {
          return node;
        }
        return null;
      }
      if (content.parent) {
        _modifyParents(clonedParent, content.parent);
      }
      var wrapperNode, contentNodes = content.nodes;
      if (void 0 !== node.attr.as) {
        tagName_ = node.attr.as;
        wrapperNode = {
          type: dom_NODE,
          tagName: tagName_,
          attr: _mergeAttr(node.attr, content.attr, placeholders, tmplNode),
          parent: clonedParent,
          nodes: contentNodes
        };
        wrapperNode.attr.as = null;
      }
      if (null == node.nodes) {
        return _merge(wrapperNode || contentNodes, placeholders, tmplNode, clonedParent);
      }
      var nodes = _merge(node.nodes, _resolvePlaceholders(contentNodes, contentNodes, new Placeholders(placeholders)), content, wrapperNode || clonedParent);
      if (null != wrapperNode) {
        wrapperNode.nodes = nodes;
        return wrapperNode;
      }
      return nodes;
    }
    function _mergeAttr(a, b, placeholders, tmplNode) {
      if (null == a || null == b) {
        return a || b;
      }
      var out = interpolate_obj_(a, placeholders, tmplNode);
      for (var key in b) {
        out[key] = interpolate_str_(b[key], placeholders, tmplNode);
      }
      return out;
    }
    function _cloneNode(node, placeholders, tmplNode, clonedParent) {
      var tagName = node.tagName || node.compoName;
      var deepClone = true;
      switch (tagName) {
       case ':template':
        var id = interpolate_str_(node.attr.id, placeholders, tmplNode);
        Templates.register(id, node.nodes);
        return null;

       case ':import':
        id = interpolate_str_(node.attr.id, placeholders, tmplNode);
        var nodes = Templates.resolve(node, id);
        return _merge(nodes, placeholders, tmplNode, clonedParent);

       case 'function':
       case 'define':
       case 'let':
       case 'var':
       case 'import':
       case 'script':
       case 'style':
       case 'slot':
       case 'event':
       case 'await':
        return node;

       case 'include':
        tagName = node.attr.id;
        if (null == tagName) {
          tagName = attr_first(node.attr);
        }
        tagName = interpolate_str_(tagName, placeholders, tmplNode);
        var handler = customTag_get(tagName, tmplNode);
        if (null != handler) {
          var proto = handler.prototype;
          var tmpl = proto.template || proto.nodes;
          placeholders.$isEmpty = false;
          var next = _resolvePlaceholders(node.nodes, node.nodes, new Placeholders(placeholders, node.nodes));
          return _merge(tmpl, next, tmplNode, clonedParent);
        }
        break;

       default:
        handler = customTag_get(tagName, tmplNode);
        if (null != handler) {
          placeholders.$compos[tagName] = handler;
          proto = handler.prototype;
          if (proto && null != proto.meta && 'merge' !== proto.meta.template) {
            deepClone = false;
          }
        }
        break;
      }
      var outnode = _cloneNodeShallow(node, clonedParent, placeholders, tmplNode);
      if (true === deepClone && outnode.nodes) {
        outnode.nodes = _merge(node.nodes, placeholders, tmplNode, outnode);
      }
      return outnode;
    }
    function _cloneNodeShallow(node, clonedParent, placeholders, tmplNode) {
      return {
        type: node.type,
        tagName: node.tagName,
        attr: interpolate_obj_(node.attr, placeholders, tmplNode),
        props: null == node.props ? null : interpolate_obj_(node.props, placeholders, tmplNode),
        expression: interpolate_str_(node.expression, placeholders, tmplNode),
        controller: node.controller,
        // use original parent, to preserve the module scope for the node of each template
        parent: node.parent || clonedParent,
        nodes: node.nodes,
        sourceIndex: node.sourceIndex
      };
    }
    function _cloneTextNode(node, placeholders, tmplNode, clonedParent) {
      return {
        type: node.type,
        content: interpolate_str_(node.content, placeholders, tmplNode),
        parent: node.parent || clonedParent,
        sourceIndex: node.sourceIndex
      };
    }
    function _cloneDecorator(node, placeholders, tmplNode, clonedParent) {
      var out = new Dom.DecoratorNode(node.expression, clonedParent || node.parent);
      out.sourceIndex = node.sourceIndex;
      return out;
    }
    function interpolate_obj_(obj, placeholders, node) {
      var clone = _Object_create(obj);
      for (var key in clone) {
        var x = clone[key];
        if (null == x) {
          continue;
        }
        if ('@[...attr]' === key) {
          // When `node` is component, the original node is under `node` property
          var attr = (node.node || node).attr;
          for (var key_1 in attr) {
            var val = attr[key_1];
            if ('class' === key_1) {
              var current = clone[key_1];
              if (null != current) {
                var isFn = false;
                if (is_Function(current)) {
                  isFn = true;
                  current = current();
                }
                if (is_Function(val)) {
                  isFn = true;
                  val = val();
                }
                current += ' ' + val;
                clone[key_1] = isFn ? parser_ensureTemplateFunction(current) : current;
                continue;
              }
            }
            clone[key_1] = val;
          }
          clone[key] = null;
          continue;
        }
        clone[key] = interpolate_str_(x, placeholders, node);
      }
      return clone;
    }
    function interpolate_str_(mix, placeholders, node) {
      var index = -1, isFn = false, str = mix;
      if ('function' === typeof mix) {
        isFn = true;
        str = mix();
      }
      if ('string' !== typeof str || -1 === (index = str.indexOf('@'))) {
        return mix;
      }
      if (null != placeholders) {
        placeholders.$isEmpty = false;
      }
      var c, result = str.substring(0, index), length = str.length, isBlockEntry = 91 === str.charCodeAt(index + 1), // [
      last = -1;
      while (index < length) {
        // interpolation
        last = index;
        if (true === isBlockEntry) {
          index = cursor_groupEnd(str, index + 2, length, 91, 93);
          // []
                    if (-1 === index) {
            index = length;
          }
          last += 2;
        } else {
          while (index < length) {
            c = str.charCodeAt(++index);
            if (36 === c || 95 === c || 46 === c) {
              // $ _ .
              continue;
            }
            if (48 <= c && c <= 57 || // 0-9
            65 <= c && c <= 90 || // A-Z
            97 <= c && c <= 122) {
              // a-z
              continue;
            }
            break;
          }
        }
        var expr = str.substring(last, index), fn = isBlockEntry ? eval_ : interpolate_, x = fn(expr, placeholders, node);
        if (null != x) {
          if (is_Function(x)) {
            isFn = true;
            x = x();
          }
          result += x;
        } else if (true === placeholders.opts.extending) {
          result += isBlockEntry ? '@[' + expr + ']' : expr;
        }
        // tail
                last = isBlockEntry ? index + 1 : index;
        index = str.indexOf('@', index);
        if (-1 === index) {
          index = length;
        }
        result += str.substring(last, index);
      }
      return isFn ? parser_ensureTemplateFunction(result) : result;
    }
    function interpolate_(path, placeholders, node) {
      var index = path.indexOf('.');
      if (-1 === index) {
        log_warn('Merge templates. Accessing node', path);
        return null;
      }
      var tagName = path.substring(0, index), id = tagName.substring(1), property = path.substring(index + 1), obj = null;
      if (null != node) {
        if ('@attr' === tagName) {
          return interpolate_getAttr_(node, placeholders, property);
        } else if ('@counter' === tagName) {
          return interpolate_getCounter_(property);
        } else if (tagName === node.tagName) {
          obj = node;
        }
      }
      if (null == obj) {
        obj = placeholders.$getNode(id);
      }
      if (null == obj) {
        //- log_error('Merge templates. Node not found', tagName);
        return null;
      }
      return obj_getProperty(obj, property);
    }
    function interpolate_getAttr_(node, placeholders, prop) {
      var x = node.attr && node.attr[prop];
      var el = placeholders;
      while (null == x && null != el) {
        x = el.attr && el.attr[prop];
        el = el.parent;
      }
      return x;
    }
    var interpolate_getCounter_;
    (function() {
      var _counters = {};
      interpolate_getCounter_ = function(prop) {
        var i = _counters[prop] || 0;
        return _counters[prop] = ++i;
      };
    })();
    function appendAny(node, mix) {
      if (null == mix) {
        return;
      }
      if ('function' === typeof mix.concat) {
        var imax = mix.length;
        for (var i = 0; i < imax; i++) {
          appendAny(node, mix[i]);
        }
        return;
      }
      if (mix.type === dom_FRAGMENT) {
        appendAny(node, mix.nodes);
        return;
      }
      if ('function' === typeof node.appendChild) {
        node.appendChild(mix);
        return;
      }
      var l = node.length;
      if (l > 0) {
        var prev = node[l - 1];
        prev.nextSibling = mix;
      }
      node.push(mix);
    }
    var RESERVED = ' else placeholder each attr if parent scope';
    function _resolvePlaceholders(root, node, placeholders) {
      if (null == node) {
        return placeholders;
      }
      if (is_Array(node)) {
        var imax = node.length, i = -1;
        while (++i < imax) {
          _resolvePlaceholders(node === root ? node[i] : root, node[i], placeholders);
        }
        return placeholders;
      }
      var type = node.type;
      if (type === dom_TEXTNODE) {
        return placeholders;
      }
      if (type === dom_NODE) {
        var tagName = node.tagName;
        if (null != tagName && 64 === tagName.charCodeAt(0)) {
          // @
          placeholders.$count++;
          var id = tagName.substring(1);
          // if DEBUG
                    if (-1 !== RESERVED.indexOf(' ' + id + ' ')) {
            log_error('MaskMerge. Reserved Name', id);
            // endif
                    }
          var x = {
            tagName: node.tagName,
            parent: _getParentModifiers(root, node),
            nodes: node.nodes,
            attr: node.attr,
            expression: node.expression,
            type: node.type
          };
          if (null == placeholders[id]) {
            placeholders[id] = x;
          } else {
            var current = placeholders[id];
            if (is_Array(current)) {
              current.push(x);
            } else {
              placeholders[id] = [ current, x ];
            }
          }
          return placeholders;
        }
      }
      var count = placeholders.$count;
      var out = _resolvePlaceholders(root, node.nodes, placeholders);
      if (root === node && count === placeholders.$count) {
        placeholders.$extra.push(root);
      }
      return out;
    }
    function _getParentModifiers(root, node) {
      if (node === root) {
        return null;
      }
      var current, parents, parent = node.parent;
      while (true) {
        if (null == parent) {
          break;
        }
        if (parent === root && root.type !== dom_NODE) {
          break;
        }
        var p = {
          type: parent.type,
          tagName: parent.tagName,
          attr: parent.attr,
          controller: parent.controller,
          expression: parent.expression,
          nodes: null,
          parent: null
        };
        if (null == parents) {
          current = parents = p;
        } else {
          current.parent = p;
          current = p;
        }
        parent = parent.parent;
      }
      return parents;
    }
    function _modifyParents(clonedParent, parents) {
      var nodeParent = clonedParent, modParent = parents;
      while (null != nodeParent && null != modParent) {
        if (modParent.tagName) {
          nodeParent.tagName = modParent.tagName;
        }
        if (modParent.expression) {
          nodeParent.expression = modParent.expression;
        }
        for (var key in modParent.attr) {
          nodeParent.attr[key] = modParent.attr[key];
        }
        nodeParent = nodeParent.parent;
        modParent = modParent.parent;
      }
    }
    function eval_(expr, placeholders, tmplNode) {
      if (null != tmplNode) {
        placeholders.attr = tmplNode.attr;
      }
      return expression_eval(expr, placeholders, null, placeholders);
    }
    function Placeholders(parent, nodes, opts) {
      var $root = null;
      if (null != nodes) {
        $root = new Dom.Node(tag_PLACEHOLDER);
        $root.nodes = nodes;
      }
      this.scope = this;
      this.parent = parent;
      this.$root = $root || parent && parent.$root;
      this.$extra = [];
      this.$compos = {};
      if (null != opts) {
        this.opts = opts;
      } else if (null != parent) {
        this.opts = parent.opts;
      }
    }
    Placeholders.prototype = {
      opts: {
        extending: false
      },
      parent: null,
      attr: null,
      scope: null,
      $root: null,
      $extra: null,
      $count: 0,
      $isEmpty: true,
      $compos: null,
      $getNode: function(id, filter) {
        var node, ctx = this;
        while (null != ctx) {
          node = ctx[id];
          if (null != node) {
            break;
          }
          ctx = ctx.parent;
        }
        if (null != filter && null != node) {
          node = {
            nodes: jMask(node.nodes).filter(filter)
          };
        }
        return node;
      }
    };
  })();
  var Templates;
  (function() {
    var cache_ = {};
    Templates = {
      get: function(id) {
        return cache_[id];
      },
      resolve: function(node, id) {
        var nodes = cache_[id];
        if (null != nodes) {
          return nodes;
        }
        var selector = ':template[id=' + id + ']', parent = node.parent, tmpl = null;
        while (null != parent) {
          tmpl = jMask(parent.nodes).filter(selector).get(0);
          if (null != tmpl) {
            return tmpl.nodes;
          }
          parent = parent.parent;
        }
        log_warn('Template was not found', id);
        return null;
      },
      register: function(id, nodes) {
        if (null == id) {
          log_warn('`:template` must define the `id` attr');
          return;
        }
        cache_[id] = nodes;
      }
    };
    customTag_register(':template', {
      render: function() {
        Templates.register(this.attr.id, this.nodes);
      }
    });
    customTag_register(':import', {
      renderStart: function() {
        var id = this.attr.id;
        if (null == id) {
          log_error('`:import` shoud reference the template via id attr');
          return;
        }
        this.nodes = Templates.resolve(this, id);
      }
    });
    custom_Statements['include'] = {
      render: function(node, model, ctx, container, ctr, els) {
        var name = attr_first(node.attr);
        var Compo = customTag_get(name, ctr);
        var template;
        if (null != Compo) {
          template = Compo.prototype.template || Compo.prototype.nodes;
          if (null != template) {
            template = mask_merge(template, node.nodes);
          }
        } else {
          template = Templates.get(name);
        }
        if (null != template) {
          builder_build(template, model, ctx, container, ctr, els);
        }
      }
    };
    customTag_register('layout:master', {
      meta: {
        mode: 'server'
      },
      render: function() {
        var name = this.attr.id || attr_first(this.attr);
        Templates.register(name, this.nodes);
      }
    });
    customTag_register('layout:view', {
      meta: {
        mode: 'server'
      },
      render: function(model, ctx, container, ctr, els) {
        var nodes = Templates.get(this.attr.master);
        var template = mask_merge(nodes, this.nodes, null, {
          extending: true
        });
        builder_build(template, model, ctx, container, ctr, els);
      }
    });
  })();
  var Decorator;
  (function() {
    var _store;
    (function() {
      _store = {};
    })();
    var _getDecorator, _getDecoType;
    (function() {
      _getDecorator = function(decoNode, model, ctx, ctr) {
        var expr = decoNode.expression, deco = expression_eval(expr, _store, null, ctr);
        if (null == deco) {
          error_withNode('Decorator not resolved', decoNode);
          return null;
        }
        if (-1 === expr.indexOf('(') && isFactory(deco)) {
          return initialize(deco);
        }
        return deco;
      };
      _getDecoType = function(node) {
        var tagName = node.tagName, type = node.type;
        if ('function' === tagName || 'slot' === tagName || 'event' === tagName || 'pipe' === tagName) {
          return 'METHOD';
        }
        if ((1 === type || 15 === type) && null != custom_Tags[tagName]) {
          type = 4;
        }
        if (1 === type && null != custom_Statements[tagName]) {
          type = 15;
        }
        if (1 === type) {
          return 'NODE';
        }
        if (4 === type) {
          return 'COMPO';
        }
        return null;
      };
      function isFactory(deco) {
        return true === deco.isFactory;
      }
      function initialize(deco) {
        if (is_Function(deco)) {
          return new deco();
        }
        // is object
                var self = obj_create(deco);
        if (deco.hasOwnProperty('constructor')) {
          var x = deco.constructor.call(self);
          if (null != x) {
            return x;
          }
        }
        return self;
      }
    })();
    var _wrapMany, _wrapper_Fn, _wrapper_NodeBuilder, _wrapper_CompoBuilder;
    (function() {
      _wrapMany = function(wrapperFn, decorators, fn, target, key, model, ctx, ctr) {
        var _fn = fn, i = decorators.length;
        while (-1 !== --i) {
          _fn = wrap(wrapperFn, decorators[i], _fn, target, key, model, ctx, ctr);
        }
        return _fn;
      };
      _wrapper_Fn = function(decoNode, deco, innerFn, target, key) {
        if (is_Function(deco)) {
          if (deco.length > 1) {
            var descriptor = {
              value: innerFn
            };
            var result = deco(target, key, descriptor);
            if (null == result) {
              if (target[key] !== innerFn) {
                return target[key];
              }
              return descriptor.value;
            }
            if (null == result.value) {
              error_withNode('Decorator should return value descriptor', decoNode);
              return innerFn;
            }
            return result.value;
          }
          return deco(innerFn) || innerFn;
        }
        var beforeInvoke = deco.beforeInvoke, afterInvoke = deco.afterInvoke;
        if (beforeInvoke || afterInvoke) {
          return function() {
            var args = _Array_slice.call(arguments);
            if (null != beforeInvoke) {
              var overridenArgs = beforeInvoke.apply(this, args);
              if (is_Array(overridenArgs)) {
                args = overridenArgs;
              }
            }
            var result = innerFn.apply(this, args);
            if (null != afterInvoke) {
              var overridenResult = afterInvoke.call(this, result);
              if (void 0 !== overridenResult) {
                result = overridenResult;
              }
            }
            return result;
          };
        }
        error_withNode('Invalid function decorator', decoNode);
      };
      _wrapper_NodeBuilder = function(decoNode, deco, builderFn) {
        var beforeRender, afterRender, decoCtx;
        if (is_Function(deco)) {
          afterRender = deco;
        } else if (is_Object(deco)) {
          beforeRender = deco.beforeRender;
          afterRender = deco.afterRender;
          decoCtx = deco;
        }
        if (beforeRender || afterRender) {
          return create(decoCtx, beforeRender, afterRender, builderFn);
        }
        error_withNode('Invalid node decorator', decoNode);
      };
      _wrapper_CompoBuilder = function(decoNode, deco, builderFn) {
        var beforeRender, afterRender, decoCtx;
        if (is_Function(deco)) {
          beforeRender = deco;
        } else if (is_Object(deco)) {
          beforeRender = deco.beforeRender;
          afterRender = deco.afterRender;
          decoCtx = deco;
        }
        if (beforeRender || afterRender) {
          return create(decoCtx, beforeRender, afterRender, builderFn);
        }
        error_withNode('Invalid node decorator', decoNode);
      };
      function wrap(wrapperFn, decoratorNode, innerFn, target, key, model, ctx, ctr) {
        var deco = _getDecorator(decoratorNode, model, ctx, ctr);
        if (null == deco) {
          return innerFn;
        }
        return wrapperFn(decoratorNode, deco, innerFn, target, key) || innerFn;
      }
      function create(decoCtx, beforeFn, afterFn, builderFn) {
        return function(node, model, ctx, el, ctr, els) {
          if (null != beforeFn) {
            var mix = beforeFn.call(decoCtx, node, model, ctx, el, ctr, els);
            if (null != mix) {
              if ('tagName' in mix) {
                console.warn('@obsolete: Before FN in decorator should return compound object with node?, container?, controller?, model? properties');
                node = mix;
              } else {
                if (mix.model) {
                  model = mix.model;
                }
                if (mix.node) {
                  node = mix.node;
                }
                if (mix.container) {
                  el = mix.container;
                }
                if (mix.controller) {
                  ctr = mix.controller;
                }
              }
            }
          }
          if (null == els) {
            els = [];
          }
          builderFn(node, model, ctx, el, ctr, els);
          if (null != afterFn) {
            afterFn.call(decoCtx, els[els.length - 1], model, ctr);
          }
        };
      }
    })();
    (function() {
      (function() {
        (function() {
          sourceUrl_get = function(node) {
            //if DEBUG
            var tag = node.tagName;
            var fn = 'let' === tag || 'define' === tag ? forDefine : forNode;
            var url = fn(node), i = _sourceUrls[url];
            if (void 0 !== i) {
              i = ++_sourceUrls[url];
            }
            if (null != i) {
              url += '_' + i;
            }
            _sourceUrls[url] = 1;
            return '\n//# sourceURL=' + ORIGIN + '/controllers/' + url;
            //endif
                    };
          var ORIGIN = _global.location && _global.location.origin || 'dynamic://MaskJS';
          //if DEBUG
                    function forDefine(node) {
            var x = node, url = x.tagName + '_' + x.name;
            if ('let' === x.tagName) {
              while (null != (x = x.parent) && 'define' !== x.tagName) {}
              if (null != x) {
                url = x.tagName + '_' + x.name + '-' + url;
              }
            }
            return url;
          }
          function forNode(node) {
            var url = node.tagName + '_' + node.name, x = node, i = 0;
            while (null != (x = x.parent) && ++i < 10) {
              var tag = x.tagName;
              if ('let' === tag || 'define' === tag) {
                url = x.name + '.' + url;
                continue;
              }
              if (0 === i) {
                url = x.tagName + '_' + url;
              }
            }
            return url;
          }
          var _sourceUrls = {};
          //endif
                })();
        (function() {
          _args_toCode = function(args) {
            var str = '';
            if (null == args || 0 === args.length) {
              return str;
            }
            var imax = args.length, i = -1;
            while (++i < imax) {
              if (i > 0) {
                str += ',';
              }
              str += args[i].prop;
            }
            return str;
          };
        })();
        (function() {
          scopeRefs_getImportVars = function(owner, out_) {
            var imports = getImports(owner);
            if (null == imports) {
              return;
            }
            var out = out_ || [ [], [] ], imax = imports.length, i = -1;
            while (++i < imax) {
              var import_ = imports[i];
              var type = import_.type;
              if ('script' !== type && 'data' !== type && 'text' !== type && 'mask' !== type) {
                continue;
              }
              import_.eachExport(register);
            }
            function register(varName) {
              var val = this.getExport(varName);
              out[0].push(varName);
              out[1].push(val);
            }
          };
          function getImports(owner) {
            if (owner.importItems) {
              return owner.importItems;
            }
            var x = owner;
            while (null != x && 'imports' !== x.tagName) {
              x = x.parent;
            }
            return null == x ? null : x.importItems;
          }
        })();
        defMethods_getSource = function(defNode, defProto, model, owner) {
          var nodes = getFnNodes(defNode.nodes);
          if (null == nodes || 0 === nodes.length) {
            return;
          }
          var body = createFnBody(defNode, nodes);
          var sourceUrl = sourceUrl_get(defNode);
          // [[name],[value]]
                    var scopeVars = getScopeVars(defNode, defProto, model, owner);
          var code = createFnWrapperCode(defNode, body, scopeVars[0]);
          var preproc = __cfg.preprocessor.script;
          if (preproc) {
            code = preproc(code);
          }
          if (null != sourceUrl) {
            code += sourceUrl;
          }
          return [ code, nodes, scopeVars[1] ];
        };
        defMethods_compile = function(defNode, defProto, model, owner) {
          var source = defMethods_getSource(defNode, defProto, model, owner);
          if (null == source) {
            return;
          }
          var code = source[0], nodes = source[1], vals = source[2], fnWrapper = Function('return ' + code), factory = fnWrapper(), fns = factory.apply(null, vals), imax = nodes.length, i = -1;
          while (++i < imax) {
            var node = nodes[i];
            var fn = fns[i];
            if ('constructor' === node.name) {
              fn = wrapDi(fn, node);
            }
            node.fn = fn;
          }
        };
        function createFnBody(defineNode, nodes) {
          var code = 'return [\n', localVars = createFnLocalVars(defineNode), i = -1, imax = nodes.length;
          while (++i < imax) {
            var node = nodes[i], name = (node.tagName, node.getFnName()), body = node.body, argMetas = node.args;
            if (node.flagAsync) {
              code += 'async ';
            }
            code += 'function ' + name + ' (' + _args_toCode(argMetas) + ') {\n';
            code += localVars + body;
            code += '\n}' + (i === imax - 1 ? '' : ',') + '\n';
          }
          code += '];\n';
          return code;
        }
        function createFnWrapperCode(defineNode, body, args) {
          var name = defineNode.name.replace(/[:$]/g, '_') + 'Controller';
          var code = 'function ' + name + ' (' + args.join(',') + ') {\n';
          code += body;
          code += '\n}';
          return code;
        }
        function createFnLocalVars(defineNode) {
          var args = defineNode.arguments;
          if (null == args) {
            return '';
          }
          var imax = args.length, i = -1;
          if (0 === imax) {
            return '';
          }
          var prop, str = 'var ';
          while (++i < imax) {
            prop = args[i].name;
            str += prop + ' = this.model.' + prop;
            str += i === imax - 1 ? ';\n' : ',\n    ';
          }
          return str;
        }
        function getFnNodes(nodes) {
          if (null == nodes) {
            return null;
          }
          var arr, imax = nodes.length, i = -1;
          while (++i < imax) {
            var node = nodes[i];
            if (node.type === Dom.DECORATOR) {
              var start = i;
              i = Decorator.goToNode(nodes, i, imax);
              node = nodes[i];
              if (false === isFn(node.tagName)) {
                continue;
              }
              node.decorators = _Array_slice.call(nodes, start, i);
            }
            if (false === isFn(node.tagName) || null != node.fn) {
              continue;
            }
            if (null == arr) {
              arr = [];
            }
            arr.push(node);
          }
          return arr;
        }
        function getScopeVars(defNode, defProto, model, owner) {
          var out = [ [], [] ];
          scopeRefs_getImportVars(owner, out);
          return out;
        }
        function isFn(name) {
          return 'function' === name || 'slot' === name || 'event' === name || 'pipe' === name;
        }
        function wrapDi(fn, fnNode) {
          var args = fnNode.args;
          if (null == args) {
            return fn;
          }
          return createDiFn(args, fn);
        }
        var createDiFn;
        (function() {
          createDiFn = function(argMetas, fn) {
            return function() {
              var args = mergeArgs(argMetas, _Array_slice.call(arguments));
              return fn.apply(this, args);
            };
          };
          function mergeArgs(argMetas, args) {
            var model = args[1];
            var controller = args[4];
            var tLength = argMetas.length, aLength = args.length, max = tLength > aLength ? tLength : aLength, arr = new Array(max), i = -1;
            while (++i < max) {
              // injections are resolved first.
              if (i < tLength && null != argMetas[i].type) {
                var Type = expression_eval(argMetas[i].type, model, null, controller);
                arr[i] = Di.resolve(Type);
                continue;
              }
              if (i < aLength && null != args[i]) {
                arr[i] = args[i];
                continue;
              }
            }
            return arr;
          }
        })();
      })();
      (function() {
        nodeMethod_getSource = function(node, model, owner) {
          var sourceUrl = sourceUrl_get(node), name = node.getFnName(), args = node.args, body = node.body, code = '';
          if (node.flagAsync) {
            code += 'async ';
          }
          code += 'function ' + name + ' (' + _args_toCode(args) + ') {\n';
          code += body;
          code += '\n}';
          var preproc = __cfg.preprocessor.script;
          if (preproc) {
            code = preproc(code);
          }
          if (null != sourceUrl) {
            code += sourceUrl;
          }
          return code;
        };
        nodeMethod_compile = function(node, model, owner) {
          var fn = node.fn;
          if (null != fn) {
            return fn;
          }
          var scopeVars = getScopeVars(node, node, owner), code = nodeMethod_getSource(node, model, owner), vars = scopeVars[0], vals = scopeVars[1], params = vars.concat([ 'return ' + code ]), factory = Function.apply(null, params);
          return node.fn = factory.apply(null, vals);
        };
        function getScopeVars(node, model, owner) {
          var out = [ [], [] ];
          scopeRefs_getImportVars(owner, out);
          return out;
        }
      })();
      (function() {
        function create(tagName) {
          return function(str, i, imax, parent) {
            var start = str.indexOf('{', i) + 1, head = parseHead(
            //tagName, str.substring(i, start - 1)
            tagName, str, i, start);
            if (null == head) {
              parser_error('Method head syntax error', str, i);
            }
            var end = cursor_groupEnd(str, start, imax, 123, 125), body = str.substring(start, end), node = null == head ? null : new MethodNode(tagName, head, body, parent);
            return [ node, end + 1, 0 ];
          };
        }
        var parseHead;
        (function() {
          var lex_ = parser_ObjectLexer('?($$flags{async:async;binding:private|public;self:self;static:static})$$methodName<accessor>? (?$$args[$$prop<token>?(? :? $$type<accessor>)](,))? ');
          parseHead = function(name, str, i, imax) {
            var head = new MethodHead();
            var end = lex_(str, i, imax, head, true);
            return end === i ? null : head;
          };
        })();
        function MethodHead() {
          this.methodName = null;
          this.args = null;
          this.async = null;
          this.binding = null;
        }
        var MethodNode = class_create(Dom.Component.prototype, {
          name: null,
          body: null,
          args: null,
          types: null,
          fn: null,
          flagAsync: false,
          flagPrivate: false,
          flagPublic: false,
          flagStatic: false,
          flagSelf: false,
          constructor: function(tagName, head, body, parent) {
            this.tagName = tagName;
            this.name = head.methodName;
            this.args = head.args;
            this.types = head.types;
            this.flagSelf = 'self' === head.self;
            this.flagAsync = 'async' === head.async;
            this.flagStatic = 'static' === head.static;
            this.flagPublic = 'public' === head.binding;
            this.flagPrivate = 'private' === head.binding;
            this.body = body;
            this.parent = parent;
          },
          getFnSource: function() {
            return nodeMethod_getSource(this, null, this.parent);
          },
          compile: function(model, owner) {
            return nodeMethod_compile(this, model, owner);
          },
          getFnName: function() {
            var tag = this.tagName, name = this.name;
            return 'event' === tag || 'pipe' === tag ? name.replace(/[^\w_$]/g, '_') : name;
          },
          stringify: function(stream) {
            var str = this.tagName + ' ';
            if (this.flagSelf) {
              str += 'self ';
            }
            if (this.flagAsync) {
              str += 'async ';
            }
            if (this.flagPublic) {
              str += 'public ';
            }
            if (this.flagStatic) {
              str += 'static ';
            }
            if (this.flagPrivate) {
              str += 'private ';
            }
            stream.write(str + this.name);
            stream.format(' ');
            stream.print('(');
            stream.printArgs(this.args);
            stream.print(')');
            stream.openBlock('{');
            stream.print(this.body);
            stream.closeBlock('}');
          }
        });
        custom_Parsers['slot'] = create('slot');
        custom_Parsers['pipe'] = create('pipe');
        custom_Parsers['event'] = create('event');
        custom_Parsers['function'] = create('function');
      })();
      (function() {
        var Method = class_create({
          meta: {
            serializeNodes: true
          },
          constructor: function(node, model, ctx, el, parent) {
            this.fn = nodeMethod_compile(node, model, parent);
            this.name = node.name;
          }
        });
        custom_Tags['slot'] = class_create(Method, {
          renderEnd: function() {
            var ctr = this.parent, slots = ctr.slots;
            if (null == slots) {
              slots = ctr.slots = {};
            }
            slots[this.name] = this.fn;
          }
        });
        (function() {
          function parse(def) {
            var rgx = /^\s*([\w]+)[:\$]+([\w]+)\s*$/, parts = rgx.exec(def), name = parts && parts[1], signal = parts && parts[2];
            if (null == parts || null == name || null == signal) {
              log_error('PipeCompo. Invalid name.', def, 'Expect', rgx.toString());
              return null;
            }
            return [ name, signal ];
          }
          function attach(node, ctr) {
            var pipes = ctr.pipes;
            if (null == pipes) {
              pipes = ctr.pipes = {};
            }
            var signal = parse(node.name);
            if (null == signal) {
              return;
            }
            var name = signal[0], type = signal[1], pipe = ctr.pipes[name];
            if (null == pipe) {
              pipe = pipes[name] = {};
            }
            pipe[type] = node.fn;
          }
          custom_Tags['pipe'] = class_create(Method, {
            renderEnd: function() {
              attach(this, this.parent);
            }
          });
          custom_Tags.pipe.attach = attach;
        })();
        custom_Tags['event'] = class_create(Method, {
          renderEnd: function(els, model, ctx, el, ctr) {
            this.fn = this.fn.bind(this.parent);
            var name = this.name, params = null, i = name.indexOf(':');
            if (-1 !== i) {
              params = name.substring(i + 1).trim();
              name = name.substring(0, i).trim();
            }
            Component.Dom.addEventListener(el, name, this.fn, params, ctr);
          }
        });
        custom_Tags['function'] = class_create(Method, {
          renderEnd: function() {
            this.parent[this.name] = this.fn;
          }
        });
      })();
      Methods = {
        getSourceForDefine: defMethods_getSource,
        compileForDefine: defMethods_compile,
        getSourceForNode: nodeMethod_getSource,
        compileForNode: nodeMethod_compile
      };
    })();
    Decorator = {
      getDecoType: _getDecoType,
      define: function(key, mix) {
        if (is_Object(mix)) {
          mix = class_create(mix);
          mix.isFactory = true;
        }
        if (is_Function(mix) && mix.isFactory) {
          // Wrap the function, as it could be a class, and decorator expression cann`t contain 'new' keyword.
          _store[key] = function() {
            return new (mix.bind.apply(mix, [ null ].concat(_Array_slice.call(arguments))))();
          };
          _store[key].isFactory = true;
          return;
        }
        _store[key] = mix;
      },
      goToNode: function(nodes, start, imax) {
        var i = start;
        while (++i < imax && 16 === nodes[i].type) {}
        if (i === imax) {
          error_withNode('No node to decorate', nodes[start]);
          return i;
        }
        return i;
      },
      wrapMethodNode: function(decorators, node, model, ctx, ctr) {
        if (node.fn) {
          return node.fn;
        }
        var fn = Methods.compileForNode(node, model, ctr);
        return node.fn = this.wrapMethod(decorators, fn, node, 'fn', model, ctx, ctr);
      },
      wrapMethod: function(decorators, fn, target, key, model, ctx, ctr) {
        return _wrapMany(_wrapper_Fn, decorators, fn, target, key, model, ctx, ctr);
      },
      wrapNodeBuilder: function(decorators, builderFn, model, ctx, ctr) {
        return _wrapMany(_wrapper_NodeBuilder, decorators, builderFn, null, null, model, ctx, ctr);
      },
      wrapCompoBuilder: function(decorators, builderFn, model, ctx, ctr) {
        return _wrapMany(_wrapper_CompoBuilder, decorators, builderFn, null, null, model, ctx, ctr);
      }
    };
  })();
  var Di;
  (function() {
    Di = {
      resolve: function(Type) {
        return _di.resolve(Type);
      },
      setResolver: function(di) {
        _di = di;
      },
      deco: {
        injectableClass: function(mix) {
          if (is_Function(mix)) {
            return createInjectableClassWrapper(mix);
          }
          return function(Ctor) {
            return createInjectableClassWrapper(Ctor, mix);
          };
        }
      }
    };
    var _di = {
      resolve: function(Type) {
        if ('function' === typeof Type) {
          return new Type();
        }
        return Type;
      }
    };
    function createInjectableClassWrapper(Ctor, types) {
      return env_class_overrideArgs(Ctor, function(node, model, ctx, el, parent) {
        var args = [];
        if (null != node.expression) {
          args = expression_evalStatements(node.expression, model, ctx, parent, node);
        }
        if (null != types) {
          if (null == args) {
            args = new Array(types.length);
          }
          for (var i = 0; i < types.length; i++) {
            if (null === types[i] || null != args[i]) {
              continue;
            }
            args[i] = _di.resolve(types[i]);
          }
        }
        return args;
      });
    }
  })();
  var Templates;
  (function() {
    (function() {
      custom_Statements['log'] = {
        render: function(node, model, ctx, container, controller) {
          var arr = expression_evalStatements(node.expression, model, ctx, controller);
          arr.unshift('Mask::Log');
          console.log.apply(console, arr);
        }
      };
      customTag_register('debugger', {
        render: function(model, ctx, container, compo) {
          debugger;
        }
      });
      customTag_register(':utest', /** @class */ function() {
        function class_1() {}
        class_1.prototype.render = function(model, ctx, container) {
          if (container.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            container = container.childNodes;
          }
          this.$ = $(container);
        };
        return class_1;
      }());
    })();
    (function() {
      (function() {
        Define = {
          create: function(node, model, ctr, Base) {
            return compo_fromNode(node, model, ctr, Base);
          },
          registerGlobal: function(node, model, ctr, Base) {
            var Ctor = Define.create(node, model, ctr, Base);
            customTag_register(node.name, Ctor);
          },
          registerScoped: function(node, model, ctr, Base) {
            var Ctor = Define.create(node, model, ctr, Base);
            customTag_registerScoped(ctr, node.name, Ctor);
          }
        };
        function compo_prototype(node, compoName, tagName, attr, nodes, owner, model, Base) {
          var arr = [];
          var selfFns = null;
          var Proto = obj_extend({
            tagName: tagName,
            compoName: compoName,
            template: arr,
            attr: attr,
            location: trav_location(owner),
            meta: {
              template: 'merge',
              arguments: node.arguments,
              statics: null
            },
            constructor: function DefineBase() {
              if (null != selfFns) {
                var i = selfFns.length;
                while (-1 !== --i) {
                  var key = selfFns[i];
                  this[key] = this[key].bind(this);
                }
              }
            },
            renderStart: function(model_, ctx, el) {
              var model = model_;
              Component.prototype.renderStart.call(this, model, ctx, el);
              if (this.nodes === this.template && 'copy' !== this.meta.template) {
                this.nodes = mask_merge(this.nodes, [], this, null, mergeStats);
                if (mergeStats.placeholders.$isEmpty) {
                  this.meta.template = 'copy';
                }
              }
            },
            getHandler: null
          }, Base);
          Methods.compileForDefine(node, Proto, model, owner);
          var imax = null == nodes ? 0 : nodes.length;
          for (var i = 0; i < imax; i++) {
            var decorators = null;
            var x = nodes[i];
            if (null == x) {
              continue;
            }
            if (x.type === Dom.DECORATOR) {
              var start = i;
              i = Decorator.goToNode(nodes, i, imax);
              decorators = _Array_slice.call(nodes, start, i);
              x = nodes[i];
            }
            var name = x.tagName;
            if ('function' === name) {
              if ('constructor' === name) {
                Proto.constructor = joinFns([ Proto.constructor, x.fn ]);
                continue;
              }
              var fn = x.fn;
              Proto[x.name] = fn;
              if (null != x.decorators) {
                var result = Decorator.wrapMethod(x.decorators, fn, Proto, x.name, model, null, owner);
                if (is_Function(result)) {
                  Proto[x.name] = result;
                }
              }
              if (x.flagSelf) {
                selfFns = selfFns || [];
                selfFns.push(x.name);
              }
              if (x.flagStatic) {
                if (null == Proto.meta.statics) {
                  Proto.meta.statics = {};
                }
                Proto.meta.statics[x.name] = fn;
              }
              continue;
            }
            if ('slot' === name || 'event' === name) {
              if ('event' === name && null != Proto.tagName) {
                // bind the event later via the component
                arr.push(x);
                continue;
              }
              var type = name + 's';
              var fns = Proto[type];
              if (null == fns) {
                fns = Proto[type] = {};
              }
              fns[x.name] = x.flagPrivate ? slot_privateWrap(x.fn) : x.fn;
              if (null != x.decorators) {
                result = Decorator.wrapMethod(x.decorators, x.fn, fns, x.name, model, null, owner);
                if (is_Function(result)) {
                  fns[x.name] = result;
                }
              }
              continue;
            }
            if ('pipe' === name) {
              custom_Tags.pipe.attach(x, Proto);
              continue;
            }
            if ('define' === name || 'let' === name) {
              var register = 'define' === name ? Define.registerGlobal : Define.registerScoped;
              register(x, model, Proto);
              continue;
            }
            if ('var' === name) {
              var key, val, obj = x.getObject(model, null, owner);
              for (key in obj) {
                val = obj[key];
                if ('meta' === key || 'model' === key || 'attr' === key || 'compos' === key) {
                  Proto[key] = obj_extend(Proto[key], val);
                  continue;
                }
                if ('scope' === key) {
                  if (is_Object(val)) {
                    Proto.scope = obj_extend(Proto.scope, val);
                    continue;
                  }
                }
                var scope = Proto.scope;
                if (null == scope) {
                  Proto.scope = scope = {};
                }
                scope[key] = val;
                Proto[key] = val;
              }
              continue;
            }
            if (null != decorators) {
              arr.push.apply(arr, decorators);
            }
            arr.push(x);
          }
          return Proto;
        }
        function compo_extends(extends_, model, ctr) {
          var args = [];
          if (null == extends_) {
            return args;
          }
          var x, imax = extends_.length, i = -1;
          while (++i < imax) {
            x = extends_[i];
            if (x.compo) {
              var compo = customTag_get(x.compo, ctr);
              if (null != compo) {
                args.unshift(compo);
                continue;
              }
              var obj = expression_eval(x.compo, model, null, ctr);
              if (null != obj) {
                args.unshift(obj);
                continue;
              }
              log_error('Nor component, nor scoped data is resolved:', x.compo);
              continue;
            }
          }
          return args;
        }
        function compo_fromNode(node, model, ctr, Base) {
          var tagName, attr, extends_ = node['extends'], as_ = (node['arguments'], node['as']);
          if (null != as_) {
            var x = parser_parse(as_);
            tagName = x.tagName;
            attr = obj_extend(node.attr, x.attr);
          }
          var name = node.name, Proto = compo_prototype(node, name, tagName, attr, node.nodes, ctr, model, Base), args = compo_extends(extends_, model, ctr);
          var Ctor = Component.createExt(Proto, args);
          if (Proto.meta.statics) {
            obj_extend(Ctor, Proto.meta.statics);
          }
          return Ctor;
        }
        function trav_location(ctr) {
          while (null != ctr) {
            if (ctr.location) {
              return ctr.location;
            }
            if (ctr.resource && ctr.resource.location) {
              return ctr.resource.location;
            }
            ctr = ctr.parent;
          }
          return null;
        }
        function slot_privateWrap(fn) {
          return function(mix) {
            if (null != mix && null != mix.stopPropagation) {
              mix.stopPropagation();
            }
            fn.apply(this, arguments);
            return false;
          };
        }
        function joinFns(fns) {
          return function() {
            var args = _Array_slice.call(arguments), imax = fns.length, i = -1;
            while (++i < imax) {
              fns[i].apply(this, args);
            }
          };
        }
        var mergeStats = {
          placeholders: {
            $isEmpty: true
          }
        };
      })();
      custom_Tags['define'] = class_create({
        meta: {
          serializeNodes: true
        },
        constructor: function(node, model, ctx, el, ctr) {
          Define.registerGlobal(node, model, ctr);
        },
        render: fn_doNothing
      });
      custom_Tags['let'] = class_create({
        meta: {
          serializeNodes: true
        },
        constructor: function(node, model, ctx, el, ctr) {
          Define.registerScoped(node, model, ctr);
        },
        render: fn_doNothing
      });
    })();
    (function() {
      var Compo = {
        meta: {
          mode: 'server:all'
        },
        render: function(model, ctx, container) {
          this.html = jMask(this.nodes).text(model, ctx, this);
          if (container.insertAdjacentHTML) {
            container.insertAdjacentHTML('beforeend', this.html);
            return;
          }
          if (container.ownerDocument) {
            var child, div = document.createElement('div');
            div.innerHTML = this.html;
            child = div.firstChild;
            while (null != child) {
              container.appendChild(child);
              child = child.nextSibling;
            }
          }
        },
        toHtml: function() {
          return this.html || '';
        },
        html: null
      };
      customTag_register(':html', Compo);
    })();
    (function() {
      var css_ensureScopedStyles;
      (function() {
        css_ensureScopedStyles = function(str, node, el) {
          var attr = node.attr;
          if (null == attr.scoped && null == attr[KEY]) {
            return str;
          }
          if (false === is_String(str)) {
            error_withNode('Scoped style can`t have interpolations', node);
            return str;
          }
          // Remove `scoped` attribute to exclude supported browsers.
          // Redefine custom attribute to use same template later
                    attr.scoped = null;
          attr[KEY] = 1;
          var id = getScopeIdentity(node, el);
          var str_ = str;
          str_ = transformScopedStyles(str_, id);
          str_ = transformHostCss(str_, id);
          return str_;
        };
        var KEY = 'x-scoped';
        var rgx_selector = /^([\s]*)([^\{\}]+)\{/gm;
        var rgx_host = /^([\s]*):host\s*(\(([^)]+)\))?\s*\{/gm;
        function transformScopedStyles(css, id) {
          return css.replace(rgx_selector, function(full, pref, selector) {
            if (-1 !== selector.indexOf(':host')) {
              return full;
            }
            var arr = selector.split(','), imax = arr.length, i = 0;
            for (;i < imax; i++) {
              arr[i] = id + ' ' + arr[i];
            }
            selector = arr.join(',');
            return pref + selector + '{';
          });
        }
        function transformHostCss(css, id) {
          return css.replace(rgx_host, function(full, pref, ext, expr) {
            return pref + id + (expr || '') + '{';
          });
        }
        function getScopeIdentity(node, el) {
          var identity = 'scoped__css__' + node.id;
          if (el.id) {
            el.className += ' ' + identity;
            return '.' + identity;
          }
          el.setAttribute('id', identity);
          return '#' + identity;
        }
      })();
      var BaseContent = class_create(customTag_Base, {
        meta: {
          mode: 'server'
        },
        tagName: null,
        id: null,
        body: null,
        constructor: function(node, model, ctx, el, ctr) {
          var content = node.content;
          if (null == content && node.nodes) {
            var x = node.nodes[0];
            if (x.type === Dom.TEXTNODE) {
              content = x.content;
            } else {
              content = jMask(x.nodes).text(model, ctr);
            }
          }
          this.id = node.id;
          this.body = is_Function(content) ? content('node', model, ctx, el, ctr) : content;
          if ('style' === this.tagName) {
            this.body = css_ensureScopedStyles(this.body, node, el);
          }
        }
      });
      var GlobalContent = class_create(BaseContent, {
        render: function(model, ctx, el) {
          manager_get(ctx, el).append(this.tagName, this);
        }
      });
      var ElementContent = class_create(BaseContent, {
        render: function(model, ctx, el) {
          render(this.tagName, this.attr, this.body, null, el);
        }
      });
      custom_Tags['style'] = class_create(GlobalContent, {
        tagName: 'style'
      });
      custom_Tags['script'] = class_create(ElementContent, {
        tagName: 'script'
      });
      var manager_get;
      (function() {
        manager_get = function(ctx, el) {
          if (null == ctx || is_DOM) {
            return manager = manager || new Manager(document.body);
          }
          var KEY = '__contentManager';
          return ctx[KEY] || (ctx[KEY] = new Manager(el));
        };
        var manager;
        var Manager = class_create({
          constructor: function(el) {
            this.container = el.ownerDocument.body;
            this.ids = {};
          },
          append: function(tagName, node) {
            var id = node.id;
            var el = this.ids[id];
            if (void 0 !== el) {
              return el;
            }
            el = render(tagName, node.attr, node.body, node.id, this.container);
            this.ids[id] = el;
          }
        });
      })();
      function render(tagName, attr, body, id, container) {
        var el = document.createElement(tagName);
        el.textContent = body;
        for (var key in attr) {
          var val = attr[key];
          if (null != val) {
            el.setAttribute(key, val);
          }
        }
        if (id) {
          el.setAttribute('id', id);
        }
        container.appendChild(el);
        return el;
      }
    })();
    (function() {
      (function() {
        // TODO: refactor methods, use MaskNode Serialization instead Model Serialization
        custom_Tags['var'] = class_create(customTag_Base, {
          renderStart: function(model, ctx) {
            set(this, this.attr, true, model, ctx);
          },
          onRenderStartClient: function() {
            set(this, this.model, false);
          }
        });
        function set(self, source, doEval, model, ctx) {
          // set data also to model, so that it will be serialized in NodeJS
          self.model = {};
          var parent = self.parent;
          var scope = parent.scope;
          if (null == scope) {
            scope = parent.scope = {};
          }
          for (var key in source) {
            self.model[key] = scope[key] = false === doEval ? source[key] : expression_eval(source[key], model, ctx, parent);
          }
        }
      })();
    })();
    (function() {
      var Compo = {
        meta: {
          mode: 'server:all'
        },
        render: function(model, ctx, container, ctr, children) {
          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          for (var key in this.attr) {
            svg.setAttribute(key, this.attr[key]);
          }
          builder_buildSVG(this.nodes, model, ctx, svg, ctr, children);
          container.appendChild(svg);
        }
      };
      customTag_register('svg', Compo);
    })();
  })();
  var mask_run;
  (function() {
    /**
		 * Find all `<script type="text/mask" data-run='true'>` blocks in the page
		 * and render each block into the parents container.
		 *
		 * The function is automatically renders the blocks
		 * `<script type="text/mask" data-run='auto'>` on `DOMContentLoaded` event
		 * @returns {object} Root component
		 * @memberOf mask
		 * @method run
		*/
    mask_run = function() {
      if (0 === _state) {
        _state = _state_All;
      }
      var model, ctx, el, Ctor, args = _Array_slice.call(arguments);
      var mix, imax = args.length, i = -1;
      while (++i < imax) {
        mix = args[i];
        if (mix instanceof Node) {
          el = mix;
          continue;
        }
        if (is_Function(mix)) {
          Ctor = mix;
          continue;
        }
        if (is_Object(mix)) {
          if (null == model) {
            model = mix;
            continue;
          }
          ctx = mix;
        }
      }
      if (null == el) {
        el = document.body;
      }
      if (null == Ctor) {
        Ctor = Compo;
      }
      if (null == model) {
        model = {};
      }
      var ctr = new Ctor(null, model, ctx, el);
      return _run(model, ctx, el, ctr);
    };
    function _run(model, ctx, container, ctr) {
      ctr.ID = ++BuilderData.id;
      var scripts = _Array_slice.call(document.getElementsByTagName('script')), script = null, found = false, ready = false, wait = 0, imax = scripts.length, i = -1;
      while (++i < imax) {
        script = scripts[i];
        var scriptType = script.getAttribute('type');
        if ('text/mask' !== scriptType && 'text/x-mask' !== scriptType) {
          continue;
        }
        var dataRun = script.getAttribute('data-run');
        if (null == dataRun) {
          continue;
        }
        if ('auto' === dataRun) {
          if (false === isCurrent(_state_Auto)) {
            continue;
          }
        }
        if ('true' === dataRun) {
          if (false === isCurrent(_state_Manual)) {
            continue;
          }
        }
        found = true;
        var ctx_ = new builder_Ctx(ctx);
        var fragment = builder_build(parser_parse(script.textContent), model, ctx_, null, ctr);
        if (true === ctx_.async) {
          wait++;
          ctx_.done(resumer);
        }
        script.parentNode.insertBefore(fragment, script);
      }
      if (false === found) {
        if (_state === _state_Auto) {
          return null;
        }
        log_warn('No blocks found: <script type=\'text/mask\' data-run=\'true\'>...<\/script>');
      }
      ready = true;
      if (0 === wait) {
        flush();
      }
      function resumer() {
        if (0 === --wait && ready) {
          flush();
        }
      }
      function flush() {
        if (is_Function(ctr.renderEnd)) {
          ctr.renderEnd(container, model);
        }
        Component.signal.emitIn(ctr, 'domInsert');
      }
      return ctr;
    }
    if (null != document && document.addEventListener) {
      document.addEventListener('DOMContentLoaded', function(event) {
        if (0 !== _state) {
          return;
        }
        var _app;
        _state = _state_Auto;
        _app = mask_run();
        _state = _state_Manual;
        if (null == _app) {
          return;
        }
        if (null == _global.app) {
          _global.app = _app;
          return;
        }
        var source = _app.components;
        if (null == source || 0 === source.length) {
          return;
        }
        var target = _global.app.components;
        if (null == target || 0 === target.length) {
          _global.app.components = source;
          return;
        }
        target.push.apply(target, source);
      });
    }
    var _state_Auto = 2, _state_Manual = 4, _state_All = _state_Auto | _state_Manual, _state = 0;
    function isCurrent(state) {
      return (_state & state) === state;
    }
  })();
  var mask_TreeWalker;
  (function() {
    /**
		 * TreeWalker
		 * @memberOf mask
		 * @name TreeWalker
		 */
    mask_TreeWalker = {
      /**
		     * Visit each mask node
		     * @param {MaskNode} root
		     * @param {TreeWalker~SyncVisitior} visitor
		     * @memberOf mask.TreeWalker
		     */
      walk: function(root, fn) {
        if ('object' === typeof root && root.type === Dom.CONTROLLER) {
          new SyncWalkerCompos(root, fn);
          return root;
        }
        root = prepairRoot(root);
        new SyncWalker(root, fn);
        return root;
      },
      /**
		     * Asynchronous visit each mask node
		     * @param {MaskNode} root
		     * @param {TreeWalker~AsyncVisitior} visitor
		     * @param {function} done
		     * @memberOf mask.TreeWalker
		     */
      walkAsync: function(root, fn, done) {
        root = prepairRoot(root);
        new AsyncWalker(root, fn, done);
      },
      map: function(root, fn) {
        return new SyncMapper().map(root, fn);
      },
      superpose: function(rootA, rootB, fn) {
        return new SyncSuperposer().join(rootA, rootB, fn);
      }
    };
    var SyncWalker, SyncWalkerCompos;
    (function() {
      SyncWalker = function(root, fn) {
        walk(root, fn);
      };
      SyncWalkerCompos = function(root, fn) {
        walkCompos(root, fn, root);
      };
      function walk(node, fn, parent, index) {
        if (null == node) {
          return null;
        }
        var mod, deep = true, break_ = false;
        if (true !== isFragment(node)) {
          mod = fn(node);
        }
        if (void 0 !== mod) {
          mod = new Modifier(mod);
          mod.process(new Step(node, parent, index));
          deep = mod.deep;
          break_ = mod['break'];
        }
        var nodes = safe_getNodes(node);
        if (null == nodes || false === deep || true === break_) {
          return mod;
        }
        var x, imax = nodes.length, i = 0;
        for (;i < imax; i++) {
          x = nodes[i];
          mod = walk(x, fn, node, i);
          if (null != mod && true === mod['break']) {
            return mod;
          }
        }
      }
      function walkCompos(compo, fn, parent, index) {
        if (null == compo) {
          return;
        }
        var mod = fn(compo, index);
        if (void 0 !== mod) {
          if (false === mod.deep || true === mod['break']) {
            return mod;
          }
        }
        var compos = compo.components;
        if (null == compos) {
          return null;
        }
        var x, imax = compos.length, i = 0;
        for (;i < imax; i++) {
          x = compos[i];
          mod = walkCompos(x, fn, compo, i);
          if (null != mod && true === mod['break']) {
            return mod;
          }
        }
      }
    })();
    var AsyncWalker;
    (function() {
      AsyncWalker = function(root, fn, done) {
        this.stack = [];
        this.done = done;
        this.root = root;
        this.fn = fn;
        this.process = this.process.bind(this);
        this.visit(this.push(root));
      };
      AsyncWalker.prototype = {
        current: function() {
          return this.stack[this.stack.length - 1];
        },
        push: function(node, parent, index) {
          var step = new Step(node, parent, index);
          this.stack.push(step);
          return step;
        },
        pop: function() {
          return this.stack.pop();
        },
        getNext: function(goDeep) {
          var current = this.current(), node = current.node, nodes = safe_getNodes(node);
          if (null == node) {
            throw Error('Node is null');
          }
          if (null != nodes && false !== goDeep && 0 !== nodes.length) {
            if (null == nodes[0]) {
              throw Error('Node is null');
            }
            return this.push(nodes[0], node, 0);
          }
          var parent, index;
          while (0 !== this.stack.length) {
            current = this.pop();
            parent = current.parent;
            index = current.index;
            if (null == parent) {
              this.pop();
              continue;
            }
            if (++index < parent.nodes.length) {
              return this.push(parent.nodes[index], parent, index);
            }
          }
          return null;
        },
        process: function(mod) {
          var deep = true, break_ = false;
          if (void 0 !== mod) {
            mod = new Modifier(mod);
            mod.process(this.current());
            deep = mod.deep;
            break_ = mod['break'];
          }
          var next = true === break_ ? null : this.getNext(deep);
          if (null == next) {
            this.done(this.root);
            return;
          }
          this.visit(next);
        },
        visit: function(step) {
          var node = step.node;
          if (false === isFragment(node)) {
            this.fn(node, this.process);
            return;
          }
          this.process();
        },
        fn: null,
        done: null,
        stack: null
      };
    })();
    var Modifier;
    (function() {
      /**
		     * @name IModifier
		     * @memberOf TreeWalker
		     */
      Modifier = function(mod, step) {
        for (var key in mod) {
          this[key] = mod[key];
        }
      };
      Modifier.prototype = {
        /**
		         * On `true` stops the walker
		         */
        break: false,
        /**
		         * On `false` doesn't visit the subnodes
		         */
        deep: true,
        /**
		         * On `true` removes current node
		         */
        remove: false,
        /**
		         * On not `null`, replaces the current node with value
		         */
        replace: null,
        process: function(step) {
          if (null != this.replace) {
            this.deep = false;
            step.parent.nodes[step.index] = this.replace;
            return;
          }
          if (true === this.remove) {
            this.deep = false;
            var arr = step.parent.nodes, i = step.index;
            _Array_splice.call(arr, i, 1);
            return;
          }
        }
      };
    })();
    var SyncMapper;
    (function() {
      SyncMapper = class_create({
        map: function(node, fn) {
          var mapper = getMapper(node);
          return mapper(node, fn);
        }
      });
      function getMapper(node) {
        /* not strict */
        if (node.compoName) {
          return mapCompo;
        }
        return mapNode;
      }
      function mapNode(node, fn, parent, index) {
        if (null == node) {
          return null;
        }
        var nextNode = isFragment(node) ? new Dom.Fragment() : fn(node);
        if (null == nextNode) {
          return null;
        }
        var nodes = safe_getNodes(node);
        if (null == nodes) {
          return nextNode;
        }
        nextNode.nodes = coll_map(nodes, function(x) {
          return mapNode(x, fn, node);
        });
        return nextNode;
      }
      function mapCompo(compo, fn, parent) {
        if (null == compo) {
          return null;
        }
        var next = fn(compo);
        if (null == next || null == compo.components) {
          return next;
        }
        next.components = coll_map(compo.components, function(x) {
          return mapCompo(x, fn, compo);
        });
        return next;
      }
    })();
    var SyncSuperposer;
    (function() {
      SyncSuperposer = class_create({
        join: function(rootA, rootB, fn) {
          var superposer = getSuperposer(rootA);
          return superposer(rootA, rootB, fn);
        }
      });
      function getSuperposer(node) {
        /* not strict */
        if (node.compoName) {
          return superposeCompos;
        }
        return superposeNodes;
      }
      function superposeNodes(nodeA, nodeB, fn) {
        var typeA = safe_getType(nodeA), typeB = safe_getType(nodeB);
        if (typeA !== typeB) {
          return;
        }
        if (typeA !== Dom.FRAGMENT) {
          fn(nodeA, nodeB);
        }
        var arrA = safe_getNodes(nodeA), arrB = safe_getNodes(nodeB);
        if (null == arrA || null == arrB) {
          return;
        }
        var aL = arrA.length, bL = arrB.length, i = -1;
        while (++i < aL && i < bL) {
          var a = arrA[i], b = arrB[i];
          if (null != a.tagName && a.tagName !== b.tagName) {
            continue;
          }
          superposeNodes(a, b, fn);
        }
        return nodeA;
      }
      function superposeCompos(compoA, compoB, fn) {
        fn(compoA, compoB);
        var arrA = compoA.components, arrB = compoB.components;
        if (null == arrA || null == arrB) {
          return;
        }
        var aL = arrA.length, bL = arrB.length, i = -1;
        while (++i < aL && i < bL) {
          var a = arrA[i], b = arrB[i];
          if (null != a.compoName && a.compoName !== b.compoName) {
            continue;
          }
          superposeCompos(a, b, fn);
        }
      }
    })();
    var Step = function(node, parent, index) {
      this.node = node;
      this.index = index;
      this.parent = parent;
    };
    /* UTILS */    function isFragment(node) {
      return Dom.FRAGMENT === safe_getType(node);
    }
    function safe_getNodes(node) {
      var nodes = node.nodes;
      if (null == nodes) {
        return null;
      }
      return is_Array(nodes) ? nodes : node.nodes = [ nodes ];
    }
    function safe_getType(node) {
      var type = node.type;
      if (null != type) {
        return type;
      }
      if (is_Array(node)) {
        return Dom.FRAGMENT;
      }
      if (null != node.tagName) {
        return Dom.NODE;
      }
      if (null != node.content) {
        return Dom.TEXTNODE;
      }
      return Dom.NODE;
    }
    function prepairRoot(root) {
      if ('string' === typeof root) {
        root = parser_parse(root);
      }
      if (false === isFragment(root)) {
        var fragment = new Dom.Fragment();
        fragment.appendChild(root);
        root = fragment;
      }
      return root;
    }
    /**
		 * Is called on each node
		 * @callback TreeWalker~SyncVisitor
		 * @param {MaskNode} node
		 * @returns {Modifier|void}
		 */
    /**
		 * Is called on each node
		 * @callback TreeWalker~AsyncVisitor
		 * @param {MaskNode} node
		 * @param {function} done - Optional pass @see{@link TreeWalker.IModifier} to the callback
		 * @returns {void}
		 */  })();
  var mask_optimize, mask_registerOptimizer;
  (function() {
    /**
		 * Run all registerd optimizers recursively on the nodes
		 * @param {MaskNode} node
		 * @param {function} onComplete
		 * @param {mask.optimize~onComplete} done
		 */
    mask_optimize = function(dom, done) {
      mask_TreeWalker.walkAsync(dom, function(node, next) {
        var fn = getOptimizer(node);
        if (null != fn) {
          fn(node, next);
          return;
        }
        next();
      }, done);
    };
    /**
		 * Register custom optimizer for a node name
		 * @param {string} tagName - Node name
		 * @param {function} visitor - Used for @see {@link mask.TreeWalker.walkSync}
		 */    mask_registerOptimizer = function(tagName, fn) {
      custom_Optimizers[tagName] = fn;
    };
    function getOptimizer(node) {
      return custom_Optimizers[node.tagName];
    }
    /**
		 * Returns optimized mask tree
		 * @callback mask.optimize~onComplete
		 * @param {MaskNode} node
		 */  })();
  var Module;
  (function() {
    var m_Types, _opts, path_getDir, path_getExtension, path_fromPrfx, path_appendQuery, path_resolveCurrent, path_normalize, path_resolveUrl, path_isRelative, path_combine;
    var _file_get, _file_getScript, _file_getStyle, _file_getJson;
    (function() {
      (function() {
        path_getDir = function(path) {
          return path.substring(0, path.lastIndexOf('/') + 1);
        };
        path_getExtension = function(path) {
          var query = path.indexOf('?');
          if (-1 !== query) {
            path = path.substring(0, query);
          }
          var match = rgx_EXT.exec(path);
          return null == match ? '' : match[1];
        };
        path_fromPrfx = function(path, prefixes) {
          var i = path.indexOf('/');
          if (-1 === i) {
            i = path.length;
          }
          var prfx = path.substring(1, i);
          var sfx = path.substring(i + 1);
          var route = prefixes[prfx];
          if (null == route) {
            return null;
          }
          if (1 === route.indexOf('{')) {
            return path_combine(route, sfx);
          }
          var routeArr = route.split('{'), sfxArr = sfx.split('/'), sfxArrL = sfxArr.length, imax = routeArr.length;
          i = 0;
          while (++i < imax) {
            var x = routeArr[i];
            var end = x.indexOf('}');
            var num = 0 | x.substring(0, end);
            var y = num < sfxArrL ? sfxArr[num] : sfxArr[sfxArrL - 1];
            if (i === imax - 1 && i < sfxArr.length) {
              y = path_combine(y, sfxArr.slice(i).join('/'));
            }
            routeArr[i] = (y || '') + x.substring(end + 1);
          }
          return path_combine.apply(null, routeArr);
        };
        path_appendQuery = function(path, key, val) {
          var conjunctor = -1 === path.indexOf('?') ? '?' : '&';
          return path + conjunctor + key + '=' + val;
        };
        path_resolveCurrent = function() {
          var current_;
          //#if (BROWSER)
                    return function() {
            if (null != current_) {
              return current_;
            }
            if (null == _document) {
              return '';
            }
            var fn = 'baseURI' in _document ? fromBase : fromBaseTag;
            return current_ = path_sliceFilename(fn());
          };
          function fromBase() {
            var path = _global.document.baseURI;
            var i = path.indexOf('?');
            return -1 === i ? path : path.substring(0, i);
          }
          function fromLocation() {
            return _global.location.origin + _global.location.pathname;
          }
          function fromBaseTag() {
            var h = _global.document.head;
            if (null == h) {
              return fromLocation();
            }
            var b = h.querySelector('base');
            if (null == b) {
              return fromLocation();
            }
            return b.href;
          }
          //#endif
                }();
        (function() {
          var root_;
          //#if (BROWSER)
                    return;
          function fromBase() {
            var path = _global.document.baseURI;
            var protocol = /^\w+:\/+/.exec(path);
            var i = path.indexOf('/', protocol && protocol[0].length);
            return -1 === i ? path : path.substring(0, i);
          }
          function fromLocation() {
            return _global.location.origin;
          }
          // endif
                })();
        path_normalize = function(path) {
          var path_ = path.replace(/\\/g, '/').replace(/([^:\/])\/{2,}/g, '$1/').replace(/^\.\//, '').replace(/\/\.\//g, '/');
          return path_collapse(path_);
        };
        path_resolveUrl = function(path, base) {
          var url = path_normalize(path);
          if (path_isRelative(url)) {
            return path_normalize(path_combine(base || path_resolveCurrent(), url));
          }
          if (rgx_PROTOCOL.test(url)) {
            return url;
          }
          if (47 /*/*/ === url.charCodeAt(0)) {
            if (__cfg.base) {
              return path_combine(__cfg.base, url);
            }
          }
          return url;
        };
        path_isRelative = function(path) {
          var c = path.charCodeAt(0);
          switch (c) {
           case 46:
            /* . */
            return true;

           case 47:
            /* / */
            return false;
          }
          return false === rgx_PROTOCOL.test(path);
        };
        path_combine = function(a, b, c, d, e) {
          var x, out = '', imax = arguments.length, i = -1;
          while (++i < imax) {
            x = arguments[i];
            if (!x) {
              continue;
            }
            x = path_normalize(x);
            if ('' === out) {
              out = x;
              continue;
            }
            if ('/' !== out[out.length - 1]) {
              out += '/';
            }
            if ('/' === x[0]) {
              x = x.substring(1);
            }
            out += x;
          }
          return path_collapse(out);
        };
        var rgx_PROTOCOL = /^[\w\-]{2,}:\/\//i, rgx_SUB_DIR = /[^\/\.]+\/\.\.\//, rgx_FILENAME = /\/[^\/]+\.\w+(\?.*)?(#.*)?$/, rgx_EXT = /\.(\w+)$/;
        function path_collapse(url_) {
          var url = url_;
          while (rgx_SUB_DIR.test(url)) {
            url = url.replace(rgx_SUB_DIR, '');
          }
          return url;
        }
        function path_ensureTrailingSlash(path) {
          if (47 /* / */ === path.charCodeAt(path.length - 1)) {
            return path;
          }
          return path + '/';
        }
        function path_sliceFilename(path) {
          return path_ensureTrailingSlash(path.replace(rgx_FILENAME, ''));
        }
      })();
      var file_get, file_getScript, file_getStyle, file_getJson;
      (function() {
        var script_get, style_get, xhr_get;
        (function() {
          (function() {
            xhr_get = function(path, cb) {
              var xhr = new XMLHttpRequest();
              xhr.onreadystatechange = function() {
                if (4 !== xhr.readyState) {
                  return;
                }
                var err, errMsg, res = xhr.responseText, status = xhr.status;
                if (0 !== status && 200 !== status) {
                  errMsg = res || xhr.statusText;
                }
                if (0 === status && '' === res) {
                  errMsg = res || xhr.statusText || 'File is not accessible';
                }
                if (null != errMsg) {
                  err = {
                    status: status,
                    content: errMsg
                  };
                }
                cb(err, res);
              };
              xhr.open('GET', path, true);
              xhr.send();
            };
          })();
          (function() {
            style_get = function(path, cb) {
              embedStyle(path);
              // do not wait for the load event
                            cb();
            };
            function embedStyle(url, callback) {
              var tag = document.createElement('link');
              tag.rel = 'stylesheet';
              tag.href = url;
              if ('onreadystatechange' in tag) {
                tag.onreadystatechange = function() {
                  ('complete' === this.readyState || 'loaded' === this.readyState) && callback();
                };
              } else {
                tag.onload = tag.onerror = callback;
              }
              if (void 0 === _head) {
                _head = document.getElementsByTagName('head')[0];
              }
              _head.appendChild(tag);
            }
            var _head;
          })();
          (function() {
            script_get = function(path, cb) {
              var res = new Resource(path).done(function(exports) {
                cb(null, exports);
              }).fail(function(err) {
                cb(err);
              });
              ScriptStack.load(res);
            };
            var Resource = class_create(class_Dfr, {
              exports: null,
              url: null,
              state: 0,
              constructor: function(url) {
                this.url = url;
              },
              load: function() {
                if (0 !== this.state) {
                  return this;
                }
                this.state = 1;
                _global.module = {};
                var self = this;
                embedScript(this.url, function(event) {
                  self.state = 4;
                  if (event && 'error' === event.type) {
                    self.reject(event);
                    return;
                  }
                  self.resolve(self.exports = _global.module.exports);
                });
                return this;
              }
            });
            var ScriptStack;
            (function() {
              ScriptStack = {
                load: function(resource) {
                  _stack.push(resource);
                  process();
                }
              };
              var _stack = [];
              function process() {
                if (0 === _stack.length) {
                  return;
                }
                var res = _stack[0];
                if (0 !== res.state) {
                  return;
                }
                res.load().always(function() {
                  _stack.shift();
                  process();
                });
              }
            })();
            var embedScript;
            (function() {
              embedScript = function(url, callback) {
                var tag = document.createElement('script');
                tag.type = 'text/javascript';
                tag.src = url;
                if ('onreadystatechange' in tag) {
                  tag.onreadystatechange = function() {
                    ('complete' === this.readyState || 'loaded' === this.readyState) && callback();
                  };
                } else {
                  tag.onload = tag.onerror = callback;
                }
                if (void 0 === _head) {
                  _head = document.getElementsByTagName('head')[0];
                }
                _head.appendChild(tag);
              };
              var _head;
            })();
          })();
          //#if (BROWSER)
          //#endif
                })();
        var json_get;
        (function() {
          json_get = function(path, cb) {
            xhr_get(path, function(error, str) {
              if (error) {
                cb(error);
                return;
              }
              var json;
              try {
                json = JSON.parse(str);
              } catch (error) {
                cb('JSON error: ' + String(error));
                return;
              }
              cb(null, json);
            });
          };
        })();
        file_get = function(path, ctr) {
          return get(xhr_get, path, ctr);
        };
        file_getScript = function(path, ctr) {
          return get(script_get, path, ctr);
        };
        file_getStyle = function(path, ctr) {
          return get(style_get, path, ctr);
        };
        file_getJson = function(path, ctr) {
          return get(json_get, path, ctr);
        };
        function get(fn, path, ctr) {
          var url = path_resolveUrl(path, Module.resolveLocation(ctr));
          if (url in Cache) {
            return Cache[url];
          }
          var dfr = Cache[url] = new class_Dfr();
          fn(url, dfr.pipeCallback());
          return dfr;
        }
        var Cache = Object.create(null);
      })();
      (function() {
        _opts = {
          base: null,
          nsBase: '/',
          version: null,
          es6Modules: false,
          moduleResolution: 'classic',
          ext: {
            mask: 'mask',
            script: 'js',
            style: 'js'
          },
          prefixes: {}
        };
      })();
      _file_get = createTransport(function() {
        return __cfg.getFile || file_get;
      });
      _file_getScript = createTransport(function() {
        return __cfg.getScript || file_getScript;
      });
      _file_getStyle = createTransport(function() {
        return __cfg.getStyle || file_getStyle;
      });
      _file_getJson = createTransport(function() {
        return __cfg.getJson || __cfg.getData || file_getJson;
      });
      listeners_on('config', function(config) {
        var modules = config.modules;
        if (null == modules) {
          return;
        }
        var fn = Loaders[modules];
        if (false === is_Function(fn)) {
          log_warn('Module system is not supported: ' + modules);
          return;
        }
        fn();
      });
      function createTransport(loaderFactoryFn) {
        return function(path_) {
          var fn = loaderFactoryFn(), path = path_, v = _opts.version;
          if (null != v) {
            path = path_appendQuery(path, 'v', v);
          }
          return fn(path);
        };
      }
      var Loaders = {
        default: function() {
          __cfg.getScript = __cfg.getFile = __cfg.getStyle = null;
        },
        include: function() {
          __cfg.getScript = getter('js');
          __cfg.getStyle = getter('css');
          __cfg.getFile = getter('load');
          var lib = include;
          function getter(name) {
            return function(path) {
              return class_Dfr.run(function(resolve, reject) {
                lib.instance('/')[name](path + '::Module').done(function(resp) {
                  if ('css' === name) {
                    return resolve();
                  }
                  if ('js' === name) {
                    return resolve(resp.Module);
                  }
                  resolve(resp[name].Module);
                });
              });
            };
          }
        }
      };
      if ('undefined' !== typeof include && is_Function(include && include.js)) {
        mask_config('modules', 'include');
      }
    })();
    var u_resolveLocation, u_setOption, u_resolvePath, u_resolvePathFromImport, u_isNpmPath, u_resolveNpmPath;
    (function() {
      u_resolveLocation = function(ctx, ctr, module) {
        if (null != module) {
          return module.location;
        }
        while (null != ctr) {
          if (null != ctr.location) {
            return ctr.location;
          }
          if (null != ctr.resource && ctr.resource.location) {
            return ctr.resource.location;
          }
          ctr = ctr.parent;
        }
        var path = null;
        if (null != ctx) {
          if (null != ctx.filename) {
            path = path_getDir(path_normalize(ctx.filename));
          }
          if (null != ctx.dirname) {
            path = path_normalize(ctx.dirname + '/');
          }
        }
        if (null == path) {
          return path_resolveCurrent();
        }
        if (false === path_isRelative(path)) {
          return path;
        }
        return path_combine(u_resolveBase(), path);
      };
      u_setOption = function(options, key, val) {
        if ('base' === key || 'nsBase' === key) {
          var path = path_normalize(val);
          if ('/' !== path[path.length - 1]) {
            path += '/';
          }
          // Do not resolve root, as it will be resolved by base later
          // @NextIteration: remove also path_resolveRoot, use instead resolveCurrent
          // if (path[0] === '/') {
          // 	path = path_combine(path_resolveRoot(), path);
          // }
                    options[key] = path;
          return this;
        }
        var current = obj_getProperty(options, key);
        if (is_Object(current) && is_Object(val)) {
          obj_extend(current, val);
          return this;
        }
        obj_setProperty(options, key, val);
      };
      function u_resolveBase() {
        if (null == _opts.base) {
          _opts.base = path_resolveCurrent();
        } else if (true === path_isRelative(_opts.base)) {
          _opts.base = path_combine(path_resolveCurrent(), _opts.base);
        }
        return _opts.base;
      }
      u_resolvePath = function(path, ctx, ctr, module) {
        if (false === hasExt(path)) {
          path += '.mask';
        }
        return toAbsolute(path, ctx, ctr, module);
      };
      u_resolvePathFromImport = function(node, ctx, ctr, module, makeAbs) {
        var path = node.path;
        if (null == path && null != node.namespace) {
          path = fromNs(node);
        }
        if ('@' === path[0]) {
          path = path_fromPrfx(path, _opts.prefixes);
          if (null == path) {
            path = node.path;
            warn_withNode('Prefix not defined: ' + path, node);
          }
        }
        if ('/' === path[path.length - 1] && null != node.exports) {
          path += node.exports[0].name;
        }
        if (false === hasExt(path)) {
          var c = path.charCodeAt(0);
          if (47 === c || 46 === c) {
            // / .
            var type = node.contentType;
            if (null == type || 'mask' === type) {
              path += '.mask';
            }
          } else if (u_isNpmPath(path)) {
            return path;
          }
        }
        return false === makeAbs ? path : toAbsolute(path, ctx, ctr, module);
      };
      u_isNpmPath = function(path) {
        return 'node' === _opts.moduleResolution && /^([\w\-]+)(\/[\w\-_]+)*$/.test(path);
      };
      function toAbsolute(path_, ctx, ctr, module) {
        var path = path_;
        if (path_isRelative(path)) {
          path = path_combine(u_resolveLocation(ctx, ctr, module), path);
        } else if (47 /*/*/ === path.charCodeAt(0)) {
          path = path_combine(u_resolveBase(), path);
        }
        return path_normalize(path);
      }
      function hasExt(path) {
        return '' !== path_getExtension(path);
      }
      function fromNs(node) {
        var type = node.contentType || 'script';
        var path = node.namespace.replace(/\./g, '/');
        if ('/' === path[0]) {
          path = '.' + path;
        } else {
          var base = _opts.nsBase;
          if (null != base) {
            path = path_combine(base, path);
          }
        }
        var exports = node.exports;
        if (null == exports) {
          path += '/' + node.alias;
        } else if (1 === exports.length) {
          var exp = exports[0];
          var name = exp.name;
          path += '/' + name;
          if ('script' === type && true !== _opts.es6Modules) {
            node.alias = exp.alias || name;
            node.exports = null;
          }
        }
        var default_ = _opts.ext[type] || type;
        path += '.' + default_;
        return path;
      }
      u_resolveNpmPath = function(contentType, path, parentLocation, cb) {
        var name = /^([\w\-]+)/.exec(path)[0];
        var resource = path.substring(name.length + 1);
        if (resource && false === hasExt(resource)) {
          resource += '.' + _ext[contentType];
        }
        var root = '';
        var domainMatch = /(\w{2,5}:\/{2,3}[^/]+)/.exec(parentLocation);
        if (domainMatch) {
          root = domainMatch[0];
          parentLocation = parentLocation.substring(root.length);
        }
        var nodeModules, current = parentLocation, lookups = [];
        function check() {
          nodeModules = path_combine(root, current, '/node_modules/', name, '/');
          lookups.unshift(path_combine(nodeModules, 'package.json'));
          _file_get(lookups[0]).then(function(text) {
            onComplete(null, text);
          }, onComplete);
        }
        function onComplete(error, text) {
          var json;
          if (text) {
            try {
              json = JSON.parse(text);
            } catch (error) {}
          }
          if (null != error || null == json) {
            var next = current.replace(/[^\/]+\/?$/, '');
            if (next === current) {
              cb('Module was not resolved: ' + lookups.join(','));
              return;
            }
            current = next;
            check();
            return;
          }
          if (resource) {
            cb(null, nodeModules + resource);
            return;
          }
          var filename;
          if ('mask' === contentType && json.mainMask) {
            filename = json.mainMask;
          } else if ('js' === contentType && json.main) {
            filename = json.main;
          } else {
            filename = 'index.' + _ext[contentType];
          }
          cb(null, path_combine(nodeModules, filename));
        }
        check();
      };
      var _ext = {
        js: 'js',
        mask: 'mask',
        css: 'css'
      };
    })();
    var _typeMappings, type_isMask, type_get, type_getModuleType;
    (function() {
      _typeMappings = {
        script: 'script',
        style: 'style',
        data: 'data',
        mask: 'mask',
        html: 'html',
        js: 'script',
        ts: 'script',
        es6: 'script',
        coffee: 'script',
        css: 'style',
        scss: 'style',
        sass: 'style',
        less: 'style',
        json: 'data',
        yml: 'data',
        txt: 'text',
        text: 'text',
        load: 'text'
      };
      type_isMask = function(endpoint) {
        var type = endpoint.contentType, ext = type || path_getExtension(endpoint.path);
        return '' === ext || 'mask' === ext || 'html' === ext;
      };
      type_get = function(endpoint) {
        var type = endpoint.contentType;
        if (null == type && null != endpoint.moduleType) {
          var x = _typeMappings[endpoint.moduleType];
          if (null != x) {
            return x;
          }
        }
        var ext = type || path_getExtension(endpoint.path);
        if ('' === ext || 'mask' === ext) {
          return 'mask';
        }
        return _typeMappings[ext];
      };
      type_getModuleType = function(endpoint) {
        return endpoint.moduleType || type_get(endpoint);
      };
    })();
    var cache_get, cache_set, cache_clear;
    (function() {
      var _cache = {};
      cache_get = function(endpoint) {
        return ensure(endpoint)[endpoint.path];
      };
      cache_set = function(endpoint, module) {
        return ensure(endpoint)[endpoint.path] = module;
      };
      cache_clear = function(path) {
        if (null == path) {
          _cache = {};
          return;
        }
        for (var x in _cache) {
          delete _cache[x][path];
        }
      };
      function ensure(endpoint) {
        var type = type_getModuleType(endpoint);
        var hash = _cache[type];
        if (null == hash) {
          hash = _cache[type] = {};
        }
        return hash;
      }
    })();
    var tools_getDependencies;
    (function() {
      tools_getDependencies = function(template, path, opts_) {
        var opts = obj_extendDefaults(opts_, defaultOptions);
        var dfr = new class_Dfr();
        var ast = 'string' === typeof template ? parser_parse(template) : template;
        return get(ast, path, opts, dfr);
      };
      var defaultOptions = {
        deep: true,
        flattern: false
      };
      function get(ast, path, opts, dfr) {
        walk(ast, path, opts, function(error, dep) {
          if (error) {
            return dfr.reject(error);
          }
          if (true === opts.flattern && true === opts.deep) {
            dep = flattern(dep);
          }
          dfr.resolve(dep);
        });
        return dfr;
      }
      function walk(ast, path, opts, done) {
        var location = path_getDir(path);
        var dependency = {
          mask: [],
          data: [],
          style: [],
          script: []
        };
        mask_TreeWalker.walkAsync(ast, visit, complete);
        function visit(node, next) {
          if ('import' !== node.tagName) {
            return next();
          }
          var path = resolvePath(node, location);
          var type = type_get(node);
          if (false === opts.deep) {
            dependency[type].push(path);
            return next();
          }
          if ('mask' === type) {
            getMask(path, opts, function(error, dep) {
              if (error) {
                return done(error);
              }
              dependency.mask.push(dep);
              next();
            });
            return;
          }
          dependency[type].push(path);
          next();
        }
        function complete() {
          done(null, dependency);
        }
      }
      function getMask(path, opts, done) {
        var dep = {
          path: path,
          dependencies: null
        };
        _file_get(path).done(function(template) {
          walk(parser_parse(template), path, opts, function(error, deps) {
            if (error) {
              done(error);
              return;
            }
            dep.dependencies = deps;
            done(null, dep);
          });
        }).fail(done);
      }
      function resolvePath(node, location) {
        var path = node.path, type = node.contentType;
        if ((null == type || 'mask' === type) && '' === path_getExtension(path)) {
          path += '.mask';
        }
        if (path_isRelative(path)) {
          path = path_combine(location, path);
        }
        return path_normalize(path);
      }
      var flattern;
      (function() {
        flattern = function(deps) {
          return {
            mask: resolve(deps, 'mask'),
            data: resolve(deps, 'data'),
            style: resolve(deps, 'style'),
            script: resolve(deps, 'script')
          };
        };
        function resolve(deps, type) {
          return distinct(get(deps, type, []));
        }
        function get(deps, type, stack) {
          if (null == deps) {
            return stack;
          }
          var x, arr = deps[type], imax = arr.length, i = -1;
          while (++i < imax) {
            x = arr[i];
            if ('string' === typeof x) {
              stack.unshift(x);
              continue;
            }
            // assume is an object { path, dependencies[] }
                        stack.unshift(x.path);
            get(x.dependencies, type, stack);
          }
          if ('mask' !== type) {
            deps.mask.forEach(function(x) {
              get(x.dependencies, type, stack);
            });
          }
          return stack;
        }
        function distinct(stack) {
          for (var i = 0; i < stack.length; i++) {
            for (var j = i + 1; j < stack.length; j++) {
              if (stack[i] === stack[j]) {
                stack.splice(j, 1);
                j--;
              }
            }
          }
          return stack;
        }
      })();
    })();
    var tools_build;
    (function() {
      tools_build = function(template, path, opts_) {
        var opts = obj_extendDefaults(opts_, optionsDefault);
        return class_Dfr.run(function(resolve, reject) {
          tools_getDependencies(template, path, {
            flattern: true
          }).fail(reject).done(function(deps) {
            build(deps, opts, complete, reject);
          });
          function complete(out) {
            out.mask += '\n' + template;
            resolve(out);
          }
        });
      };
      var optionsDefault = {
        minify: false
      };
      function build(deps, opts, resolve, reject) {
        var types = [ 'mask', 'script', 'style', 'data' ];
        var out = {
          mask: '',
          data: '',
          style: '',
          script: ''
        };
        function next() {
          if (0 === types.length) {
            if (out.data) {
              out.script = out.data + '\n' + out.script;
            }
            return resolve(out);
          }
          var type = types.shift();
          build_type(deps, type, opts, function(error, str) {
            if (error) {
              return reject(error);
            }
            out[type] = str;
            next();
          });
        }
        next();
      }
      function build_type(deps, type, opts, done) {
        var arr = deps[type], imax = arr.length, i = -1, stack = [];
        function next() {
          if (++i === imax) {
            done(null, stack.join('\n'));
            return;
          }
          Single[type](arr[i], opts).fail(done).done(function(str) {
            stack.push('/* source ' + arr[i] + ' */');
            stack.push(str);
            next();
          });
        }
        next();
      }
      var Single = {
        mask: function(path, opts, done) {
          return class_Dfr.run(function(resolve, reject) {
            _file_get(path).fail(reject).done(function(str) {
              // remove all remote styles
              var ast = mask_TreeWalker.walk(str, function(node) {
                if ('link' === node.tagName && node.attr.href) {
                  return {
                    remove: true
                  };
                }
              });
              ast = jMask('module').attr('path', path).append(ast);
              str = mask_stringify(ast[0], {
                indent: opts.minify ? 0 : 4
              });
              resolve(str);
            });
          });
        },
        script: function(path, opts) {
          return (__cfg.buildScript || build_script)(path, opts);
        },
        style: function(path, opts) {
          return (__cfg.buildStyle || build_style)(path, opts);
        },
        data: function(path, opts) {
          return (__cfg.buildData || build_data)(path, opts);
        }
      };
      function build_script(path, opts, done) {
        return class_Dfr.run(function(resolve, reject) {
          _file_get(path).fail(reject).done(function(str) {
            var script = 'var module = { exports: null }\n';
            script += str + ';\n';
            script += 'mask.Module.registerModule(module.exports, new mask.Module.Endpoint("' + path + '", "script"))';
            resolve(script);
          });
        });
      }
      function build_style(path, opts) {
        return _file_get(path);
      }
      function build_data(path, opts, done) {
        return class_Dfr.run(function(resolve, reject) {
          _file_get(path).fail(reject).done(function(mix) {
            var json;
            try {
              json = 'string' === typeof mix ? JSON.parse(mix) : mix;
            } catch (error) {
              reject(error);
              return;
            }
            var str = JSON.stringify(json, null, opts.minify ? 4 : void 0);
            var script = 'module = { exports: ' + str + ' }\nmask.Module.registerModule(module.exports, new mask.Module.Endpoint("' + path + '", "json"))';
            resolve(script);
          });
        });
      }
    })();
    var IModule;
    (function() {
      IModule = class_create(class_Dfr, {
        type: null,
        path: null,
        location: null,
        exports: null,
        state: 0,
        constructor: function(path, parent) {
          this.path = path;
          this.parent = parent;
          this.exports = {};
          this.location = path_getDir(path);
          this.complete_ = this.complete_.bind(this);
        },
        loadModule: function() {
          if (0 !== this.state) {
            return this;
          }
          this.state = 1;
          var self = this;
          if (u_isNpmPath(this.path)) {
            u_resolveNpmPath(this.type, this.path, this.parent.location, function(err, path) {
              if (null != err) {
                self.onLoadError_(err);
                return;
              }
              self.location = path_getDir(path);
              self.path = path;
              self.doLoad();
            });
            return this;
          }
          self.doLoad();
          return this;
        },
        doLoad: function() {
          var _this = this;
          this.load_(this.path).then(function(mix) {
            return _this.onLoadSuccess_(mix);
          }, function(err) {
            return _this.onLoadError_(err);
          });
        },
        complete_: function(error, exports) {
          this.exports = exports;
          this.error = error;
          this.state = 4;
          if (error) {
            this.reject(error);
            return;
          }
          this.resolve(this);
        },
        onLoadSuccess_: function(mix) {
          if (null == this.preprocess_) {
            this.complete_(null, mix);
            return;
          }
          this.preprocess_(mix, this.complete_);
        },
        onLoadError_: function(error) {
          if (null == this.preprocessError_) {
            this.complete_(error);
            return;
          }
          this.preprocessError_(error, this.complete_);
        },
        load_: null,
        preprocess_: null,
        preprocessError_: null,
        register: fn_doNothing,
        getExport: function(property) {
          var obj = this.exports;
          return '*' !== property ? obj_getProperty(obj, property) : obj;
        }
      });
    })();
    var Endpoint;
    (function() {
      Endpoint = /** @class */ function() {
        function Endpoint(path, contentType, moduleType) {
          this.path = path;
          this.contentType = contentType;
          this.moduleType = moduleType;
        }
        return Endpoint;
      }();
    })();
    var i_createImport;
    (function() {
      var IImport, i_Types;
      var ImportScript;
      (function() {
        (function() {
          (function() {
            function create(endpoint, parent) {
              return new (Factory(endpoint))(endpoint.path, parent);
            }
            function Factory(endpoint) {
              var type = type_getModuleType(endpoint);
              var Ctor = m_Types[type];
              if (null == Ctor) {
                throw Error('Import is not supported for type ' + type + ' and the path ' + endpoint.path);
              }
              return Ctor;
            }
            m_createModule = function(node, ctx, ctr, parent) {
              var path = u_resolvePathFromImport(node, ctx, ctr, parent), endpoint = new Endpoint(path, node.contentType, node.moduleType), module = cache_get(endpoint);
              if (null == module) {
                module = cache_set(endpoint, create(endpoint, parent));
              }
              return module;
            };
            m_registerModule = function(mix, endpoint, ctx, ctr, parent) {
              endpoint.path = u_resolvePath(endpoint.path, ctx, ctr, parent);
              var module = m_createModule(endpoint, ctx, ctr, parent);
              if (type_isMask(endpoint)) {
                module.onLoadSuccess_(mix);
                return module;
              }
              // assume others and is loaded
                            module.state = 4;
              module.exports = mix;
              module.resolve(module);
              return module;
            };
            m_registerModuleType = function(baseModuleType, newType, mix) {
              _typeMappings[newType] = baseModuleType;
              m_Types[newType] = class_create(m_Types[baseModuleType], mix);
            };
          })();
          IImport = class_create({
            type: null,
            constructor: function(endpoint, node, module) {
              this.node = node;
              this.path = endpoint.path;
              this.alias = node.alias;
              this.exports = node.exports;
              this.async = node.async;
              this.contentType = node.contentType;
              this.moduleType = node.moduleType;
              this.module = m_createModule(endpoint, null, null, module);
              this.parent = module;
              this.imports = null;
            },
            eachExport: function(fn) {
              var alias = this.alias;
              if (null != alias) {
                fn.call(this, alias, '*', alias);
                return;
              }
              var exports = this.exports;
              if (null != exports) {
                var imax = exports.length, i = -1;
                while (++i < imax) {
                  var x = exports[i];
                  fn.call(this, null == x.alias ? x.name : x.alias, x.name, x.alias);
                }
              }
            },
            hasExport: function(name) {
              if (this.alias === name) {
                return true;
              }
              var exports = this.exports;
              if (null != exports) {
                var imax = exports.length, i = -1;
                while (++i < imax) {
                  var x = exports[i];
                  var expName = null == x.alias ? x.name : x.alias;
                  if (expName === name) {
                    return true;
                  }
                }
              }
              return false;
            },
            getExport: function(name) {
              return this.imports[name];
            },
            getExportedName: function(alias) {
              if (this.alias === alias) {
                return '*';
              }
              var exports = this.exports;
              if (null != exports) {
                var x, imax = exports.length, i = -1;
                while (++i < imax) {
                  x = exports[i];
                  if ((x.alias || x.name) === alias) {
                    return x.name;
                  }
                }
              }
              return null;
            },
            loadImport: function(cb) {
              var self = this;
              this.module.loadModule().fail(cb).done(function(module) {
                cb(null, self);
              });
            },
            registerScope: function(ctr) {
              this.imports = {};
              this.eachExport(function(exportName, name, alias) {
                this.registerExport_(ctr, exportName, name, alias);
              });
            },
            registerExport_: function(ctr, exportName, name, alias) {
              var module = this.module;
              var prop = alias || name;
              var obj = null;
              if ('async' === this.async && module.isBusy()) {
                var dfr = new class_Dfr();
                var that = this;
                module.then(function() {
                  var val = module.getExport(name);
                  if (null == val) {
                    that.logError_('Exported property is undefined: ' + name);
                  }
                  dfr.resolve(val);
                }, function(error) {
                  dfr.reject(error);
                });
                obj = dfr;
              } else {
                obj = module.getExport(name);
              }
              if (null == obj) {
                this.logError_('Exported property is undefined: ' + name);
                return;
              }
              if ('*' === name && _opts.es6Modules && null != obj.default) {
                var defaultOnly = true;
                for (var key in obj) {
                  if ('default' === key || '_' === key[0]) {
                    continue;
                  }
                  defaultOnly = false;
                  break;
                }
                if (defaultOnly) {
                  warn_withNode('Default ONLY export is deprecated: `import * as foo from X`. Use `import foo from X`', this.node);
                  obj = obj.default;
                }
              }
              if (null == ctr.scope) {
                ctr.scope = {};
              }
              if ('*' === exportName) {
                throw new Error('Obsolete: unexpected exportName');
              }
              this.imports[exportName] = obj;
              obj_setProperty(ctr.scope, prop, obj);
              customTag_registerResolver(prop);
            },
            logError_: function(msg) {
              var str = '\n(Module) ' + (this.parent || {
                path: 'root'
              }).path;
              str += '\n  (Import) ' + this.path;
              str += '\n    ' + msg;
              error_withCompo(str, this);
            }
          });
        })();
        (function() {
          i_Types = {};
        })();
        ImportScript = i_Types['script'] = class_create(IImport, {
          type: 'script',
          contentType: 'script'
        });
      })();
      (function() {
        i_Types['data'] = class_create(ImportScript, {
          type: 'data',
          contentType: 'json'
        });
      })();
      var ImportMask;
      (function() {
        ImportMask = i_Types['mask'] = class_create(IImport, {
          type: 'mask',
          contentType: 'mask',
          getHandler: function(name) {
            var module = this.module;
            if (null == module) {
              return;
            }
            if (null != module.error) {
              if (this.hasExport(name)) {
                this.logError_('Resource for the import `' + name + '` not loaded');
                return this.empty;
              }
              return null;
            }
            var x = this.getExportedName(name);
            if (null == x) {
              return null;
            }
            return module.exports[x] || module.queryHandler(x);
          },
          empty: function EmptyCompo() {}
        });
      })();
      (function() {
        i_Types['html'] = class_create(ImportMask, {
          type: 'mask',
          contentType: 'html'
        });
      })();
      (function() {
        i_Types['style'] = class_create(IImport, {
          type: 'style',
          contentType: 'css',
          registerScope: fn_doNothing
        });
      })();
      (function() {
        i_Types['text'] = class_create(ImportScript, {
          type: 'text',
          contentType: 'txt'
        });
      })();
      (function() {
        i_createImport = function(node, ctx, ctr, module) {
          var path = u_resolvePathFromImport(node, ctx, ctr, module), endpoint = new Endpoint(path, node.contentType, node.moduleType);
          return create(endpoint, node, module);
        };
        function create(endpoint, node, parent) {
          return new (Factory(endpoint))(endpoint, node, parent);
        }
        function Factory(endpoint) {
          var type = type_get(endpoint);
          var Ctor = i_Types[type];
          if (null == Ctor) {
            throw Error('Module is not supported for type ' + type + ' and the path ' + endpoint.path);
          }
          return Ctor;
        }
      })();
    })();
    var ModuleMask;
    (function() {
      (function() {
        m_Types = {};
      })();
      var mask_nodesToArray;
      (function() {
        // Also flattern all `imports` tags
        mask_nodesToArray = function(mix) {
          var type = mix.type;
          if (type === Dom.NODE && 'imports' === mix.tagName) {
            return mix.nodes;
          }
          if (type !== Dom.FRAGMENT && null != type) {
            return [ mix ];
          }
          var arr = mix;
          if (type === Dom.FRAGMENT) {
            arr = mix.nodes;
            if (null == arr) {
              return [];
            }
          }
          var x, imax = arr.length, i = -1;
          while (++i < imax) {
            x = arr[i];
            if ('imports' === x.tagName) {
              arr.splice.apply(arr, [ i, 1 ].concat(x.nodes));
              i--;
            }
          }
          return arr;
        };
      })();
      ModuleMask = m_Types['mask'] = class_create(IModule, {
        type: 'mask',
        scope: null,
        source: null,
        modules: null,
        exports: null,
        importItems: null,
        load_: _file_get,
        loadModule: function() {
          if (0 === this.state) {
            return IModule.prototype.loadModule.call(this);
          }
          if (2 === this.state) {
            this.state = 3;
            var self = this;
            self.preprocess_(this.source, function() {
              self.state = 4;
              self.resolve(self);
            });
          }
          return this;
        },
        preprocessError_: function(error, next) {
          var msg = 'Load error: ' + this.path;
          if (error && error.status) {
            msg += '; Status: ' + error.status;
          }
          this.source = reporter_createErrorNode(msg);
          next.call(this, error);
        },
        preprocess_: function(mix, next) {
          var ast = 'string' === typeof mix ? parser_parse(mix, this.path) : mix;
          this.source = ast;
          this.importItems = [];
          this.exports = {
            __nodes__: [],
            __handlers__: {}
          };
          var x, arr = mask_nodesToArray(ast), importNodes = [], imax = arr.length, i = -1;
          while (++i < imax) {
            x = arr[i];
            switch (x.tagName) {
             case 'import':
              importNodes.push(x);
              this.importItems.push(i_createImport(x, null, null, this));
              break;

             case 'module':
              var path = u_resolvePath(x.attr.path, null, null, this), type = x.attr.contentType, endpoint = new Endpoint(path, type);
              m_registerModule(x.nodes, endpoint);
              break;

             case 'define':
             case 'let':
              continue;

             default:
              this.exports.__nodes__.push(x);
              break;
            }
          }
          _loadImports(this, importNodes, function() {
            next.call(this, null, _createExports(arr, null, this));
          });
        },
        getHandler: function(name) {
          return _module_getHandler.call(this, this, name);
        },
        queryHandler: function(selector) {
          if (this.error) {
            return _createHandlerForNodes(this.source, this);
          }
          var nodes = this.exports.__nodes__;
          if ('*' !== selector) {
            nodes = _nodesFilter(nodes, selector);
          }
          return null != nodes && 0 !== nodes.length ? _createHandlerForNodes(nodes, this) : null;
        },
        getExport: function(misc) {
          return this.getHandler(misc) || this.queryHandler(misc);
        }
      });
      function _nodesFilter(nodes, tagName) {
        var x, arr = [], imax = nodes.length, i = -1;
        while (++i < imax) {
          x = nodes[i];
          if (x.tagName === tagName) {
            arr.push(x);
          }
        }
        return arr;
      }
      function _createExports(nodes, model, module) {
        var exports = module.exports, items = module.importItems, getHandler = _module_getHandlerDelegate(module);
        var i = -1, imax = items.length;
        while (++i < imax) {
          var x = items[i];
          if (x.registerScope) {
            x.registerScope(module);
          }
        }
        i = -1, imax = nodes.length;
        while (++i < imax) {
          var node = nodes[i];
          var name = node.tagName;
          if ('define' === name || 'let' === name) {
            var Base = {
              getHandler: _fn_wrap(customTag_Compo_getHandler, getHandler),
              getModule: _module_getModuleDelegate(module),
              location: module.location
            };
            var Ctor = Define.create(node, model, module, Base);
            var Proto = Ctor.prototype;
            if (null != Proto.scope || null != module.scope) {
              Proto.scope = obj_extend(Proto.scope, module.scope);
            }
            var compoName = node.name;
            if ('define' === name) {
              exports[compoName] = Ctor;
              customTag_register(compoName, Ctor);
            }
            if ('let' === name) {
              customTag_registerResolver(compoName);
            }
            exports.__handlers__[compoName] = Ctor;
          }
        }
        exports['*'] = class_create(customTag_Base, {
          getHandler: getHandler,
          location: module.location,
          nodes: exports.__nodes__,
          scope: module.scope
        });
        return exports;
      }
      function _createHandlerForNodes(nodes, module) {
        return class_create({
          scope: module.scope,
          location: module.location,
          nodes: nodes,
          getHandler: _module_getHandlerDelegate(module)
        });
      }
      function _loadImports(module, importNodes, done) {
        var items = module.importItems, count = items.length, imax = count, i = -1;
        if (0 === count) {
          return done.call(module);
        }
        process();
        //= private
                function awaiter() {
          if (--count > 0) {
            return;
          }
          done.call(module);
        }
        function process() {
          if (i > -1) {
            // resume from sync
            awaiter();
          }
          while (++i < imax) {
            var node = importNodes[i];
            var resumer = awaiter;
            if ('async' === node.async) {
              resumer = null;
            }
            if ('sync' === node.async) {
              resumer = process;
            }
            _loadImport(module, items[i], node, resumer);
            if ('async' === node.async) {
              awaiter();
            }
            if ('sync' === node.async) {
              return;
            }
          }
        }
      }
      function _loadImport(module, import_, node, done) {
        import_.loadImport(function(error) {
          if (error) {
            error_withNode(error, node);
          }
          done && done();
        });
      }
      function _module_getModuleDelegate(module) {
        return function(name) {
          return module;
        };
      }
      function _module_getHandlerDelegate(module) {
        return function(name) {
          return _module_getHandler.call(this, module, name);
        };
      }
      function _module_getHandler(module, name) {
        if (null != module.error) {
          return;
        }
        // check public exports
                var exports = module.exports;
        var Ctor = exports[name];
        if (null != Ctor) {
          return Ctor;
        }
        // check private components store
                var handlers = exports.__handlers__;
        if (null != handlers && null != (Ctor = handlers[name])) {
          return Ctor;
        }
        var x, type, arr = module.importItems, i = arr.length;
        while (--i > -1) {
          x = arr[i];
          type = x.type;
          if ('mask' === type) {
            if (null != (Ctor = x.getHandler(name))) {
              return Ctor;
            }
          } else if (null != (Ctor = x.imports && x.imports[name])) {
            return Ctor;
          }
        }
        return null;
      }
      function _fn_wrap(baseFn, fn) {
        if (null == baseFn) {
          return fn;
        }
        return function() {
          var x = baseFn.apply(this, arguments);
          if (null != x) {
            return x;
          }
          return fn.apply(this, arguments);
        };
      }
    })();
    var m_registerModuleType, m_registerModule, m_createModule;
    (function() {
      var ModuleScript;
      (function() {
        ModuleScript = m_Types['script'] = class_create(IModule, {
          type: 'script',
          load_: _file_getScript,
          preprocessError_: function(error, next) {
            log_error('Resource ' + this.path + ' thrown an Exception: ' + error);
            next(error);
          },
          getExport: function(property) {
            var fn = IModule.prototype.getExport;
            var obj = fn.call(this, property);
            if (null == obj && _opts.es6Modules) {
              return fn.call(this, 'default');
            }
            return obj;
          }
        });
      })();
      (function() {
        m_Types['data'] = class_create(ModuleScript, {
          type: 'data',
          load_: _file_getJson
        });
      })();
      (function() {
        m_Types['html'] = class_create(ModuleMask, {
          type: 'mask',
          preprocess_: function(mix, next) {
            var ast = 'string' === typeof mix ? parser_parseHtml(mix) : mix;
            return ModuleMask.prototype.preprocess_.call(this, ast, next);
          }
        });
      })();
      (function() {
        m_Types['style'] = class_create(IModule, {
          type: 'style',
          load_: _file_getStyle
        });
      })();
      (function() {
        m_Types['text'] = class_create(ModuleScript, {
          type: 'text',
          load_: _file_get,
          getExport: function(property) {
            return this.exports;
          }
        });
      })();
      (function() {
        ModuleMidd.parseMaskContent = function(mix, path) {
          return class_Dfr.run(function(resolve, reject) {
            new ModuleMask(path || '').preprocess_(mix, function(error, exports) {
              if (error) {
                reject(error);
                return;
              }
              resolve(exports);
            });
          });
        };
      })();
    })();
    var m_cfg;
    (function() {
      m_cfg = function(mix, val) {
        if (1 === arguments.length) {
          if (is_String(mix)) {
            return obj_getProperty(_opts, mix);
          }
          if (is_Object(mix)) {
            for (var key in mix) {
              u_setOption(_opts, key, mix[key]);
            }
          }
          return this;
        }
        u_setOption(_opts, mix, val);
        return this;
      };
    })();
    (function() {
      (function() {
        var IMPORT = 'import', IMPORTS = 'imports';
        custom_Tags['module'] = class_create({
          constructor: function(node, model, ctx, container, ctr) {
            var path = path_resolveUrl(node.attr.path, u_resolveLocation(ctx, ctr)), type = node.attr.type, endpoint = new Endpoint(path, type);
            m_registerModule(node.nodes, endpoint, ctx, ctr);
          },
          render: fn_doNothing
        });
        custom_Tags['import:base'] = function(node, model, ctx, el, ctr) {
          var x = expression_eval(node.expression, model, ctx, ctr);
          m_cfg('base', x);
        };
        custom_Tags['import:cfg'] = function(node, model, ctx, el, ctr) {
          var args = expression_evalStatements(node.expression, model, ctx, ctr);
          m_cfg.apply(null, args);
        };
        custom_Tags[IMPORT] = class_create({
          meta: {
            serializeNodes: true
          },
          constructor: function(node, model, ctx, el, ctr) {
            if (null == node.alias && null == node.exports && type_isMask(node)) {
              // embedding
              this.module = m_createModule(node, ctx, ctr);
            }
          },
          renderStart: function(model, ctx) {
            if (null == this.module) {
              return;
            }
            var resume = Component.pause(this, ctx);
            var self = this;
            this.module.loadModule().done(function() {
              self.nodes = self.module.exports['__nodes__'];
              self.scope = self.module.scope;
              self.location = self.module.location;
              self.getHandler = self.module.getHandler.bind(self.module);
            }).fail(function(error) {
              error_withCompo(error, this);
              self.nodes = self.module.source;
            }).always(resume);
          }
        });
        custom_Tags[IMPORTS] = class_create({
          importItems: null,
          load_: function(ctx, cb) {
            var arr = this.importItems, self = this, imax = arr.length, await_ = imax, next = cb, i = -1;
            function done(error, import_) {
              if (null == error) {
                if (import_.registerScope) {
                  import_.registerScope(self);
                }
                if (null != ctx._modules) {
                  ctx._modules.add(import_.module);
                }
              }
              if (0 === --await_ && null != next) {
                next();
              }
            }
            function process(error, import_) {
              if (0 !== arguments.length) {
                done(error, import_);
              }
              while (++i < imax) {
                var x = arr[i];
                if ('async' === x.async && 0 === --await_) {
                  next();
                  next = null;
                }
                var onReady = 'sync' === x.async ? process : done;
                x.loadImport(onReady);
                if ('sync' === x.async) {
                  break;
                }
              }
            }
            process();
          },
          start_: function(model, ctx) {
            var x, resume = Component.pause(this, ctx), nodes = this.nodes, imax = nodes.length, i = -1;
            var arr = this.importItems = [];
            while (++i < imax) {
              x = nodes[i];
              if (x.tagName === IMPORT) {
                if (null != x.path && -1 !== x.path.indexOf('~')) {
                  var fn = parser_ensureTemplateFunction(x.path);
                  if (is_Function(fn)) {
                    x.path = fn('attr', model, ctx, null, this);
                  }
                }
                arr.push(i_createImport(x, ctx, this));
              }
            }
            this.load_(ctx, resume);
          },
          renderStart: function(model, ctx) {
            this.start_(model, ctx);
          },
          renderStartClient: function(model, ctx) {
            this.start_(model, ctx);
          },
          getHandler: function(name) {
            var import_, x, arr = this.importItems, imax = arr.length, i = -1;
            while (++i < imax) {
              import_ = arr[i];
              switch (import_.type) {
               case 'mask':
                x = import_.getHandler(name);
                break;

               case 'script':
                x = import_.getExport(name);
                break;
              }
              if (null != x) {
                return x;
              }
            }
            return null;
          },
          getHandlers: function() {
            var handlers = {};
            var import_, x, arr = this.importItems, imax = arr.length, i = -1;
            while (++i < imax) {
              import_ = arr[i];
              if ('mask' !== import_) {
                continue;
              }
              x = import_.getHandlers();
              obj_extend(handlers, x);
            }
            return handlers;
          }
        });
      })();
    })();
    (function() {
      var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function(d, b) {
            d.__proto__ = b;
          } || function(d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) {
                d[p] = b[p];
              }
            }
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
        var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ('object' === typeof Reflect && 'function' === typeof Reflect.decorate) {
          r = Reflect.decorate(decorators, target, key, desc);
        } else {
          for (var i = decorators.length - 1; i >= 0; i--) {
            if (d = decorators[i]) {
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
            }
          }
        }
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var AwaitCtr = /** @class */ function() {
        function AwaitCtr() {
          this.nodes = null;
          this.attr = null;
          this.expression = null;
          this.scope = null;
          this.parent = null;
          this.model = null;
          this.components = null;
          this.progressNodes = null;
          this.progressNodesExpr = null;
          this.completeNodes = null;
          this.completeNodesExpr = null;
          this.errorNodes = null;
          this.errorNodesExpr = null;
          this.keys = null;
          this.strategy = null;
          this.importItems = null;
        }
        AwaitCtr.prototype.domInsert = function() {
          this.strategy.emit('domInsert');
        };
        AwaitCtr.prototype.splitNodes_ = function() {
          var map = {
            '@progress': 'progressNodes',
            '@fail': 'errorNodes',
            '@done': 'completeNodes'
          };
          coll_each(this.nodes, function(node) {
            var name = node.tagName, nodes = node.nodes;
            var prop = map[name];
            if (null == prop) {
              prop = 'completeNodes';
              nodes = [ node ];
            }
            if (node.expression) {
              this[prop + 'Expr'] = node.expression;
            }
            var current = this[prop];
            if (null == current) {
              this[prop] = nodes;
              return;
            }
            this[prop] = Array.prototype.concat.call(current, nodes);
          }, this);
          this.nodes = null;
        };
        AwaitCtr.prototype.prepairKeys_ = function() {
          for (var key in this.attr) {
            var val = this.attr[key];
            if (key !== val) {
              continue;
            }
            if (null == this.keys) {
              this.keys = [];
            }
            this.keys.push(key);
          }
        };
        AwaitCtr.prototype.prepairImports_ = function() {
          var imports = Component.closest(this, 'imports');
          if (null != imports) {
            return this.importItems = imports.importItems;
          }
        };
        AwaitCtr.prototype.initStrategy_ = function() {
          var expr = this.expression;
          if (expr && null == this.keys) {
            if (-1 !== expr.indexOf('(') || -1 !== expr.indexOf('.')) {
              this.strategy = new ExpressionStrategy(this);
              return;
            }
            this.strategy = new RefOrImportStrategy(this);
            return;
          }
          if (null != this.keys) {
            if (1 === this.keys.length) {
              this.strategy = new ComponentStrategy(this, this.keys[0], this.expression);
              return;
            }
            if (this.keys.length > 1 && null == expr) {
              this.strategy = new RefOrImportStrategy(this);
              return;
            }
          }
          var msg = 'Unsupported await strategy. `(';
          msg += this.expression || '';
          msg += ') ';
          msg += this.keys && this.keys.join(' ') || '';
          throw new Error(msg);
        };
        AwaitCtr.prototype.getModuleFor = function(name) {
          var parent = this.parent;
          var module;
          while (null != parent && null == module) {
            module = parent.getModule && parent.getModule() || parent.importItems && parent || null;
            parent = parent.parent;
          }
          if (null == module || null == module.importItems) {
            log_error('Module not found for import ' + name);
            return null;
          }
          var import_ = module.importItems.find(function(x) {
            return x.hasExport(name);
          });
          return import_ && import_.module || null;
        };
        AwaitCtr.prototype.await_ = function(model, ctx, container) {
          this.progress_(ctx, container);
          this.strategy.process(model, ctx, container);
          var resume = builder_resumeDelegate(this, model, ctx, container);
          var self = this;
          this.strategy.done(function() {
            self.complete_();
          }).fail(function(error) {
            self.error_(error);
          }).always(resume);
        };
        AwaitCtr.prototype.renderStart = function(model, ctx, container) {
          this.splitNodes_();
          this.prepairKeys_();
          this.prepairImports_();
          this.initStrategy_();
          this.await_(model, ctx, container);
        };
        AwaitCtr.prototype.error_ = function(error) {
          this.nodes = this.errorNodes || reporter_createErrorNode(error.message);
          this.model = error;
          if (this.errorNodesExpr) {
            this.initScope(this.errorNodesExpr, [ error ]);
          }
        };
        AwaitCtr.prototype.progress_ = function(ctx, container) {
          var nodes = this.progressNodes;
          if (null == nodes) {
            return;
          }
          var hasLiteral = nodes.some(function(x) {
            return x.type === Dom.TEXTNODE;
          });
          if (hasLiteral) {
            nodes = jMask('div').append(nodes);
          }
          var node = {
            type: Dom.COMPONENT,
            nodes: nodes,
            controller: new Component(),
            attr: {}
          };
          builder_build(node, null, ctx, container, this);
        };
        AwaitCtr.prototype.complete_ = function() {
          var progress = this.progressNodes && this.components && this.components[0];
          if (progress) {
            progress.remove();
          }
          if (null != this.completeNodesExpr) {
            this.initScope(this.completeNodesExpr, this.strategy.getExports());
          }
          this.nodes = this.strategy.getNodes();
        };
        AwaitCtr.prototype.initScope = function(expr, exports) {
          this.scope = {};
          var names = _getNames(expr), i = names.length;
          while (--i > -1) {
            this.scope[names[i]] = exports[i];
          }
        };
        __decorate([ Component.deco.slot() ], AwaitCtr.prototype, 'domInsert', null);
        return AwaitCtr;
      }();
      custom_Tags['await'] = AwaitCtr;
      var AStrategy = /** @class */ function(_super) {
        __extends(AStrategy, _super);
        function AStrategy(awaiter) {
          var _this = _super.call(this) || this;
          _this.awaiter = awaiter;
          _this.error = null;
          return _this;
        }
        AStrategy.prototype.getNodes_ = function() {
          return this.awaiter.completeNodes;
        };
        AStrategy.prototype.getNodes = function() {
          return this.getNodes_();
        };
        AStrategy.prototype.process = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          throw Error('Not implemented');
        };
        AStrategy.prototype.emit = function(name) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
        };
        return AStrategy;
      }(class_Dfr);
      var ExpressionStrategy = /** @class */ function(_super) {
        __extends(ExpressionStrategy, _super);
        function ExpressionStrategy() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        ExpressionStrategy.prototype.process = function() {
          this.awaitable = new AwaitableExpr(this.awaiter.parent, this.awaiter.expression);
          this.awaitable.pipe(this);
        };
        ExpressionStrategy.prototype.getExports = function() {
          return this.awaitable.exports;
        };
        return ExpressionStrategy;
      }(AStrategy);
      var RefOrImportStrategy = /** @class */ function(_super) {
        __extends(RefOrImportStrategy, _super);
        function RefOrImportStrategy() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        RefOrImportStrategy.prototype.process = function() {
          var self = this;
          var refs = this.awaiter.expression ? _getNames(this.awaiter.expression) : this.awaiter.keys;
          var arr = refs.map(function(ref) {
            var module = self.awaiter.getModuleFor(ref);
            if (null != module) {
              return new AwaitableModule(module);
            }
            return new AwaitableExpr(self.awaiter.parent, ref);
          });
          var i = arr.length;
          arr.forEach(function(awaiter) {
            awaiter.done(function() {
              if (null == self.error && 0 === --i) {
                self.resolve();
              }
            }).fail(function(error) {
              self.error = error;
              self.reject(error);
            });
          });
          this.awaitables = arr;
        };
        RefOrImportStrategy.prototype.getExports = function() {
          return this.awaitables.reduce(function(aggr, x) {
            return aggr.concat(x.getExports());
          }, []);
        };
        return RefOrImportStrategy;
      }(AStrategy);
      var ComponentStrategy = /** @class */ function(_super) {
        __extends(ComponentStrategy, _super);
        function ComponentStrategy(awaiter, name, expr) {
          var _this = _super.call(this, awaiter) || this;
          _this.isDomInsert = false;
          _this.name = name;
          _this.expr = expr;
          return _this;
        }
        ComponentStrategy.prototype.process = function(model, ctx, container) {
          var module = this.awaiter.getModuleFor(this.name);
          if (null == module) {
            this.render(model, ctx, container);
            return;
          }
          var self = this;
          module.done(function() {
            self.render(model, ctx, container);
          }).fail(this.rejectDelegate());
        };
        ComponentStrategy.prototype.render = function(model, ctx, container) {
          var _this = this;
          var attr = Object.create(this.awaiter.attr);
          attr[this.name] = null;
          this.awaitable = new AwaitableRender(this.name, attr, this.expr, this.getNodes_(), model, ctx, container, this.awaiter);
          this.awaitable.pipe(this).then(function() {
            if (_this.isDomInsert) {
              Component.signal.emitIn(_this.awaiter, 'domInsert');
            }
          });
        };
        ComponentStrategy.prototype.getNodes = function() {
          return null;
        };
        ComponentStrategy.prototype.emit = function(name) {
          if ('domInsert' === name) {
            this.isDomInsert = true;
          }
        };
        return ComponentStrategy;
      }(AStrategy);
      var AwaitableModule = /** @class */ function(_super) {
        __extends(AwaitableModule, _super);
        function AwaitableModule(module) {
          var _this = _super.call(this) || this;
          _this.module = module;
          _this.module.pipe(_this);
          return _this;
        }
        AwaitableModule.prototype.getExports = function() {
          return [ this.module.exports ];
        };
        return AwaitableModule;
      }(class_Dfr);
      var AwaitableExpr = /** @class */ function(_super) {
        __extends(AwaitableExpr, _super);
        function AwaitableExpr(compo, expression) {
          var _this = _super.call(this) || this;
          _this.error = null;
          _this.exports = [];
          _this.onResolve = _this.onResolve.bind(_this);
          _this.onReject = _this.onReject.bind(_this);
          var arr = expression_evalStatements(expression, compo.model, null, compo);
          var imax = arr.length, i = -1;
          _this.await_ = imax;
          while (++i < imax) {
            var x = arr[i];
            if (null == x || false === is_Function(x.then)) {
              _this.await_--;
              _this.exports.push(x);
              continue;
            }
            x.then(_this.onResolve, _this.onReject);
          }
          if (0 === _this.await_) {
            _this.resolve(_this.exports);
          }
          return _this;
        }
        AwaitableExpr.prototype.onResolve = function() {
          if (this.error) {
            return;
          }
          this.exports.push.apply(this.exports, arguments);
          if (0 === --this.await_) {
            this.resolve(this.exports);
          }
        };
        AwaitableExpr.prototype.onReject = function(error) {
          this.error = error || Error('Rejected');
          this.reject(this.error);
        };
        AwaitableExpr.prototype.getExports = function() {
          return this.exports;
        };
        return AwaitableExpr;
      }(class_Dfr);
      var AwaitableRender = /** @class */ function(_super) {
        __extends(AwaitableRender, _super);
        function AwaitableRender(name, attr, expression, nodes, model, ctx, container, ctr) {
          var _this = _super.call(this) || this;
          _this.onComplete = _this.onComplete.bind(_this);
          _this.anchor = document.createComment('');
          container.appendChild(_this.anchor);
          var node = {
            type: Dom.NODE,
            tagName: name,
            nodes: nodes,
            expression: expression,
            attr: attr
          };
          renderer_renderAsync(node, model, builder_Ctx.clone(ctx), null, ctr).then(_this.onComplete, _this.rejectDelegate());
          return _this;
        }
        AwaitableRender.prototype.onComplete = function(fragment) {
          this.anchor.parentNode.insertBefore(fragment, this.anchor);
          this.resolve();
        };
        return AwaitableRender;
      }(class_Dfr);
      function _getNames(str) {
        var names = str.split(','), imax = names.length, i = -1, arr = new Array(imax);
        while (++i < imax) {
          arr[i] = names[i].trim();
        }
        return arr;
      }
    })();
    Module = {
      ModuleMask: ModuleMask,
      Endpoint: Endpoint,
      createModule: m_createModule,
      registerModule: m_registerModule,
      registerModuleType: m_registerModuleType,
      createImport: i_createImport,
      isMask: type_isMask,
      getType: type_get,
      getModuleType: type_getModuleType,
      cfg: m_cfg,
      resolveLocation: u_resolveLocation,
      resolvePath: u_resolvePathFromImport,
      getDependencies: tools_getDependencies,
      build: tools_build,
      clearCache: cache_clear,
      getCache: cache_get,
      reload: function(path) {},
      types: IModule.types,
      File: {
        get: _file_get,
        getScript: _file_getScript,
        getStyle: _file_getStyle,
        getJson: _file_getJson
      }
    };
  })();
  (function() {
    (function() {
      var els_toggleVisibility, el_renderPlaceholder;
      (function() {
        els_toggleVisibility = function(mix, state) {
          if (null == mix) {
            return;
          }
          if (is_ArrayLike(mix)) {
            _toggleArr(mix, state);
            return;
          }
          _toggle(mix, state);
        };
        function _toggle(el, state) {
          el.style.display = state ? '' : 'none';
        }
        function _toggleArr(els, state) {
          var imax = els.length, i = -1;
          while (++i < imax) {
            _toggle(els[i], state);
          }
        }
        el_renderPlaceholder = function(container) {
          var anchor = _document.createComment('');
          container.appendChild(anchor);
          return anchor;
        };
      })();
      var dom_insertBefore;
      (function() {
        function setVisibility(state, el) {
          if (null != el) {
            el.style.display = state ? '' : 'none';
          }
        }
        setVisibility.bind(null, true);
        setVisibility.bind(null, false);
        dom_insertBefore = function(el, anchor) {
          return anchor.parentNode.insertBefore(el, anchor);
        };
      })();
      var __spreadArrays = this && this.__spreadArrays || function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
          s += arguments[i].length;
        }
        var r = Array(s), k = 0;
        for (i = 0; i < il; i++) {
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
          }
        }
        return r;
      };
      function getNodesSync(node, model, ctx, ctr) {
        do {
          if (expression_eval(node.expression, model, ctx, ctr, node)) {
            return node.nodes;
          }
          node = node.nextSibling;
          if (null == node || 'else' !== node.tagName) {
            return null;
          }
          var expr = node.expression;
          if (null == expr || '' === expr) {
            return node.nodes;
          }
        } while (true);
      }
      var ObservableNodes = /** @class */ function() {
        function ObservableNodes(node, model, ctx, ctr, cb) {
          this.node = node;
          this.model = model;
          this.ctx = ctx;
          this.ctr = ctr;
          this.cb = cb;
          this.frame = 0;
          this.index = 0;
          this.cursor = null;
          this.switch = [];
          this.subscriptions = [];
          this.disposed = false;
          this.next = this.next.bind(this);
          this.tick = this.tick.bind(this);
          this.onValue = this.onValue.bind(this);
          this.cursor = node;
        }
        ObservableNodes.prototype.start = function() {
          this.frame++;
          this.index = 0;
          this.cursor = this.node;
          this.process();
        };
        ObservableNodes.prototype.eval = function() {
          return expression_eval(this.cursor.expression, this.model, this.ctx, this.ctr, this.node);
        };
        ObservableNodes.prototype.onValue = function(err, val) {
          if (err) {
            this.cb(err);
            return;
          }
          this.next(null, val);
        };
        ObservableNodes.prototype.next = function(err, result) {
          var meta = this.switch[this.index];
          meta.result = result;
          if (err) {
            this.cb(err);
            return;
          }
          if (result) {
            this.cb(null, meta.node, this.index);
            return;
          }
          this.index++;
          this.cursor = this.cursor.nextSibling;
          if (null == this.cursor || 'else' !== this.cursor.tagName) {
            this.cb(null, null, -1);
            return;
          }
          var expr = this.cursor.expression;
          if (null == expr || '' === expr) {
            this.cb(null, this.cursor, this.index);
            return;
          }
          this.process();
        };
        ObservableNodes.prototype.tick = function(err, i, result) {
          if (this.disposed) {
            return;
          }
          var s = this.switch[i];
          s.result = result;
          s.busy = false;
          this.start();
        };
        ObservableNodes.prototype.process = function() {
          var _this = this;
          var i = this.index;
          var meta = this.switch[i];
          if (null != meta) {
            switch (meta.type) {
             case exp_type_Sync:
              this.onValue(null, this.eval());
              return;

             case exp_type_Async:
             case exp_type_Observe:
              if (false === meta.busy) {
                this.onValue(null, meta.result);
                return;
              }
            }
          }
          var value = this.eval();
          meta = this.switch[i] = {
            busy: true,
            type: exp_type_Sync,
            node: this.cursor,
            value: null,
            error: null,
            result: null
          };
          if (is_Observable(value) && 2 /* SubjectKind.Promise */ !== value.kind) {
            meta.type = exp_type_Observe;
            this.subscriptions.push(value.subscribe(function(x) {
              return _this.tick(null, i, x);
            }, this.tick));
            return;
          }
          if (is_PromiseLike(value)) {
            meta.type = exp_type_Async;
            value.then(function(x) {
              return _this.onValue(null, x);
            }, this.onValue);
            return;
          }
          meta.type = exp_type_Sync;
          this.onValue(null, value);
        };
        ObservableNodes.prototype.dispose = function() {
          this.disposed = true;
          this.subscriptions.forEach(function(x) {
            return x.unsubscribe();
          });
        };
        return ObservableNodes;
      }();
      custom_Statements['if'] = {
        getNodes: getNodesSync,
        render: function(node, model, ctx, container, ctr, children) {
          var type = expression_getType(node.expression);
          if (type === exp_type_Sync) {
            var nodes = getNodesSync(node, model, ctx, ctr);
            if (null != nodes) {
              builder_build(nodes, model, ctx, container, ctr, children);
            }
            return;
          }
          var compo = new ObservableIf(node, model, ctx, container, ctr, children);
          compo_addChild(ctr, compo);
          compo.render();
        }
      };
      var ObservableIf = /** @class */ function() {
        function ObservableIf(node, model, ctx, el, ctr, children) {
          this.node = node;
          this.model = model;
          this.ctx = ctx;
          this.el = el;
          this.ctr = ctr;
          this.children = children;
          this.compoName = '+if';
          this.binder = null;
          this.placeholder = null;
          this.index = -1;
          this.Switch = [];
        }
        ObservableIf.prototype.render = function() {
          var _this = this;
          this.resumeFn = Compo.pause(this, this.ctx);
          this.placeholder = el_renderPlaceholder(this.el);
          this.obs = new ObservableNodes(this.node, this.model, this.ctx, this.ctr, function(err, node, index) {
            return _this.show(err, node, index);
          });
          this.obs.start();
        };
        ObservableIf.prototype.show = function(err, node, index) {
          this.refresh(err, node, index);
          if (null != this.resumeFn) {
            this.resumeFn();
            this.resumeFn = null;
          }
        };
        ObservableIf.prototype.refresh = function(err, node, index) {
          var currentIndex = this.index, switch_ = this.Switch;
          if (currentIndex === index) {
            return;
          }
          if (currentIndex > -1) {
            els_toggleVisibility(switch_[currentIndex].elements, false);
          }
          if (-1 === index) {
            this.index = -1;
            return;
          }
          this.index = index;
          var current = switch_[index];
          if (null == current) {
            switch_[index] = current = {
              elements: null,
              node: node
            };
          }
          if (null != current.elements) {
            els_toggleVisibility(current.elements, true);
            return;
          }
          var nodes = current.node.nodes, frag = _document.createDocumentFragment(), owner = {
            components: [],
            parent: this.ctr
          }, els = compo_renderElements(nodes, this.model, this.ctx, frag, owner);
          dom_insertBefore(frag, this.placeholder);
          current.elements = els;
          compo_emitInserted(owner);
          compo_addChildren.apply(void 0, __spreadArrays([ this.ctr ], owner.components));
        };
        ObservableIf.prototype.dispose = function() {
          this.obs && this.obs.dispose();
        };
        return ObservableIf;
      }();
    })();
    (function() {
      var FOR_OF_ITEM = 'for..of::item', FOR_IN_ITEM = 'for..in::item';
      custom_Statements['for'] = {
        render: function(node, model, ctx, container, ctr, children) {
          parse_For(node.expression);
          var value = expression_eval(__ForDirective[3], model, ctx, ctr);
          if (null == value) {
            return;
          }
          build(value, __ForDirective, node.nodes, model, ctx, container, ctr, children);
        },
        build: build,
        parseFor: parse_For,
        createForNode: createForItemNode,
        getNodes: getNodes,
        getHandler: function(compoName, model) {
          if (compoName !== FOR_OF_ITEM && compoName !== FOR_IN_ITEM) {
            return null;
          }
          return createForItemHandler(compoName, model);
        }
      };
      (function() {
        custom_Tags[FOR_OF_ITEM] = createBootstrapCompo(FOR_OF_ITEM);
        custom_Tags[FOR_IN_ITEM] = createBootstrapCompo(FOR_IN_ITEM);
        function createBootstrapCompo(name) {
          function For_Item() {}
          For_Item.prototype = {
            meta: {
              serializeScope: true
            },
            serializeScope: for_proto_serializeScope,
            type: Dom.COMPONENT,
            compoName: name,
            renderEnd: handler_proto_renderEnd,
            dispose: handler_proto_dispose
          };
          return For_Item;
        }
      })();
      function build(value, For, nodes, model, ctx, container, ctr, childs) {
        builder_build(getNodes(nodes, value, For[0], For[1], For[2], For[3]), model, ctx, container, ctr, childs);
      }
      function getNodes(nodes, value, prop1, prop2, type, expr) {
        if ('of' === type) {
          if (false === is_Array(value)) {
            log_error('<ForStatement> Value is not enumerable', value);
            return null;
          }
          return loop_Array(nodes, value, prop1, prop2, expr);
        }
        if ('in' === type) {
          if ('object' !== typeof value) {
            log_warn('<ForStatement> Value is not an object', value);
            return null;
          }
          if (is_Array(value)) {
            log_warn('<ForStatement> Consider to use `for..of` for Arrays');
          }
          return loop_Object(nodes, value, prop1, prop2, expr);
        }
      }
      function loop_Array(template, arr, prop1, prop2, expr) {
        var scope, i = -1, imax = arr.length, nodes = new Array(imax);
        while (++i < imax) {
          scope = {};
          scope[prop1] = arr[i];
          if (prop2) {
            scope[prop2] = i;
          }
          nodes[i] = createForItemNode(FOR_OF_ITEM, template, scope, i, prop1, expr);
        }
        return nodes;
      }
      function loop_Object(template, obj, prop1, prop2, expr) {
        var scope, key, value, nodes = [], i = 0;
        for (key in obj) {
          value = obj[key];
          scope = {};
          scope[prop1] = key;
          if (prop2) {
            scope[prop2] = value;
          }
          nodes[i++] = createForItemNode(FOR_IN_ITEM, template, scope, key, prop2, expr);
        }
        return nodes;
      }
      function createForItemNode(name, nodes, scope, key, propVal, expr) {
        return {
          type: Dom.COMPONENT,
          tagName: name,
          nodes: nodes,
          controller: createForItemHandler(name, scope, key, propVal, expr)
        };
      }
      function createForItemHandler(name, scope, key, propVal, expr) {
        return {
          meta: {
            serializeScope: true
          },
          compoName: name,
          scope: scope,
          elements: null,
          propVal: propVal,
          key: key,
          expression: expr,
          renderEnd: handler_proto_renderEnd,
          dispose: handler_proto_dispose,
          serializeScope: for_proto_serializeScope
        };
      }
      function handler_proto_renderEnd(elements) {
        this.elements = elements;
      }
      function handler_proto_dispose() {
        if (this.elements) {
          this.elements.length = 0;
        }
      }
      function for_proto_serializeScope(scope, model) {
        var ctr = this, expr = ctr.expression, key = ctr.key, propVal = ctr.propVal;
        var val = scope[propVal];
        if (null != val && 'object' === typeof val) {
          scope[propVal] = '$ref:(' + expr + ')."' + key + '"';
        }
        return scope;
      }
      var __ForDirective = [ 'prop1', 'prop2', 'in|of', 'expression' ];
      var template, index, length;
      function parse_For(expr) {
        // /([\w_$]+)((\s*,\s*([\w_$]+)\s*\))|(\s*\))|(\s+))(of|in)\s+([\w_$\.]+)/
        template = expr;
        length = expr.length;
        index = 0;
        var prop1, prop2, hasBrackets, c;
        c = parser_skipWhitespace();
        if (40 === c) {
          // (
          hasBrackets = true;
          index++;
          parser_skipWhitespace();
        }
        prop1 = parser_getVarDeclaration();
        c = parser_skipWhitespace();
        if (44 === c) {
          //,
          if (true !== hasBrackets) {
            return throw_('Parenthese must be used in multiple var declarion');
          }
          index++;
          parser_skipWhitespace();
          prop2 = parser_getVarDeclaration();
        }
        if (hasBrackets) {
          c = parser_skipWhitespace();
          if (41 !== c) {
            return throw_('Closing parenthese expected');
          }
          index++;
        }
        c = parser_skipWhitespace();
        var loopType;
        if (105 === c && 110 === template.charCodeAt(++index)) {
          // i n
          loopType = 'in';
        }
        if (111 === c && 102 === template.charCodeAt(++index)) {
          // o f
          loopType = 'of';
        }
        if (null == loopType) {
          return throw_('Invalid FOR statement. (in|of) expected');
        }
        __ForDirective[0] = prop1;
        __ForDirective[1] = prop2;
        __ForDirective[2] = loopType;
        __ForDirective[3] = template.substring(++index);
        return __ForDirective;
      }
      function parser_skipWhitespace() {
        var c;
        for (;index < length; index++) {
          c = template.charCodeAt(index);
          if (c < 33) {
            continue;
          }
          return c;
        }
        return -1;
      }
      function parser_getVarDeclaration() {
        var c, start = index;
        for (;index < length; index++) {
          c = template.charCodeAt(index);
          if (c > 48 && c < 57) {
            // 0-9
            if (start === index) {
              return throw_('Variable name begins with a digit');
            }
            continue;
          }
          if (36 === c || // $
          95 === c || // _
          c >= 97 && c <= 122 || // a-z
          c >= 65 && c <= 90) {
            continue;
          }
          break;
        }
        if (start === index) {
          return throw_('Variable declaration expected');
        }
        return template.substring(start, index);
      }
      function throw_(message) {
        throw new Error('<ForStatement parser> ' + message + ' `' + template.substring(index, 20) + '`');
      }
    })();
    (function() {
      custom_Statements['each'] = {
        render: function(node, model, ctx, container, ctr, children) {
          var array = expression_eval(node.expression, model, ctx, ctr);
          if (null == array) {
            return;
          }
          builder_build(getNodes(node, array), array, ctx, container, ctr, children);
        }
      };
      function getNodes(node, array) {
        var imax = array.length, nodes = new Array(imax), template = node.nodes, expression = node.expression, exprPrefix = '.' === expression ? '."' : '(' + node.expression + ')."', i = 0;
        for (;i < imax; i++) {
          nodes[i] = createEachNode(template, array[i], exprPrefix, i);
        }
        return nodes;
      }
      function createEachNode(nodes, model, exprPrefix, i) {
        return {
          type: Dom.COMPONENT,
          tagName: 'each::item',
          nodes: nodes,
          controller: createEachItemHandler(model, i, exprPrefix)
        };
      }
      function createEachItemHandler(model, i, exprPrefix) {
        return {
          compoName: 'each::item',
          model: model,
          scope: {
            index: i
          },
          modelRef: exprPrefix + i + '"',
          attr: null,
          meta: null
        };
      }
    })();
    (function() {
      custom_Statements['with'] = {
        render: function(node, model, ctx, el, ctr, elements) {
          var obj = expression_eval(node.expression, model, ctx, ctr);
          if (null == obj) {
            warn_withNode('Value is undefined', node);
          }
          builder_build(node.nodes, obj, ctx, el, ctr, elements);
        }
      };
    })();
    (function() {
      custom_Statements['switch'] = {
        render: function(node, model, ctx, el, ctr, elements) {
          var value = expression_eval(node.expression, model, ctx, ctr), nodes = getNodes(value, node.nodes, model, ctx, ctr);
          if (null == nodes) {
            return;
          }
          builder_build(nodes, model, ctx, el, ctr, elements);
        },
        getNodes: getNodes
      };
      function getNodes(value, nodes, model, ctx, ctr) {
        if (null == nodes) {
          return null;
        }
        var child, expr, case_, default_, imax = nodes.length, i = -1;
        while (++i < imax) {
          child = nodes[i];
          if ('default' === child.tagName) {
            default_ = child;
            continue;
          }
          if ('case' !== child.tagName) {
            log_warn('<mask:switch> Case expected', child.tagName);
            continue;
          }
          expr = child.expression;
          if (!expr) {
            log_warn('<mask:switch:case> Expression expected');
            continue;
          }
          /* jshint eqeqeq: false */          if (expression_eval(expr, model, ctx, ctr) == value) {
            /* jshint eqeqeq: true */
            case_ = child;
            break;
          }
        }
        if (null == case_) {
          case_ = default_;
        }
        return null != case_ ? case_.nodes : null;
      }
    })();
    (function() {
      custom_Statements['visible'] = {
        toggle: toggle,
        render: function(node, model, ctx, container, ctr, children) {
          var els = [];
          builder_build(node.nodes, model, ctx, container, ctr, els);
          arr_pushMany(children, els);
          var visible = expression_eval(node.expression, model, ctx, ctr);
          toggle(els, visible);
        }
      };
      function toggle(els, visible) {
        for (var i = 0; i < els.length; i++) {
          els[i].style.display = visible ? '' : 'none';
        }
      }
    })();
    (function() {
      custom_Statements['repeat'] = {
        render: function(node, model, ctx, container, ctr, children) {
          var run = expression_eval, str = node.expression, repeat = str.split('..'), start = +run(repeat[0] || '', model, ctx, ctr), end = +run(repeat[1] || '', model, ctx, ctr);
          if (start !== start || end !== end) {
            log_error('Repeat attribute(from..to) invalid', str);
            return;
          }
          var nodes = node.nodes;
          var arr = [];
          var i = start - 1;
          while (++i < end) {
            arr.push(compo_init('repeat::item', nodes, model, i, container, ctr));
          }
          var els = [];
          builder_build(arr, model, ctx, container, ctr, els);
          arr_pushMany(children, els);
        }
      };
      function compo_init(name, nodes, model, index, container, parent) {
        return {
          type: Dom.COMPONENT,
          compoName: name,
          attr: {},
          nodes: nodes,
          model: model,
          container: container,
          parent: parent,
          index: index,
          scope: {
            index: index
          }
        };
      }
    })();
  })();
  var obj_removeObserver, obj_addObserver, registerValidator, Validators, BindingProviders, registerBinding;
  (function() {
    var expression_eval_safe;
    (function() {
      (function() {
        customAttr_register('xx-visible', function(node, attrValue, model, ctx, el, ctr) {
          var binder = expression_createBinder(attrValue, model, ctx, ctr, function(value) {
            el.style.display = value ? '' : 'none';
          });
          expression_bind(attrValue, model, ctx, ctr, binder);
          Component.attach(ctr, 'dispose', function() {
            expression_unbind(attrValue, model, ctr, binder);
          });
          if (expression_eval(attrValue, model, ctx, ctr, node)) {
            el.style.display = 'none';
          }
        });
      })();
      (function() {
        (function() {
          expression_eval_safe = function(expr, model, ctx, ctr, node) {
            var x = expression_eval(expr, model, ctx, ctr, node);
            return null == x ? '' : x;
          };
        })();
        /**
				 *	Toggle value with ternary operator on an event.
				 *
				 *	button x-toggle='click: foo === "bar" ? "zet" : "bar" > 'Toggle'
				 */        customAttr_register('x-toggle', 'client', function(node, attrValue, model, ctx, el, ctr) {
          var event = attrValue.substring(0, attrValue.indexOf(':')), expression = attrValue.substring(event.length + 1), ref = expression_varRefs(expression);
          if ('string' !== typeof ref) {
            // assume is an array
            ref = ref[0];
          }
          Component.Dom.addEventListener(el, event, function() {
            var val = expression_eval_safe(expression, model, ctx, ctr, node);
            obj_setProperty(model, ref, val);
          });
        });
      })();
      (function() {
        /**
				 *	Toggle Class Name
				 *
				 *	button x-toggle='click: selected'
				 */
        customAttr_register('x-class-toggle', 'client', function(node, attrVal, model, ctx, element) {
          var event = attrVal.substring(0, attrVal.indexOf(':')), klass = attrVal.substring(event.length + 1).trim();
          Component.Dom.addEventListener(element, event, function() {
            domLib(element).toggleClass(klass);
          });
        });
      })();
    })();
    var ValidatorProvider;
    (function() {
      var class_INVALID = '-validate__invalid';
      ValidatorProvider = {
        getFnFromModel: fn_fromModelWrapp,
        getFnByName: fn_byName,
        validate: validate,
        validateUi: function(fns, val, ctr, el, oncancel) {
          var error = validate(fns, val, ctr);
          if (null != error) {
            ui_notifyInvalid(el, error, oncancel);
            return error;
          }
          ui_clearInvalid(el);
          return null;
        }
      };
      function validate(fns, val, ctr) {
        if (null == fns) {
          return null;
        }
        var error, fn, imax = fns.length, i = -1;
        while (++i < imax) {
          fn = fns[i];
          if (null == fn) {
            continue;
          }
          error = fn(val, ctr);
          if (null != error) {
            if (is_String(error)) {
              return {
                message: error,
                actual: val
              };
            }
            if (null == error.actual) {
              error.actual = val;
            }
            return error;
          }
        }
      }
      function fn_fromModel(model, prop) {
        if (false === is_Object(model)) {
          return null;
        }
        var Validate = model.Validate;
        if (null != Validate) {
          var fn = null;
          if (is_Function(fn = Validate)) {
            return fn;
          }
          if (is_Function(fn = Validate[prop])) {
            return fn;
          }
        }
        var i = prop.indexOf('.');
        if (-1 !== i) {
          return fn_fromModel(model[prop.substring(0, i)], prop.substring(i + 1));
        }
        return null;
      }
      function fn_fromModelWrapp(model, prop) {
        var fn = fn_fromModel(model, prop);
        if (null == fn) {
          return null;
        }
        return function() {
          var mix = fn.apply(model, arguments);
          if (null == mix) {
            return null;
          }
          if (is_String(mix)) {
            return {
              message: mix,
              property: prop,
              ctx: model
            };
          }
          mix.property = prop;
          mix.ctx = model;
          return mix;
        };
      }
      function fn_byName(name, param, message) {
        var Delegate = Validators[name];
        if (null == Delegate) {
          log_error('Invalid validator', name, 'Supports:', Object.keys(Validators));
          return null;
        }
        var fn = Delegate(param);
        return function(val, ctr) {
          var mix = fn(val, ctr);
          if (null == mix || true === mix) {
            return null;
          }
          if (false === mix) {
            return message || 'Check failed: `' + name + '`';
          }
          if (is_String(mix) && 0 !== mix.length) {
            return mix;
          }
          return null;
        };
      }
      function ui_notifyInvalid(el, error, oncancel) {
        var message = error.message || error;
        var next = domLib(el).next('.' + class_INVALID);
        if (0 === next.length) {
          next = domLib('<div>').addClass(class_INVALID).html('<span></span><button>&otimes;</button>').insertAfter(el);
        }
        return next.children('button').off().on('click', function() {
          next.hide();
          oncancel && oncancel();
        }).end().children('span').text(message).end().show();
      }
      function ui_clearInvalid(el) {
        return domLib(el).next('.' + class_INVALID).hide();
      }
      Validators = {
        match: function(match) {
          return function(str) {
            return new RegExp(match).test(str);
          };
        },
        unmatch: function(unmatch) {
          return function(str) {
            return !new RegExp(unmatch).test(str);
          };
        },
        minLength: function(min) {
          return function(str) {
            return str.length >= parseInt(min, 10);
          };
        },
        maxLength: function(max) {
          return function(str) {
            return str.length <= parseInt(max, 10);
          };
        },
        check: function(condition, node) {
          return function(str) {
            return expression_eval_safe('x' + condition, node.model, {
              x: str
            }, node);
          };
        }
      };
      registerValidator = function(type, fn) {
        Validators[type] = fn;
      };
    })();
    var CustomProviders, BindingProvider;
    (function() {
      var DomObjectTransport;
      (function() {
        var date_ensure;
        (function() {
          date_ensure = function(val) {
            if (null == val || '' === val) {
              return null;
            }
            var date = val;
            var type = typeof val;
            if ('string' === type) {
              date = new Date(val);
              if (rgx_es5Date.test(date) && -1 === val.indexOf('Z')) {
                // adjust to local time (http://es5.github.io/x15.9.html#x15.9.1.15)
                val.setMinutes(val.getTimezoneOffset());
              }
            }
            if ('number' === type) {
              date = new Date(val);
            }
            return false === isNaN(date) && 'function' === typeof date.getFullYear ? date : null;
          };
          var rgx_es5Date = /^\d{4}\-\d{2}/;
        })();
        var objectWay = {
          get: function(provider, expression) {
            var getter = provider.objGetter;
            if (null == getter) {
              return expression_eval(expression, provider.model, provider.ctx, provider.ctr);
            }
            var ctr = provider.ctr.parent, model = provider.model;
            return expression_callFn(getter, provider.model, provider.ctx, ctr, [ expression, model, ctr ]);
          },
          set: function(obj, property, value, provider) {
            var setter = provider.objSetter;
            if (null == setter) {
              obj_setProperty(obj, property, value);
              return;
            }
            var ctr = provider.ctr.parent, model = provider.model;
            return expression_callFn(setter, provider.model, provider.ctx, ctr, [ value, property, model, ctr ]);
          }
        };
        var domWay = {
          get: function(provider) {
            var getter = provider.domGetter;
            if (null == getter) {
              return obj_getProperty(provider, provider.property);
            }
            var ctr = provider.ctr.parent;
            if (false === isValidFn_(ctr, getter, 'Getter')) {
              return null;
            }
            return ctr[getter](provider.element);
          },
          set: function(provider, value) {
            var setter = provider.domSetter;
            if (null == setter) {
              obj_setProperty(provider, provider.property, value);
              return;
            }
            var ctr = provider.ctr.parent;
            if (false === isValidFn_(ctr, setter, 'Setter')) {
              return;
            }
            ctr[setter](value, provider.element);
          }
        };
        var DateTimeDelegate = {
          domSet: function(format) {
            return function(prov, val) {
              var date = date_ensure(val);
              prov.element.value = null == date ? '' : format(date);
            };
          },
          objSet: function(extend) {
            return function(obj, prop, val) {
              var date = date_ensure(val);
              if (null == date) {
                return;
              }
              var target = obj_getProperty(obj, prop);
              if (null == target) {
                obj_setProperty(obj, prop, date);
                return;
              }
              if (null == target.getFullYear || isNaN(target)) {
                target = date_ensure(target) || date;
                extend(target, date);
                obj_setProperty(obj, prop, target);
                return;
              }
              extend(target, date);
            };
          }
        };
        DomObjectTransport = {
          // generic
          objectWay: objectWay,
          domWay: domWay,
          domModelWay: {
            get: function(provider) {
              return obj_getProperty(provider.owner, provider.property);
            },
            set: function(provider, val) {
              obj_setProperty(provider.owner, provider.property, val);
            }
          },
          SELECT: {
            get: function(provider) {
              var el = provider.element, i = el.selectedIndex;
              if (-1 === i) {
                return '';
              }
              var opt = el.options[i], val = opt.getAttribute('value');
              return null == val ? opt.getAttribute('name') /* obsolete */ : val;
            },
            set: function(provider, val) {
              var opt, x, i, el = provider.element, options = el.options, imax = options.length;
              for (i = 0; i < imax; i++) {
                opt = options[i];
                x = opt.getAttribute('value');
                if (null == x) {
                  x = opt.getAttribute('name');
                  /* jshint eqeqeq: false */                }
                if (x == val) {
                  /* jshint eqeqeq: true */
                  el.selectedIndex = i;
                  return;
                }
              }
              log_warn('Value is not an option', val);
            }
          },
          SELECT_MULT: {
            get: function(provider) {
              return coll_map(provider.element.selectedOptions, function(x) {
                return x.value;
              });
            },
            set: function(provider, mix) {
              coll_each(provider.element.options, function(el) {
                el.selected = false;
              });
              if (null == mix) {
                return;
              }
              var arr = is_ArrayLike(mix) ? mix : [ mix ];
              coll_each(arr, function(val) {
                var els = provider.element.options, imax = els.length, i = -1;
                while (++i < imax) {
                  /* jshint eqeqeq: false */
                  if (els[i].value == val) {
                    /* jshint eqeqeq: true */
                    els[i].selected = true;
                  }
                }
                log_warn('Value is not an option', val);
              });
            }
          },
          DATE: {
            domWay: {
              get: domWay.get,
              set: function(prov, val) {
                var date = date_ensure(val);
                prov.element.value = null == date ? '' : formatDate(date);
              }
            },
            objectWay: {
              get: objectWay.get,
              set: DateTimeDelegate.objSet(function(a, b) {
                var offset = a.getTimezoneOffset();
                a.setFullYear(b.getFullYear());
                a.setMonth(b.getMonth());
                a.setDate(b.getDate());
                var diff = offset - a.getTimezoneOffset();
                if (0 !== diff) {
                  var h = diff / 60 | 0;
                  a.setHours(a.getHours() + h);
                }
              })
            }
          },
          TIME: {
            domWay: {
              get: domWay.get,
              set: DateTimeDelegate.domSet(formatTime)
            },
            objectWay: {
              get: objectWay.get,
              set: DateTimeDelegate.objSet(function(a, b) {
                a.setHours(b.getHours());
                a.setMinutes(b.getMinutes());
                a.setSeconds(b.getSeconds());
              })
            }
          },
          MONTH: {
            domWay: {
              get: domWay.get,
              set: DateTimeDelegate.domSet(formatMonth)
            },
            objectWay: {
              get: objectWay.get,
              set: DateTimeDelegate.objSet(function(a, b) {
                a.setFullYear(b.getFullYear());
                a.setMonth(b.getMonth());
              })
            }
          },
          RADIO: {
            domWay: {
              get: function(provider) {
                var el = provider.element;
                return el.checked ? el.value : null;
              },
              set: function(provider, value) {
                var el = provider.element;
                el.checked = el.value === value;
              }
            }
          }
        };
        function isValidFn_(obj, prop, name) {
          if (null == obj || 'function' !== typeof obj[prop]) {
            log_error('BindingProvider. Controllers accessor.', name, 'should be a function. Property:', prop);
            return false;
          }
          return true;
        }
        function formatDate(date) {
          var YYYY = date.getFullYear(), MM = date.getMonth() + 1, DD = date.getDate();
          return YYYY + '-' + (MM < 10 ? '0' : '') + MM + '-' + (DD < 10 ? '0' : '') + DD;
        }
        function formatTime(date) {
          var H = date.getHours(), M = date.getMinutes();
          return H + ':' + (M < 10 ? '0' : '') + M;
        }
        function formatMonth(date) {
          var YYYY = date.getFullYear(), MM = date.getMonth() + 1;
          return YYYY + '-' + (MM < 10 ? '0' : '') + MM;
        }
      })();
      var signal_parse;
      (function() {
        signal_parse = function(str, isPiped, defaultType) {
          var x, signalName, type, signal, signals = str.split(';'), set = [], i = 0, imax = signals.length;
          for (;i < imax; i++) {
            x = signals[i].split(':');
            if (1 !== x.length && 2 !== x.length) {
              log_error('Too much ":" in a signal def.', signals[i]);
              continue;
            }
            type = 2 === x.length ? x[0] : defaultType;
            signalName = x[2 === x.length ? 1 : 0];
            signal = signal_create(signalName.trim(), type, isPiped);
            if (null != signal) {
              set.push(signal);
            }
          }
          return set;
        };
        function signal_create(signal, type, isPiped) {
          if (true !== isPiped) {
            return {
              signal: signal,
              type: type
            };
          }
          var index = signal.indexOf('.');
          if (-1 === index) {
            log_error('No pipe name in a signal', signal);
            return null;
          }
          return {
            signal: signal.substring(index + 1),
            pipe: signal.substring(0, index),
            type: type
          };
        }
      })();
      CustomProviders = {};
      var A_dom_slot = 'dom-slot';
      var A_property = 'property';
      var A_change_event = 'change-event';
      BindingProvider = /** @class */ function() {
        function BindingProvider(model, element, ctr, bindingType) {
          this.model = model;
          this.element = element;
          this.ctr = ctr;
          this.validations = null;
          this.ctx = null;
          this.dismiss = 0;
          this.log = false;
          this.locked = false;
          this.domWay = DomObjectTransport.domWay;
          this.objectWay = DomObjectTransport.objectWay;
          if (null == bindingType) {
            bindingType = 'dual';
            var name = ctr.compoName;
            if (':bind' === name || 'bind' === name) {
              bindingType = 'single';
            }
          }
          var attr = ctr.attr;
          this.bindingType = bindingType;
          this.value = attr.value;
          this.property = attr[A_property];
          this.domSetter = attr['dom-setter'] || attr.setter;
          this.domGetter = attr['dom-getter'] || attr.getter;
          this.objSetter = attr['obj-setter'];
          this.objGetter = attr['obj-getter'];
          this.mapToObj = attr['map-to-obj'];
          this.mapToDom = attr['map-to-dom'];
          this.owner = ctr.parent;
          this.changeEvent = attr[A_change_event] || 'change';
          /* Convert to an instance, e.g. Number, on domchange event */          this.typeOf = attr['typeof'] || null;
          var isCompoBinder = ctr.node.parent.tagName === this.owner.compoName;
          switch (true) {
           case A_dom_slot in attr:
            this.domListenerType = 'signal';
            break;

           case A_change_event in attr:
            this.domListenerType = 'event';
            break;

           case isCompoBinder && A_property in attr:
            this.domListenerType = 'observe';
            break;
          }
          if (isCompoBinder) {
            if ('observe' === this.domListenerType) {
              this.domWay = DomObjectTransport.domModelWay;
            } else {
              var isInput = 1 === element.nodeType && ('INPUT' === element.tagName || 'TEXTAREA' === element.tagName);
              if (false === isInput) {
                if (null == this.domSetter) {
                  this.domSetter = 'setValue';
                }
                if (null == this.domGetter) {
                  this.domGetter = 'getValue';
                }
                if (null == attr[A_dom_slot]) {
                  attr[A_dom_slot] = 'input';
                }
              }
            }
          }
          if (null == this.domListenerType) {
            this.domListenerType = 'event';
          }
          if (null == this.property && null == this.domGetter) {
            switch (element.tagName) {
             case 'INPUT':
              // Do not use .type accessor, as some browsers do not support e.g. date
              var type = element.getAttribute('type');
              if ('checkbox' === type) {
                this.property = 'element.checked';
                break;
              }
              if ('radio' === type) {
                this.domWay = DomObjectTransport.RADIO.domWay;
                break;
              }
              if ('date' === type || 'time' === type || 'month' === type) {
                var x = DomObjectTransport[type.toUpperCase()];
                this.domWay = x.domWay;
                this.objectWay = x.objectWay;
              } else if ('number' === type) {
                this['typeOf'] = 'Number';
              }
              this.changeEvent = attr[A_change_event] || 'change,input';
              this.property = 'element.value';
              break;

             case 'TEXTAREA':
              this.property = 'element.value';
              break;

             case 'SELECT':
              this.domWay = element.multiple ? DomObjectTransport.SELECT_MULT : DomObjectTransport.SELECT;
              break;

             default:
              this.property = 'element.innerHTML';
              break;
            }
          }
          if (attr['log']) {
            this.log = true;
            if ('log' !== attr.log) {
              this.logExpression = attr.log;
            }
          }
          // Send signal on OBJECT or DOM change
                    if (attr['x-signal']) {
            var signals = signal_parse(attr['x-signal'], null, 'dom'), i = signals.length;
            while (--i > -1) {
              var signal = signals[i], signalType = signal && signal.type;
              if ('dom' !== signalType && 'object' !== signalType) {
                log_error('Signal typs is not supported', signal);
                continue;
              }
              this['signal_' + signalType + 'Changed'] = signal.signal;
            }
          }
          // Send PIPED signal on OBJECT or DOM change
                    if (attr['x-pipe-signal']) {
            signals = signal_parse(attr['x-pipe-signal'], true, 'dom'), i = signals.length;
            while (--i > -1) {
              signal = signals[i], signalType = signal && signal.type;
              if ('dom' !== signalType && 'object' !== signalType) {
                log_error('Pipe type is not supported', signal);
                continue;
              }
              this['pipe_' + signalType + 'Changed'] = signal;
            }
          }
          var domSlot = attr[A_dom_slot];
          if (null != domSlot) {
            this.slots = {};
            // @hack - place dualb. provider on the way of a signal
            //
                        var parent = ctr.parent, newparent = parent.parent;
            parent.parent = this;
            this.parent = newparent;
            this.slots[domSlot] = function(sender, value) {
              this.domChanged(sender, value);
            };
          }
          /*
			         *  @obsolete: attr name : 'x-pipe-slot'
			         */          var pipeSlot = attr['object-pipe-slot'] || attr['x-pipe-slot'];
          if (pipeSlot) {
            var str = pipeSlot, index = str.indexOf('.'), pipeName = str.substring(0, index);
            signal = str.substring(index + 1);
            this.pipes = {};
            this.pipes[pipeName] = {};
            this.pipes[pipeName][signal] = function() {
              this.objectChanged();
            };
            Component.pipe.addController(this);
          }
          var expression = attr.expression || ctr.expression;
          if (expression) {
            this.expression = expression;
            if (null == this.value && 'single' !== bindingType) {
              var refs = expression_varRefs(this.expression);
              if ('string' === typeof refs) {
                this.value = refs;
              } else {
                log_warn('Please set value attribute in DualBind Control.');
              }
            }
            return;
          }
          this.expression = this.value;
        }
        BindingProvider.prototype.dispose = function() {
          if (null != this.binder) {
            expression_unbind(this.expression, this.model, this.ctr, this.binder);
          }
          if (null != this.domObserveBinder) {
            expression_unbind(this.property, this.ctr, this.ctr, this.domObserveBinder);
          }
        };
        BindingProvider.prototype.objectChanged = function(val) {
          if (this.dismiss-- > 0) {
            return;
          }
          var isConcurrent = true === this.locked;
          if (isConcurrent) {
            log_warn('Concurrent change detected', this);
            // Set the value to dom anyway, but skip emitting
                    }
          this.locked = true;
          if (null == val || null != this.objGetter) {
            val = this.objectWay.get(this, this.expression);
          }
          if (null != this.mapToDom) {
            val = expression_callFn(this.mapToDom, this.model, null, this.ctr, [ val ]);
          }
          this.domWay.set(this, val);
          if (this.log) {
            console.log('[BindingProvider] objectChanged -', val);
          }
          if (false === isConcurrent) {
            var signal = this.signal_objectChanged;
            if (null != signal) {
              Component.signal.emitOut(this.ctr, signal, this.ctr, [ val ]);
            }
            var pipe = this.pipe_objectChanged;
            if (null != pipe) {
              Component.pipe(pipe.pipe).emit(pipe.signal);
            }
          }
          this.locked = false;
        };
        BindingProvider.prototype.domChanged = function(event, val) {
          if (true === this.locked) {
            log_warn('Concurance change detected', this);
            return;
          }
          this.locked = true;
          if (null == val) {
            val = this.domWay.get(this);
          }
          var typeof_ = this['typeOf'];
          if (null != typeof_) {
            var Converter = window[typeof_];
            val = Converter(val);
          }
          if (null != this.mapToObj) {
            val = expression_callFn(this.mapToObj, this.model, null, this.ctr, [ val ]);
          }
          var error = this.validate(val);
          if (null == error) {
            this.dismiss = 1;
            var tuple = expression_getHost(this.value, this.model, null, this.ctr.parent);
            if (null != tuple) {
              var obj = tuple[0], prop = tuple[1];
              this.objectWay.set(obj, prop, val, this);
            }
            this.dismiss = 0;
            if (this.log) {
              console.log('[BindingProvider] domChanged -', val);
            }
            if (null != this.signal_domChanged) {
              Component.signal.emitOut(this.ctr, this.signal_domChanged, this.ctr, [ val ]);
            }
            if (null != this.pipe_domChanged) {
              var pipe = this.pipe_domChanged;
              Component.pipe(pipe.pipe).emit(pipe.signal);
            }
          }
          this.locked = false;
        };
        BindingProvider.prototype.addValidation = function(mix) {
          if (null == this.validations) {
            this.validations = [];
          }
          if (is_Array(mix)) {
            this.validations = this.validations.concat(mix);
            return;
          }
          this.validations.push(mix);
        };
        BindingProvider.prototype.validate = function(val) {
          var fns = this.validations, ctr = this.ctr, el = this.element;
          if (null == fns || 0 === fns.length) {
            return null;
          }
          var val_ = 0 !== arguments.length ? val : this.domWay.get(this);
          return ValidatorProvider.validateUi(fns, val_, ctr, el, this.objectChanged.bind(this));
        };
        BindingProvider.create = function(model, el, ctr, bindingType) {
          /* Initialize custom provider */
          var provider, type = ctr.attr.bindingProvider, CustomProvider = null == type ? null : CustomProviders[type];
          if ('function' === typeof CustomProvider) {
            return new CustomProvider(model, el, ctr, bindingType);
          }
          provider = new BindingProvider(model, el, ctr, bindingType);
          if (null != CustomProvider) {
            obj_extend(provider, CustomProvider);
          }
          return provider;
        };
        BindingProvider.bind = function(provider) {
          return apply_bind(provider);
        };
        return BindingProvider;
      }();
      function apply_bind(provider) {
        var expr = provider.expression, model = provider.model, onObjChanged = provider.objectChanged = provider.objectChanged.bind(provider);
        provider.binder = expression_createBinder(expr, model, provider.ctx, provider.ctr, onObjChanged);
        expression_bind(expr, model, provider.ctx, provider.ctr, provider.binder);
        if ('dual' === provider.bindingType) {
          var onDomChange = provider.domChanged.bind(provider);
          switch (provider.domListenerType) {
           case 'event':
            var el = provider.element, event = provider.changeEvent, attachListener = Component.Dom.addEventListener;
            if (-1 !== event.indexOf(',')) {
              var arr = event.split(',');
              for (var i = 0; i < arr.length; i++) {
                attachListener(el, arr[i].trim(), onDomChange);
              }
            }
            attachListener(el, event, onDomChange);
            break;

           case 'observe':
            provider.domObserveBinder = onDomChange;
            expression_bind(provider.property, provider.owner, provider.ctx, null, onDomChange);
            break;
          }
          if (null == provider.objectWay.get(provider, provider.expression)) {
            // object has no value, so check the dom            
            setTimeout(function() {
              if (provider.domWay.get(provider)) {
                // and apply when exists
                provider.domChanged();
              }
            });
            return provider;
          }
        }
        // trigger update
                provider.objectChanged();
        return provider;
      }
    })();
    (function() {
      (function() {
        /**
				 * visible handler. Used to bind directly to display:X/none
				 *
				 * attr =
				 *    check - expression to evaluate
				 *    bind - listen for a property change
				 */
        function VisibleHandler() {}
        customTag_register(':visible', VisibleHandler);
        VisibleHandler.prototype = {
          constructor: VisibleHandler,
          refresh: function(model, container) {
            container.style.display = expression_eval(this.attr.check, model) ? '' : 'none';
          },
          renderStart: function(model, cntx, container) {
            this.refresh(model, container);
            if (this.attr.bind) {
              obj_addObserver(model, this.attr.bind, this.refresh.bind(this, model, container));
            }
          }
        };
      })();
      var ValidationCompo;
      (function() {
        var class_INVALID = '-validate-invalid';
        ValidationCompo = class_create({
          attr: null,
          element: null,
          validators: null,
          constructor: function() {
            this.validators = [];
          },
          renderStart: function(model, ctx, container) {
            this.element = container;
            var prop = this.attr.value;
            if (prop) {
              var fn = ValidatorProvider.getFnFromModel(model, prop);
              if (null != fn) {
                this.validators.push(fn);
              }
            }
          },
          /**
				     * @param input - {control specific} - value to validate
				     * @param element - {HTMLElement} - (optional, @default this.element) -
				     *				Invalid message is schown(inserted into DOM) after this element
				     * @param oncancel - {Function} - Callback function for canceling
				     *				invalid notification
				     */
          validate: function(val, el, oncancel) {
            var element = null == el ? this.element : el, value = val;
            if (0 === arguments.length) {
              value = obj_getProperty(this.model, this.attr.value);
            }
            if (0 === this.validators.length) {
              this.initValidators();
            }
            var fns = this.validators, type = this.attr.silent ? 'validate' : 'validateUi';
            return ValidatorProvider[type](fns, value, this, element, oncancel);
          },
          initValidators: function() {
            var attr = this.attr, message = this.attr.message, isDefault = null == message;
            if (isDefault) {
              message = 'Invalid value of `' + this.attr.value + '`';
            }
            for (var key in attr) {
              switch (key) {
               case 'message':
               case 'value':
               case 'getter':
               case 'silent':
                continue;
              }
              if (key in Validators === false) {
                log_error('Unknown Validator:', key, this);
                continue;
              }
              var str = isDefault ? message + ' Validation: `' + key + '`' : message;
              var fn = ValidatorProvider.getFnByName(key, attr[key], str);
              if (null != fn) {
                this.validators.push(fn);
              }
            }
          }
        });
        customTag_register(':validate', ValidationCompo);
        customTag_register(':validate:message', Component.create({
          template: 'div.' + class_INVALID + ' { span > "~[bind:message]" button > "~[cancel]" }',
          onRenderStart: function(model) {
            if ('string' === typeof model) {
              model = {
                message: model
              };
            }
            if (!model.cancel) {
              model.cancel = 'cancel';
            }
            this.model = model;
          },
          compos: {
            button: '$: button'
          },
          show: function(message, oncancel) {
            var that = this;
            this.model.message = message;
            this.compos.button.off().on(function() {
              that.hide();
              oncancel && oncancel();
            });
            this.$.show();
          },
          hide: function() {
            this.$.hide();
          }
        }));
      })();
      (function() {
        function ValidateGroup() {}
        customTag_register(':validate:group', ValidateGroup);
        ValidateGroup.prototype = {
          constructor: ValidateGroup,
          validate: function() {
            var validations = getValidations(this);
            for (var x, i = 0, length = validations.length; i < length; i++) {
              x = validations[i];
              if (!x.validate()) {
                return false;
              }
            }
            return true;
          }
        };
        function getValidations(component, out) {
          if (void 0 === out) {
            out = [];
          }
          if (null == component.components) {
            return out;
          }
          var compos = component.components;
          for (var x, i = 0, length = compos.length; i < length; i++) {
            x = compos[i];
            if ('validate' === x.compoName) {
              out.push(x);
              continue;
            }
            getValidations(x, out);
          }
          return out;
        }
      })();
      (function() {
        /**
				 *  Mask Custom Tag Handler
				 *	attr =
				 *		attr: {String} - attribute name to bind
				 *		prop: {Stirng} - property name to bind
				 *		- : {default} - innerHTML
				 */
        (function() {
          function Bind() {}
          customTag_register(':bind', Bind);
          customTag_register('bind', Bind);
          Bind.prototype = {
            constructor: Bind,
            renderEnd: function(els, model, cntx, container) {
              this.provider = BindingProvider.create(model, container, this, 'single');
              BindingProvider.bind(this.provider);
            },
            dispose: function() {
              if (this.provider && 'function' === typeof this.provider.dispose) {
                this.provider.dispose();
              }
            }
          };
        })();
      })();
      (function() {
        /**
				 *	Mask Custom Handler
				 *
				 *	2 Way Data Model binding
				 *
				 *
				 *	attr =
				 *		value: {string} - property path in object
				 *		?property : {default} 'element.value' - value to get/set from/to HTMLElement
				 *		?changeEvent: {default} 'change' - listen to this event for HTMLELement changes
				 *
				 *		?setter: {string} - setter function of a parent controller
				 *		?getter: {string} - getter function of a parent controller
				 *
				 *
				 */
        var DualbindCompo = class_create({
          renderEnd: function(elements, model, ctx, container) {
            this.provider = BindingProvider.create(model, container, this);
            var compos = this.components;
            if (null != compos) {
              var x, imax = compos.length, i = -1;
              while (++i < imax) {
                x = compos[i];
                if (':validate' === x.compoName) {
                  this.provider.addValidation(x.validations);
                }
              }
            }
            if (null == this.attr['no-validation']) {
              var fn = ValidatorProvider.getFnFromModel(model, this.provider.value);
              if (null != fn) {
                this.provider.addValidation(fn);
              }
            }
            BindingProvider.bind(this.provider);
          },
          dispose: function() {
            var dispose = this.provider && this.provider.dispose;
            if (null != dispose) {
              dispose.call(this.provider);
            }
          },
          validate: function() {
            return this.provider && this.provider.validate();
          },
          handlers: {
            attr: {
              'x-signal': function() {}
            }
          }
        });
        customTag_register(':dualbind', DualbindCompo);
        customTag_register('dualbind', DualbindCompo);
      })();
      //#if (BROWSER)
      //#endif
        })();
    (function() {
      var arr_createRefs, list_sort, list_update, list_remove, LoopStatementProto, dom_removeAll, dom_insertAfter, dom_insertBefore, compo_fragmentInsert, compo_renderChildren, compo_dispose, compo_disposeChildren, compo_inserted;
      var _getNodes, _renderPlaceholder, _compo_initAndBind, els_toggleVisibility;
      (function() {
        _getNodes = function(name, node, model, ctx, controller) {
          return custom_Statements[name].getNodes(node, model, ctx, controller);
        };
        _renderPlaceholder = function(staticCompo, compo, container) {
          var placeholder = staticCompo.placeholder;
          if (null == placeholder) {
            placeholder = _document.createComment('');
            container.appendChild(placeholder);
          }
          compo.placeholder = placeholder;
        };
        _compo_initAndBind = function(compo, node, model, ctx, container, controller) {
          compo.parent = controller;
          compo.model = model;
          compo.ctx = ctx;
          compo.refresh = fn_proxy(compo.refresh, compo);
          compo.binder = expression_createBinder(compo.expr || compo.expression, model, ctx, controller, compo.refresh);
          expression_bind(compo.expr || compo.expression, model, ctx, controller, compo.binder);
        };
        (function() {
          els_toggleVisibility = function(mix, state) {
            if (null == mix) {
              return;
            }
            if (is_Array(mix)) {
              _arr(mix, state);
              return;
            }
            _single(mix, state);
          };
          function _single(el, state) {
            el.style.display = state ? '' : 'none';
          }
          function _arr(els, state) {
            var imax = els.length, i = -1;
            while (++i < imax) {
              _single(els[i], state);
            }
          }
        })();
      })();
      (function() {
        (function() {
          function dom_removeElement(el) {
            var parent = el.parentNode;
            if (null == parent) {
              return el;
            }
            return parent.removeChild(el);
          }
          dom_removeAll = function(arr) {
            arr_each(arr, dom_removeElement);
          };
          dom_insertAfter = function(el, anchor) {
            return anchor.parentNode.insertBefore(el, anchor.nextSibling);
          };
          dom_insertBefore = function(el, anchor) {
            return anchor.parentNode.insertBefore(el, anchor);
          };
        })();
        (function() {
          compo_fragmentInsert = function(compo, index, fragment, placeholder) {
            if (null == compo.components) {
              return dom_insertAfter(fragment, placeholder || compo.placeholder);
            }
            var compos = compo.components, anchor = null, insertBefore = true, imax = compos.length, i = index - 1;
            if (null == anchor) {
              while (++i < imax) {
                var arr = compos[i].elements;
                if (null != arr && 0 !== arr.length) {
                  anchor = arr[0];
                  break;
                }
              }
            }
            if (null == anchor) {
              insertBefore = false;
              i = index < imax ? index : imax;
              while (--i > -1) {
                arr = compos[i].elements;
                if (null != arr && 0 !== arr.length) {
                  anchor = arr[arr.length - 1];
                  break;
                }
              }
            }
            if (null == anchor) {
              anchor = placeholder || compo.placeholder;
            }
            if (insertBefore) {
              return dom_insertBefore(fragment, anchor);
            }
            return dom_insertAfter(fragment, anchor);
          };
          compo_renderChildren = function(compo, anchor, model) {
            var fragment = _document.createDocumentFragment();
            var ctx = new builder_Ctx(compo.ctx);
            compo.elements = compo_renderElements(compo.nodes, model || compo.model, ctx, fragment, compo);
            dom_insertBefore(fragment, anchor);
            compo_inserted(compo, ctx);
          };
          // export function compo_renderElements (nodes, model, ctx, el, ctr, children?){
          //     if (nodes == null){
          //         return null;
          //     }
          //     var arr = [];
          //     builder_build(nodes, model, ctx, el, ctr, arr);
          //     if (is_Array(children)) {
          //         children.push.apply(children, arr);
          //     }
          //     return arr;
          // };
                    compo_dispose = function(compo, parent) {
            if (null == compo) {
              return false;
            }
            if (null != compo.elements) {
              dom_removeAll(compo.elements);
              compo.elements = null;
            }
            Component.dispose(compo);
            var compos = parent && parent.components || compo.parent && compo.parent.components;
            if (null == compos) {
              log_error('Parent Components Collection is undefined');
              return false;
            }
            return arr_remove(compos, compo);
          };
          compo_disposeChildren = function(compo) {
            var els = compo.elements;
            if (null != els) {
              dom_removeAll(els);
              compo.elements = null;
            }
            var compos = compo.components;
            if (null != compos) {
              var imax = compos.length, i = -1;
              while (++i < imax) {
                Component.dispose(compos[i]);
              }
              compos.length = 0;
            }
          };
          compo_inserted = function(compo, ctx) {
            if (null == ctx || 'object' !== typeof ctx || true !== ctx.async) {
              Component.signal.emitIn(compo, 'domInsert');
            } else {
              ctx.done(function() {
                Component.signal.emitIn(compo, 'domInsert');
              });
            }
          };
        })();
        customTag_register('+if', {
          placeholder: null,
          meta: {
            serializeNodes: true
          },
          render: function(model, ctx, container, ctr, children) {
            var node = this, nodes = _getNodes('if', node, model, ctx, ctr), index = 0, next = node;
            while (next.nodes !== nodes) {
              index++;
              next = node.nextSibling;
              if (null == next || 'else' !== next.tagName) {
                index = null;
                break;
              }
            }
            this.attr['switch-index'] = index;
            return compo_renderElements(nodes, model, ctx, container, ctr, children);
          },
          renderEnd: function(els, model, ctx, container, ctr) {
            var compo = new IFStatement(), index = this.attr['switch-index'];
            _renderPlaceholder(this, compo, container);
            return initialize(compo, this, index, els, model, ctx, container, ctr);
          },
          serializeNodes: function(current) {
            var nodes = [ current ];
            while (true) {
              current = current.nextSibling;
              if (null == current || 'else' !== current.tagName) {
                break;
              }
              nodes.push(current);
            }
            return mask_stringify(nodes);
          }
        });
        function IFStatement() {}
        IFStatement.prototype = {
          compoName: '+if',
          ctx: null,
          model: null,
          controller: null,
          index: null,
          Switch: null,
          binder: null,
          refresh: function() {
            var currentIndex = this.index, model = this.model, ctx = this.ctx, ctr = this.controller, switch_ = this.Switch, imax = switch_.length, i = -1;
            while (++i < imax) {
              var node = switch_[i].node;
              var expr = node.expression;
              if (null == expr) {
                break;
              }
              if (expression_eval_safe(expr, model, ctx, ctr, node)) {
                break;
              }
            }
            if (currentIndex === i) {
              return;
            }
            if (null != currentIndex) {
              els_toggleVisibility(switch_[currentIndex].elements, false);
            }
            if (i === imax) {
              this.index = null;
              return;
            }
            this.index = i;
            var current = switch_[i];
            if (null != current.elements) {
              els_toggleVisibility(current.elements, true);
              return;
            }
            var nodes = current.node.nodes, frag = _document.createDocumentFragment(), owner = {
              components: [],
              parent: ctr
            }, els = compo_renderElements(nodes, model, ctx, frag, owner);
            dom_insertBefore(frag, this.placeholder);
            current.elements = els;
            compo_inserted(owner);
            if (null == ctr.components) {
              ctr.components = [];
            }
            ctr.components.push.apply(ctr.components, owner.components);
          },
          dispose: function() {
            var x, expr, switch_ = this.Switch, imax = switch_.length, i = -1;
            while (++i < imax) {
              x = switch_[i];
              expr = x.node.expression;
              if (expr) {
                expression_unbind(expr, this.model, this.controller, this.binder);
              }
              x.node = null;
              x.elements = null;
            }
            this.controller = null;
            this.model = null;
            this.ctx = null;
          }
        };
        function initialize(compo, node, index, elements, model, ctx, container, ctr) {
          compo.model = model;
          compo.ctx = ctx;
          compo.controller = ctr;
          compo.refresh = fn_proxy(compo.refresh, compo);
          compo.binder = expression_createListener(compo.refresh);
          compo.index = index;
          compo.Switch = [ {
            node: node,
            elements: null
          } ];
          expression_bind(node.expression, model, ctx, ctr, compo.binder);
          while (true) {
            node = node.nextSibling;
            if (null == node || 'else' !== node.tagName) {
              break;
            }
            compo.Switch.push({
              node: node,
              elements: null
            });
            if (node.expression) {
              expression_bind(node.expression, model, ctx, ctr, compo.binder);
            }
          }
          if (null != index) {
            compo.Switch[index].elements = elements;
          }
          return compo;
        }
      })();
      (function() {
        (function() {
          arr_createRefs = function(array) {
            var imax = array.length, i = -1;
            while (++i < imax) {
              //create references from values to distinguish the models
              var x = array[i];
              switch (typeof x) {
               case 'string':
               case 'number':
               case 'boolean':
                array[i] = Object(x);
                break;
              }
            }
          };
          list_sort = function(self, array) {
            var compos = self.node.components, i = 0, imax = compos.length, j = 0, jmax = null, element = null, compo = null, fragment = _document.createDocumentFragment(), sorted = [];
            for (;i < imax; i++) {
              compo = compos[i];
              if (null == compo.elements || 0 === compo.elements.length) {
                continue;
              }
              for (j = 0, jmax = compo.elements.length; j < jmax; j++) {
                element = compo.elements[j];
                element.parentNode.removeChild(element);
              }
            }
            outer: for (j = 0, jmax = array.length; j < jmax; j++) {
              for (i = 0; i < imax; i++) {
                if (array[j] === self._getModel(compos[i])) {
                  sorted[j] = compos[i];
                  continue outer;
                }
              }
              console.warn('No Model Found for', array[j]);
            }
            for (i = 0, imax = sorted.length; i < imax; i++) {
              compo = sorted[i];
              if (null == compo.elements || 0 === compo.elements.length) {
                continue;
              }
              for (j = 0, jmax = compo.elements.length; j < jmax; j++) {
                element = compo.elements[j];
                fragment.appendChild(element);
              }
            }
            self.components = self.node.components = sorted;
            dom_insertBefore(fragment, self.placeholder);
          };
          list_update = function(self, deleteIndex, deleteCount, insertIndex, rangeModel) {
            var node = self.node, compos = node.components;
            if (null == compos) {
              compos = node.components = [];
            }
            self.prop1, self.prop2, self.type;
            var ctx = self.ctx, ctr = self.node;
            if (null != deleteIndex && null != deleteCount) {
              var i = deleteIndex, length = deleteIndex + deleteCount;
              if (length > compos.length) {
                length = compos.length;
              }
              for (;i < length; i++) {
                if (compo_dispose(compos[i], node)) {
                  i--;
                  length--;
                }
              }
            }
            if (null != insertIndex && rangeModel && rangeModel.length) {
              i = compos.length;
              var imax, fragment = self._build(node, rangeModel, ctx, ctr), new_ = compos.splice(i);
              compo_fragmentInsert(node, insertIndex, fragment, self.placeholder);
              compos.splice.apply(compos, [ insertIndex, 0 ].concat(new_));
              i = 0;
              imax = new_.length;
              for (;i < imax; i++) {
                Component.signal.emitIn(new_[i], 'domInsert');
              }
            }
          };
          list_remove = function(self, removed) {
            var compos = self.components, i = compos.length;
            while (--i > -1) {
              var x = compos[i];
              if (-1 === removed.indexOf(x.model)) {
                continue;
              }
              compo_dispose(x, self.node);
            }
          };
        })();
        (function() {
          LoopStatementProto = {
            ctx: null,
            model: null,
            parent: null,
            binder: null,
            refresh: function(value, method, args, result) {
              var i = 0;
              var node = this.node, ctx = (this.model, this.ctx), ctr = this.node;
              if (null == method) {
                // this was new array/object setter and not an immutable function call
                var compos = node.components;
                if (null != compos) {
                  var imax = compos.length;
                  i = -1;
                  while (++i < imax) {
                    if (compo_dispose(compos[i], node)) {
                      i--;
                      imax--;
                    }
                  }
                  compos.length = 0;
                }
                var frag = this._build(node, value, ctx, ctr);
                dom_insertBefore(frag, this.placeholder);
                arr_each(node.components, compo_inserted);
                return;
              }
              var array = value;
              arr_createRefs(value);
              switch (method) {
               case 'push':
                list_update(this, null, null, array.length - 1, array.slice(array.length - 1));
                break;

               case 'pop':
                list_update(this, array.length, 1);
                break;

               case 'unshift':
                list_update(this, null, null, 0, array.slice(0, 1));
                break;

               case 'shift':
                list_update(this, 0, 1);
                break;

               case 'splice':
                var sliceStart = args[0], sliceRemove = 1 === args.length ? this.components.length : args[1], sliceAdded = args.length > 2 ? array.slice(args[0], args.length - 2 + args[0]) : null;
                list_update(this, sliceStart, sliceRemove, sliceStart, sliceAdded);
                break;

               case 'sort':
               case 'reverse':
                list_sort(this, array);
                break;

               case 'remove':
                if (null != result && result.length) {
                  list_remove(this, result);
                }
                break;
              }
            },
            dispose: function() {
              expression_unbind(this.expr || this.expression, this.model, this.parent, this.binder);
            }
          };
        })();
        var For = custom_Statements['for'], attr_PROP_1 = 'for-prop-1', attr_PROP_2 = 'for-prop-2', attr_TYPE = 'for-type', attr_EXPR = 'for-expr';
        customTag_register('+for', {
          meta: {
            serializeNodes: true
          },
          serializeNodes: function(node) {
            return mask_stringify(node);
          },
          render: function(model, ctx, container, ctr, children) {
            var directive = For.parseFor(this.expression), attr = this.attr;
            attr[attr_PROP_1] = directive[0];
            attr[attr_PROP_2] = directive[1];
            attr[attr_TYPE] = directive[2];
            attr[attr_EXPR] = directive[3];
            var value = expression_eval(directive[3], model, ctx, ctr);
            if (null == value) {
              return;
            }
            if (is_Array(value)) {
              arr_createRefs(value);
            }
            For.build(value, directive, this.nodes, model, ctx, container, this, children);
          },
          renderEnd: function(els, model, ctx, container, ctr) {
            var compo = new ForStatement(this, this.attr);
            _renderPlaceholder(this, compo, container);
            _compo_initAndBind(compo, this, model, ctx, container, ctr);
            return compo;
          },
          getHandler: function(name, model) {
            return For.getHandler(name, model);
          }
        });
        function ForStatement(node, attr) {
          this.prop1 = attr[attr_PROP_1];
          this.prop2 = attr[attr_PROP_2];
          this.type = attr[attr_TYPE];
          this.expr = attr[attr_EXPR];
          if (null == node.components) {
            node.components = [];
          }
          this.node = node;
          this.components = node.components;
        }
        ForStatement.prototype = {
          compoName: '+for',
          model: null,
          parent: null,
          refresh: LoopStatementProto.refresh,
          dispose: LoopStatementProto.dispose,
          _getModel: function(compo) {
            return compo.scope[this.prop1];
          },
          _build: function(node, model, ctx, component) {
            var nodes = For.getNodes(node.nodes, model, this.prop1, this.prop2, this.type);
            return builder_build(nodes, this.model, ctx, null, component);
          }
        };
      })();
      (function() {
        var EachBinded = {
          meta: {
            serializeNodes: true
          },
          serializeNodes: function(node) {
            return mask_stringify(node);
          },
          //modelRef: null,
          render: function(model, ctx, container, ctr, children) {
            //this.modelRef = this.expression;
            var array = expression_eval(this.expression, model, ctx, ctr);
            if (null == array) {
              return;
            }
            arr_createRefs(array);
            build(this.nodes, array, ctx, container, this, children);
          },
          renderEnd: function(els, model, ctx, container, ctr) {
            var compo = new EachStatement(this, this.attr);
            _renderPlaceholder(this, compo, container);
            _compo_initAndBind(compo, this, model, ctx, container, ctr);
            return compo;
          }
        };
        var EachItem = class_create({
          compoName: 'each::item',
          scope: null,
          model: null,
          modelRef: null,
          parent: null,
          renderEnd: function(els) {
            this.elements = els;
          },
          dispose: function() {
            if (null != this.elements) {
              this.elements.length = 0;
              this.elements = null;
            }
          }
        });
        var EachStatement = class_create(LoopStatementProto, {
          compoName: '+each',
          constructor: function EachStatement(node, attr) {
            this.expression = node.expression;
            this.nodes = node.nodes;
            if (null == node.components) {
              node.components = [];
            }
            this.node = node;
            this.components = node.components;
          },
          _getModel: function(compo) {
            return compo.model;
          },
          _build: function(node, model, ctx, component) {
            var fragment = _document.createDocumentFragment();
            build(node.nodes, model, ctx, fragment, component);
            return fragment;
          }
        });
        // METHODS
                function build(nodes, array, ctx, container, ctr, elements) {
          var node, imax = array.length, i = (new Array(imax), 0);
          for (;i < imax; i++) {
            node = createEachNode(nodes, i);
            builder_build(node, array[i], ctx, container, ctr, elements);
          }
        }
        function createEachNode(nodes, index) {
          var item = new EachItem();
          item.scope = {
            index: index
          };
          return {
            type: Dom.COMPONENT,
            tagName: 'each::item',
            nodes: nodes,
            controller: function() {
              return item;
            }
          };
        }
        // EXPORTS
                customTag_register('each::item', EachItem);
        customTag_register('+each', EachBinded);
      })();
      (function() {
        (function() {
          var $Switch = customStatement_get('switch'), attr_SWITCH = 'switch-index';
          var _nodes, _index;
          customTag_register('+switch', {
            meta: {
              serializeNodes: true
            },
            serializeNodes: function(current) {
              return mask_stringify(current);
            },
            render: function(model, ctx, container, ctr, children) {
              var value = expression_eval_safe(this.expression, model, ctx, ctr);
              resolveNodes(value, this.nodes, model, ctx, ctr);
              var nodes = _nodes, index = _index;
              if (null == nodes) {
                return null;
              }
              this.attr[attr_SWITCH] = index;
              return compo_renderElements(nodes, model, ctx, container, ctr, children);
            },
            renderEnd: function(els, model, ctx, container, ctr) {
              var compo = new SwitchStatement(), index = this.attr[attr_SWITCH];
              _renderPlaceholder(this, compo, container);
              return initialize(compo, this, index, els, model, ctx, container, ctr);
            }
          });
          function SwitchStatement() {}
          SwitchStatement.prototype = {
            compoName: '+switch',
            ctx: null,
            model: null,
            controller: null,
            index: null,
            nodes: null,
            Switch: null,
            binder: null,
            refresh: function(value) {
              var compo = this, Switch = compo.Switch, model = compo.model, ctx = compo.ctx, ctr = compo.controller;
              resolveNodes(value, compo.nodes, model, ctx, ctr);
              var nodes = _nodes, index = _index;
              if (index === compo.index) {
                return;
              }
              if (null != compo.index) {
                els_toggleVisibility(Switch[compo.index], false);
              }
              compo.index = index;
              if (null == index) {
                return;
              }
              var elements = Switch[index];
              if (null != elements) {
                els_toggleVisibility(elements, true);
                return;
              }
              var result = renderer_render(nodes, model, ctx, null, ctr);
              Switch[index] = result.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? _Array_slice.call(result.childNodes) : result;
              dom_insertBefore(result, compo.placeholder);
            },
            dispose: function() {
              expression_unbind(this.expr, this.model, this.controller, this.binder);
              this.controller = null;
              this.model = null;
              this.ctx = null;
              var key, els, i, imax, switch_ = this.Switch;
              for (key in switch_) {
                els = switch_[key];
                if (null == els) {
                  continue;
                }
                imax = els.length;
                i = -1;
                while (++i < imax) {
                  if (null != els[i].parentNode) {
                    els[i].parentNode.removeChild(els[i]);
                  }
                }
              }
            }
          };
          function resolveNodes(val, nodes, model, ctx, ctr) {
            _nodes = $Switch.getNodes(val, nodes, model, ctx, ctr);
            _index = null;
            if (null == _nodes) {
              return;
            }
            var imax = nodes.length, i = -1;
            while (++i < imax) {
              if (nodes[i].nodes === _nodes) {
                break;
              }
            }
            _index = i === imax ? null : i;
          }
          function initialize(compo, node, index, elements, model, ctx, container, ctr) {
            compo.ctx = ctx;
            compo.expr = node.expression;
            compo.model = model;
            compo.controller = ctr;
            compo.index = index;
            compo.nodes = node.nodes;
            compo.refresh = fn_proxy(compo.refresh, compo);
            compo.binder = expression_createBinder(compo.expr, model, ctx, ctr, compo.refresh);
            compo.Switch = new Array(node.nodes.length);
            if (null != index) {
              compo.Switch[index] = elements;
            }
            expression_bind(node.expression, model, ctx, ctr, compo.binder);
            return compo;
          }
        })();
      })();
      (function() {
        (function() {
          customTag_register('+with', {
            meta: {
              serializeNodes: true
            },
            rootModel: null,
            render: function(model, ctx, container, ctr) {
              var expr = this.expression, nodes = this.nodes, val = expression_eval(expr, model, ctx, ctr);
              this.rootModel = model;
              return compo_renderElements(nodes, val, ctx, container, ctr);
            },
            onRenderStartClient: function(model, ctx) {
              this.rootModel = model;
              this.model = expression_eval(this.expression, model, ctx, this);
            },
            renderEnd: function(els, model_, ctx, container, ctr) {
              var model = this.rootModel || model_, compo = new WithStatement(this);
              compo.elements = els;
              compo.model = model;
              compo.parent = ctr;
              compo.refresh = fn_proxy(compo.refresh, compo);
              compo.binder = expression_createBinder(compo.expr, model, ctx, ctr, compo.refresh);
              expression_bind(compo.expr, model, ctx, ctr, compo.binder);
              _renderPlaceholder(this, compo, container);
              return compo;
            }
          });
          function WithStatement(node) {
            this.expr = node.expression;
            this.nodes = node.nodes;
          }
          WithStatement.prototype = {
            compoName: '+with',
            elements: null,
            binder: null,
            model: null,
            parent: null,
            refresh: function(model) {
              compo_disposeChildren(this);
              compo_renderChildren(this, this.placeholder, model);
            },
            dispose: function() {
              expression_unbind(this.expr, this.model, this.parent, this.binder);
              this.parent = null;
              this.model = null;
              this.ctx = null;
            }
          };
        })();
      })();
      (function() {
        (function() {
          var $Visible = customStatement_get('visible');
          customTag_register('+visible', {
            meta: {
              serializeNodes: true
            },
            render: function(model, ctx, container, ctr, childs) {
              return build(this.nodes, model, ctx, container, ctr);
            },
            renderEnd: function(els, model, ctx, container, ctr) {
              var compo = new VisibleStatement(this);
              compo.elements = els;
              compo.model = model;
              compo.parent = ctr;
              compo.refresh = fn_proxy(compo.refresh, compo);
              compo.binder = expression_createBinder(compo.expr, model, ctx, ctr, compo.refresh);
              expression_bind(compo.expr, model, ctx, ctr, compo.binder);
              compo.refresh();
              return compo;
            }
          });
          function VisibleStatement(node) {
            this.expr = node.expression;
            this.nodes = node.nodes;
          }
          VisibleStatement.prototype = {
            compoName: '+visible',
            elements: null,
            binder: null,
            model: null,
            parent: null,
            refresh: function() {
              var isVisible = expression_eval_safe(this.expr, this.model, this.ctx, this);
              $Visible.toggle(this.elements, isVisible);
            },
            dispose: function() {
              expression_unbind(this.expr, this.model, this.parent, this.binder);
              this.parent = null;
              this.model = null;
              this.ctx = null;
            }
          };
          function build(nodes, model, ctx, container, ctr) {
            var els = [];
            builder_build(nodes, model, ctx, container, ctr, els);
            return els;
          }
        })();
      })();
      (function() {
        var Binders;
        (function() {
          var IBinder;
          var EventEmitterBinder;
          (function() {
            (function() {
              IBinder = class_create({
                constructor: function(exp, model, ctr) {
                  this.exp = exp;
                  this.ctr = ctr;
                  this.model = model;
                  this.cb = null;
                },
                on: null,
                bind: function(cb) {
                  this.cb = cb;
                  // we have here no access to the ctx, so pass null
                                    this.on(this.exp, this.model, null, this.ctr, cb);
                },
                dispose: function() {
                  this.off(this.exp, this.model, this.ctr, this.cb);
                  this.exp = this.model = this.ctr = this.cb = null;
                }
              });
            })();
            /*
						 *	"expression, ...args"
						 *	expression: to get the IEventEmitter
						 */            EventEmitterBinder = class_create(IBinder, {
              on: function(exp, model, ctx, ctr, cb) {
                call('on', exp, model, ctr, cb);
              },
              off: function(exp, model, ctr, cb) {
                call('off', exp, model, ctr, cb);
              }
            });
            function call(method, expr, model, ctr, cb) {
              var arr = expression_evalStatements(expr, model, null, ctr);
              var observable = arr.shift();
              if (null == observable || null == observable[method]) {
                log_error('Method is undefined on observable: ' + method);
                return;
              }
              arr.push(cb);
              observable[method].apply(observable, arr);
            }
          })();
          var ExpressionBinder;
          (function() {
            ExpressionBinder = class_create(IBinder, {
              on: expression_bind,
              off: expression_unbind
            });
          })();
          var RxBinder;
          (function() {
            /*
						 *	"expression, ...args"
						 *	expression: to get the RxObservable {subscribe:IDisposable}
						 */
            RxBinder = class_create(IBinder, {
              stream: null,
              on: function call(expr, model, ctr, cb) {
                var arr = expression_evalStatements(expr, model, null, ctr);
                var stream = arr.shift();
                if (null == stream || null == stream.subscribe) {
                  error_withCompo('Subscribe method is undefined on RxObservable', ctr);
                  return;
                }
                arr.push(cb);
                this.stream = stream.subscribe.apply(stream, arr);
              },
              off: function() {
                if (null == this.stream) {
                  return;
                }
                this.stream.dispose();
              }
            });
          })();
          Binders = {
            EventEmitterBinder: EventEmitterBinder,
            ExpressionBinder: ExpressionBinder,
            RxBinder: RxBinder
          };
        })();
        customTag_register('listen', class_create({
          disposed: false,
          placeholder: null,
          compoName: 'listen',
          show: null,
          hide: null,
          binder: null,
          meta: {
            serializeNodes: true,
            attributes: {
              animatable: false,
              on: false,
              rx: false
            }
          },
          renderEnd: function(els, model, ctx, container, ctr) {
            _renderPlaceholder(this, this, container);
            var fn = Boolean(this.attr.animatable) ? this.refreshAni : this.refreshSync;
            this.refresh = fn_proxy(fn, this);
            this.elements = els;
            var Ctor = this.getBinder();
            this.binder = new Ctor(this.expression, model, this);
            this.binder.bind(this.refresh);
          },
          getBinder: function() {
            if (this.attr.on) {
              return Binders.EventEmitterBinder;
            }
            if (this.attr.rx) {
              return Binders.RxBinder;
            }
            return Binders.ExpressionBinder;
          },
          dispose: function() {
            this.binder.dispose();
            this.disposed = true;
            this.elements = null;
          },
          refresh: function() {
            throw new Error('Should be defined by refreshSync/refreshAni');
          },
          refreshSync: function() {
            compo_disposeChildren(this);
            this.create();
          },
          create: function() {
            compo_renderChildren(this, this.placeholder);
          },
          refreshAni: function() {
            var _this = this;
            var x = {
              components: this.components,
              elements: this.elements
            };
            this.components = this.elements = null;
            var show = this.getAni('show');
            var hide = this.getAni('hide');
            if ('parallel' === this.attr.animatable) {
              show.start(this.create());
              hide.start(x.elements, function() {
                compo_dispose(x);
              });
              return;
            }
            hide.start(x.elements, function() {
              if (true === _this.disposed) {
                return;
              }
              compo_dispose(x);
              show.start(_this.create());
            });
          },
          getAni: function(name) {
            var x = this[name];
            if (null != x) {
              return x;
            }
            var ani = Component.child(this, 'Animation#' + name);
            if (null != ani) {
              return this[name] = ani.start.bind(ani);
            }
          }
        }));
      })();
    })();
    (function() {
      (function() {
        /**
				 *	Mask Custom Utility - for use in textContent and attribute values
				 */
        function attr_strReplace(attrValue, currentValue, newValue) {
          if (!attrValue) {
            return newValue;
          }
          if (null == currentValue || '' === currentValue) {
            return attrValue + ' ' + newValue;
          }
          return attrValue.replace(currentValue, newValue);
        }
        function refresherDelegate_NODE(el) {
          return function(value) {
            el.textContent = value;
          };
        }
        /** Attributes */        function refresherDelegate_ATTR(el, attrName, currentValue) {
          var current_ = currentValue;
          return function(value) {
            var currentAttr = el.getAttribute(attrName), attr = attr_strReplace(currentAttr, current_, value);
            if (null == attr || '' === attr) {
              el.removeAttribute(attrName);
            } else {
              el.setAttribute(attrName, attr);
            }
            current_ = value;
          };
        }
        function refresherDelegate_ATTR_COMPO(ctr, attrName, currentValue) {
          var current_ = currentValue;
          return function(val) {
            if (current_ === val) {
              return;
            }
            current_ = val;
            var fn = ctr.setAttribute;
            if (is_Function(fn)) {
              fn.call(ctr, attrName, val);
              return;
            }
            ctr.attr[attrName] = val;
          };
        }
        function refresherDelegate_ATTR_PROP(element, attrName, currentValue) {
          return function(value) {
            switch (typeof element[attrName]) {
             case 'boolean':
              currentValue = element[attrName] = !!value;
              return;

             case 'number':
              currentValue = element[attrName] = Number(value);
              return;

             case 'string':
              currentValue = element[attrName] = attr_strReplace(element[attrName], currentValue, value);
              return;

             default:
              log_warn('Unsupported elements property type', attrName);
              return;
            }
          };
        }
        /** Properties */        function refresherDelegate_PROP_NODE(el, property, currentValue) {
          return function(value) {
            obj_setProperty(el, property, value);
          };
        }
        function refresherDelegate_PROP_COMPO(ctr, property, currentValue) {
          var current_ = currentValue;
          return function(val) {
            if (current_ === val) {
              return;
            }
            current_ = val;
            obj_setProperty(ctr, property, val);
          };
        }
        function create_refresher(type, expr, element, currentValue, attrName, ctr) {
          if ('node' === type) {
            return refresherDelegate_NODE(element);
          }
          if ('attr' === type) {
            switch (attrName) {
             case 'value':
             case 'disabled':
             case 'checked':
             case 'selected':
             case 'selectedIndex':
              if (attrName in element) {
                return refresherDelegate_ATTR_PROP(element, attrName, currentValue);
              }
            }
            return refresherDelegate_ATTR(element, attrName, currentValue);
          }
          if ('prop' === type) {
            return refresherDelegate_PROP_NODE(element, attrName, currentValue);
          }
          if ('compo-attr' === type) {
            return refresherDelegate_ATTR_COMPO(ctr, attrName, currentValue);
          }
          if ('compo-prop' === type) {
            return refresherDelegate_PROP_COMPO(ctr, attrName, currentValue);
          }
          throw Error('Unexpected binder type: ' + type);
        }
        function bind(current, expr, model, ctx, element, ctr, attrName, type) {
          var owner = 'compo-attr' === type || 'compo-prop' === type ? ctr.parent : ctr;
          var refresher = create_refresher(type, expr, element, current, attrName, ctr), binder = expression_createBinder(expr, model, ctx, owner, refresher);
          expression_bind(expr, model, ctx, owner, binder);
          Component.attach(ctr, 'dispose', function() {
            expression_unbind(expr, model, owner, binder);
          });
        }
        customUtil_register('bind', {
          mode: 'partial',
          current: null,
          element: null,
          nodeRenderStart: function(expr, model, ctx, el, ctr, attrName, type, node) {
            var owner = 'compo-attr' === type || 'compo-prop' === type ? ctr.parent : ctr;
            var current = expression_eval_safe(expr, model, ctx, owner, node);
            // though we apply value's to `this` context, but it is only for immediat use
            // in .node() function, as `this` context is a static object that share all bind
            // utils
                        this.element = _document.createTextNode(current);
            return this.current = current;
          },
          node: function(expr, model, ctx, container, ctr) {
            var el = this.element, val = this.current;
            bind(val, expr, model, ctx, el, ctr, null, 'node');
            this.element = null;
            this.current = null;
            return el;
          },
          attrRenderStart: function(expr, model, ctx, el, ctr, attrName, type, node) {
            var owner = 'compo-attr' === type || 'compo-prop' === type ? ctr.parent : ctr;
            return this.current = expression_eval_safe(expr, model, ctx, owner, node);
          },
          attr: function(expr, model, ctx, element, controller, attrName, type) {
            bind(this.current, expr, model, ctx, element, controller, attrName, type);
            return this.current;
          }
        });
      })();
    })();
    BindingProviders = CustomProviders;
    registerBinding = function(name, Prov) {
      CustomProviders[name] = Prov;
    };
  })();
  /**
	 * @namespace mask
	 */  var Mask = {
    /**
	     * Render the mask template to document fragment or single html node
	     * @param {(string|MaskDom)} template - Mask string template or Mask Ast to render from.
	     * @param {*} [model] - Model Object.
	     * @param {Object} [ctx] - Context can store any additional information, that custom handler may need
	     * @param {IAppendChild} [container]  - Container Html Node where template is rendered into
	     * @param {Object} [controller] - Component that should own this template
	     * @returns {(IAppendChild|Node|DocumentFragment)} container
	     * @memberOf mask
	     */
    render: renderer_render,
    /**
	     * Same to `mask.render` but returns the promise, which is resolved when all async components
	     * are resolved, or is in resolved state, when all components are synchronous.
	     * For the parameters doc @see {@link mask.render}
	     * @returns {Promise} Fullfills with (`IAppendChild|Node|DocumentFragment`, `Component`)
	     * @memberOf mask
	     */
    renderAsync: renderer_renderAsync,
    parse: parser_parse,
    parseHtml: parser_parseHtml,
    stringify: mask_stringify,
    build: builder_build,
    buildSVG: builder_buildSVG,
    run: mask_run,
    merge: mask_merge,
    optimize: mask_optimize,
    registerOptimizer: mask_registerOptimizer,
    TreeWalker: mask_TreeWalker,
    Module: Module,
    File: Module.File,
    Di: Di,
    registerHandler: customTag_register,
    registerFromTemplate: customTag_registerFromTemplate,
    define: customTag_define,
    getHandler: customTag_get,
    getHandlers: customTag_getAll,
    registerStatement: customStatement_register,
    getStatement: customStatement_get,
    registerAttrHandler: customAttr_register,
    getAttrHandler: customAttr_get,
    registerUtil: customUtil_register,
    getUtil: customUtil_get,
    $utils: customUtil_$utils,
    _: customUtil_$utils,
    defineDecorator: Decorator.define,
    Dom: Dom,
    /**
	     * Is present only in DEBUG (not minified) version
	     * Evaluates script in masks library scope
	     * @param {string} script
	     */
    plugin: function(source) {},
    clearCache: renderer_clearCache,
    Utils: {
      Expression: ExpressionUtil,
      ensureTmplFn: parser_ensureTemplateFunction
    },
    obj: {
      get: obj_getProperty,
      set: obj_setProperty,
      extend: obj_extend,
      addObserver: obj_addObserver,
      removeObserver: obj_removeObserver
    },
    str: {
      dedent: str_dedent
    },
    is: {
      Function: is_Function,
      String: is_String,
      ArrayLike: is_ArrayLike,
      Array: is_ArrayLike,
      Object: is_Object,
      Date: is_Date,
      NODE: is_NODE,
      DOM: is_DOM
    },
    class: {
      create: class_create,
      createError: error_createClass,
      Deferred: class_Dfr,
      EventEmitter: class_EventEmitter
    },
    parser: {
      ObjectLexer: parser_ObjectLexer,
      getStackTrace: reporter_getNodeStack,
      defineContentTag: parser_defineContentTag
    },
    log: {
      info: log,
      error: log_error,
      errorWithNode: error_withNode,
      warn: log_warn,
      warnWithNode: warn_withNode
    },
    on: listeners_on,
    off: listeners_off,
    // Stub for the reload.js, which will be used by includejs.autoreload
    delegateReload: function() {},
    /**
	     * Define interpolation quotes for the parser
	     * Starting from 0.6.9 mask uses ~[] for string interpolation.
	     * Old '#{}' was changed to '~[]', while template is already overloaded with #, { and } usage.
	     * @param {string} start - Must contain 2 Characters
	     * @param {string} end - Must contain 1 Character
	     **/
    setInterpolationQuotes: parser_setInterpolationQuotes,
    setCompoIndex: function(index) {
      BuilderData.id = index;
    },
    cfg: mask_config,
    config: mask_config,
    // For the consistence with the NodeJS
    toHtml: function(dom) {
      return Mask.$(dom).outerHtml();
    },
    factory: function(compoName) {
      var params_ = _Array_slice.call(arguments, 1), factory = params_.pop(), mode = 'both';
      if (0 !== params_.length) {
        var x = params_[0];
        if ('client' === x || 'server' === x) {
          mode = x;
        }
      }
      if ('client' === mode && is_NODE || 'server' === mode && is_DOM) {
        customTag_register(compoName, {
          meta: {
            mode: mode
          }
        });
        return;
      }
      factory(_global, Component.config.getDOMLibrary(), function(compo) {
        customTag_register(compoName, compo);
      });
    },
    injectable: Di.deco.injectableClass,
    deco: {
      slot: Component.deco.slot,
      slotPrivate: Component.deco.slotPrivate,
      pipe: Component.deco.pipe,
      event: Component.deco.event,
      hotkey: Component.deco.hotkey,
      attr: Component.deco.attr,
      refCompo: Component.deco.refCompo,
      refElement: Component.deco.refElement,
      refQuery: Component.deco.refQuery,
      inject: Di.deco.injectableClass
    },
    templates: Templates,
    /* from binding */
    Validators: Validators,
    registerValidator: registerValidator,
    BindingProviders: BindingProviders,
    registerBinding: registerBinding,
    Compo: Compo,
    Component: Component,
    jmask: jMask,
    version: '0.71.78',
    $: domLib,
    j: jMask
  };
  //> make fast properties
    custom_optimize();
  return exports.mask = Mask;
});
// source /src/umd.es6
'use strict';

/*!
 * Form Component v0.10.42
 * Part of the Atma.js Project
 * http://atmajs.com/
 *
 * MIT license
 * http://opensource.org/licenses/MIT
 *
 * (c) 2012, 2020 Atma.js and other contributors
 */
(function (root, factory) {
	var _global = typeof global !== 'undefined' ? global : window,
	    _mask = resolve('mask', 'maskjs'),
	    _ruta = resolve('ruta', 'ruta');

	function resolve(property, npm) {
		var lib = _global[property] || _global.atma && _global.atma[property];
		if (lib != null) {
			return lib;
		}
		if (typeof require === 'function') {
			return require(npm);
		}
		throw Error(property + ' was not loaded');
	}

	factory(_global, _mask, _mask.jmask, _mask.Compo, _mask.Compo.config.getDOMLibrary(), _ruta);
})(undefined, function (global, mask, j, Compo, $, ruta) {

	// source utils/path.es6
	'use strict';

	var path_getCurrent;
	(function () {

		path_getCurrent = function path_getCurrent(ctx) {
			return mask.obj.get(ctx, 'req.url') || ruta.currentPath();
		};
	})();
	//# sourceMappingURL=path.es6.map
	// end:source utils/path.es6

	// source class/ViewData.es6
	'use strict';

	var ViewData, ViewState;

	(function () {

		ViewState = {
			NONE: 0,
			LOADING: 1,
			LOADED: 2,
			RENDERING: 3,
			RENDERED: 4
		};

		ViewData = mask.class.create({
			viewNode: null,
			nodes: null,
			compo: null,
			route: null,
			state: ViewState.NONE,
			path: null,
			/*
    * View is shown when no route is matched, otherwise viewManager decides
    * whether to hide everything, or to show an error
    */
			default: false,
			constructor: function constructor() {
				var imax = arguments.length,
				    i = -1;
				while (++i < imax) {
					var x = arguments.length <= i ? undefined : arguments[i];
					if (x == null) {
						continue;
					}
					mask.obj.extend(this, x);
					if (x.view != null && this.path == null) {
						this.path = x.view;
					}
				}
			},
			getNodes: function getNodes() {
				if (this.viewNode != null) {
					if (this.path != null && this.viewNode.nodes == null) {
						this.viewNode.nodes = mask.parse('import from \'' + this.path + '\'');
					}
					return this.viewNode;
				}
				if (this.nodes == null && this.path != null) {
					return this.nodes = mask.parse('import from \'' + this.path + '\'');
				}
				return this.nodes;
			},
			toJSON: function toJSON() {
				return {
					route: this.route,
					state: this.state,
					path: this.path,
					viewNode: this.viewNode ? mask.stringify(this.viewNode) : null,
					nodes: this.nodes ? mask.stringify(this.nodes) : null
				};
			},
			createViewNode: function createViewNode(nodes) {
				var $ = j(nodes);

				if (this.hasView_($) === false) {
					var container = this.viewNode || j('View');
					this.viewNode = j(container).append(nodes);
					return;
				}
				this.viewNode = $[0];
			},
			hasView_: function hasView_($nodes) {
				if ($nodes.length !== 1) {
					return false;
				}
				// Any Component supposed to be an IView
				var name = $nodes.tag();
				if (name[0] === name[0].toUpperCase()) {
					return true;
				}
				return false;
			}
		});

		ViewData.createFromNode = function (viewNode) {
			return new ViewData({
				viewNode: viewNode,
				route: viewNode.attr.route,
				path: viewNode.attr.path,
				'default': Boolean(viewNode.attr['default'])
			});
		};
		ViewData.createFromObj = function (data) {
			return new ViewData({
				route: data.route,
				path: data.path || data.view,
				'default': Boolean(data['default'])
			});
		};
	})();
	//# sourceMappingURL=ViewData.es6.map
	// end:source class/ViewData.es6
	// source class/ViewMap.es6
	'use strict';

	var ViewMap;
	(function () {
		ViewMap = mask.class.create({
			views: null,
			constructor: function constructor() {
				this.views = [];
			},
			add: function add(viewData) {
				this.views.push(viewData);
			},
			each: function each(fn) {
				var imax = this.views.length,
				    i = -1;
				while (++i < imax) {
					fn(this.views[i]);
				}
			},
			toJSON: function toJSON() {
				return this.views.map(function (x) {
					return x.toJSON();
				});
			}
		});

		ViewMap.ensure = function (viewManager, model, ctx) {
			var viewmap = viewManager.viewmap;
			if (viewmap != null) {
				return viewmap;
			}
			var viewmap = new ViewMap();
			var scoped = viewManager.scope.viewmap;

			if (scoped == null && viewManager.xViewmap) {
				var fn = mask.Utils.Expression.eval;
				scoped = fn(viewManager.xViewmap, model, ctx, viewManager);
			}

			if (scoped == null && mask.is.NODE) {
				scoped = ViewMap.getFromRoutes(viewManager, ctx);
			}

			if (mask.is.Array(scoped)) {
				var arr = scoped;
				arr.map(ViewData.createFromObj).forEach(function (x) {
					viewmap.add(new ViewData(viewmap[x.route], x));
				});
			} else if (mask.is.Object(scoped)) {
				var obj = scoped;
				for (var key in obj) {
					var entry = obj[key];
					if (entry.route == null) {
						entry.route = key;
					}
					viewmap.add(ViewData.createFromObj(entry));
				}
			}
			mask.jmask(viewManager.nodes).filter('View').map(ViewData.createFromNode).each(function (x) {
				viewmap.add(new ViewData(viewmap[x.route], x));
			});

			return viewManager.viewmap = viewmap;
		};

		ViewMap.getFromRoutes = function (vm, ctx) {
			if (ctx.page == null || ctx.config == null) {
				return null;
			}
			var current = ctx.page.data,
			    pages = ctx.config.pages,
			    key,
			    page,
			    arr = [];
			for (key in pages) {
				page = pages[key];
				if (page.template === current.template) {
					arr.push(page);
				}
			}
			return arr;
		};

		ViewMap.createRoutes = function (viewManager) {
			var viewmap = viewManager.viewmap,
			    views = viewmap.views,
			    imax = views.length,
			    i = -1;
			while (++i < imax) {
				var view = views[i];
				viewManager.routes.add(view.route, view);
			}
		};

		ViewMap.getRouteByPath = function (viewManager, path) {
			var routes = viewManager.routes,
			    route = routes.get(path);
			if (route) {
				return route;
			}
			var viewmap = viewManager.viewmap,
			    views = viewmap.views,
			    imax = views.length,
			    i = -1;
			while (++i < imax) {
				var view = views[i];
				if (view.default == true) {
					var route = routes.get(view.route);
					if (route.definition.indexOf('?') > -1) {
						ruta.navigate(route.definition, {
							extend: true,
							silent: true,
							replace: true
						});
					}
					return route;
				}
			}
			return null;
		};

		ViewMap.getRouteByPathOrCurrentOrDefault = function (viewManager, path, params) {
			var routes = viewManager.routes,
			    route = routes.get(path),
			    fromPath = route != null;
			if (route == null) {
				route = viewManager.route;
			} else {
				obj_default(route.current.params, params);
			}

			if (route == null) {
				var viewmap = viewManager.viewmap,
				    views = viewmap.views,
				    imax = views.length,
				    i = -1;
				while (++i < imax) {
					var view = views[i];
					if (view.default == true) {
						route = routes.get(view.route);
						break;
					}
				}
			}
			if (route == null) {
				return null;
			}
			if (fromPath === false && route.definition.indexOf('?') > -1) {
				ruta.navigate(route.definition, {
					extend: true,
					silent: true,
					replace: true
				});
			}
			return route;
		};

		ViewMap.bindRouter = function (viewManager, model, ctx) {
			var viewmap = ViewMap.ensure(viewManager, model, ctx);
			if (viewmap == null) {
				console.error('Viewmap is undefined');
				return;
			}
			if (viewManager.xNested === true && viewManager.isNested() === true) {
				return;
			}
			viewmap.each(function (view) {
				ruta.add(view.route, function (route) {
					var current = route.current,
					    path = current.path,
					    params = current.params;
					viewManager.navigate(path, null, { params: params });
				});
			});
		};

		function obj_default(a, b) {
			if (b == null) {
				return a;
			}
			if (a == null) {
				return b;
			}
			for (var key in b) {
				if (a[key] == null) {
					a[key] = b[key];
				}
			}
			return a;
		}
	})();
	//# sourceMappingURL=ViewMap.es6.map
	// end:source class/ViewMap.es6

	// source class/ActivityTracker.es6
	'use strict';

	var ActivityTracker;
	(function () {
		ActivityTracker = mask.class.create({
			tickStart: null,
			tickEnd: null,
			history: null,
			vm: null,
			constructor: function constructor(viewManager) {
				this.history = [];
				this.routes = [];
				this.vm = viewManager;
				this.activityCounter = 0;
				this.isBusy = false;
			},
			show: function show(route, loaderFn) {
				var _this = this;

				var i = this.routes.indexOf(route),
				    dfr;
				if (i === -1) {
					route.dfr = dfr = loaderFn();
					this.routes.push(route);
				} else {
					dfr = this.routes[i].dfr;
				}

				this.history.push({ current: route.current, route: route });
				this._requestProgressStart();
				return dfr.done(function () {
					return _this._requestProgressEnd(route);
				}).fail(function (error) {
					return console.error(error);
				});
			},
			clear: function clear(route) {
				var i = this.routes.indexOf(route);
				if (i === -1) return;

				route.dfr = null;
				route.value.compo = null;
				this.routes.splice(i, 1);
			},
			_requestProgressStart: function _requestProgressStart(route) {
				this._activity(1, route);
			},
			_requestProgressEnd: function _requestProgressEnd(route) {
				this._activity(-1, route);
			},
			_cancelProgressStart: function _cancelProgressStart() {
				clearTimeout(this.tickStart);
			},
			_cancelProgressEnd: function _cancelProgressEnd() {
				clearTimeout(this.tickEnd);
			},
			_progressStart: function _progressStart(route) {
				this._cancelProgressStart();
				this._cancelProgressEnd();
				this.isBusy = true;
				this.vm.emitIn('viewActivity', 'start');
			},
			_progressEnd: function _progressEnd(route) {
				// if (route != null && this.current !== route) {
				// 	return;
				// }
				this._cancelProgressStart();
				this._cancelProgressEnd();
				this.isBusy = false;
				this.vm.emitIn('viewActivity', 'end');
			},
			_activity: function _activity(val, route) {
				this._cancelProgressEnd();
				this._cancelProgressStart();

				if ((this.activityCounter += val) < 0) {
					this.activityCounter = 0;
				}
				var shouldBeBusy = this.activityCounter > 0;
				if (shouldBeBusy === this.isBusy) {
					return;
				}
				if (shouldBeBusy) {
					this.tickStart = setTimeout(this._progressStart.bind(this, route));
				} else {
					this.tickEnd = setTimeout(this._progressEnd.bind(this, route));
				}
			},

			get current() {
				var track = this.history[this.history.length - 1];
				return track && track.route;
			},
			back: function back() {
				this.history.pop();
				return this.history.pop();
			}
		});
	})();
	//# sourceMappingURL=ActivityTracker.es6.map
	// end:source class/ActivityTracker.es6
	// source class/ViewChanger.es6
	'use strict';

	var ViewChanger;
	(function () {
		ViewChanger = mask.class.create({
			vm: null,
			constructor: function constructor(viewManager) {
				this.vm = viewManager;
			},
			show: function show(route, prevRoute, isInitial) {
				var _this = this;

				var show = this.getShow(route, prevRoute);
				var hide = this.getHide(prevRoute, route);
				if (show.parallel) {
					this.hide_(hide, prevRoute);
					this.show_(show, route, isInitial);
					return;
				}
				this.hide_(hide, prevRoute).then(function () {
					return _this.show_(show, route, isInitial);
				});
			},
			show_: function show_(ani, route, isInitial) {
				var _this2 = this;

				return mask.class.Deferred.run(function (resolve) {
					_this2.vm.showCompo_(route.value.compo, isInitial).then(function () {
						var el = route.value.compo.$[0];
						ani.start(resolve, el, { route: route, isInitial: isInitial });
					});
				});
			},
			hide_: function hide_(ani, route) {
				var _this3 = this;

				return mask.class.Deferred.run(function (resolve) {
					if (route.value.compo == null) {
						resolve();
						return;
					}
					ani.start(function () {
						_this3.vm.hideCompo_(route.value.compo).then(resolve);
					}, route.value.compo.$[0], { route: route });
				});
			},
			getShow: function getShow(route, beforeRoute) {
				return this.getAniForRoute(route, 'show', beforeRoute);
			},
			getHide: function getHide(route, nextRoute) {
				return this.getAniForRoute(route, 'hide', nextRoute);
			},
			getAniForCompo: function getAniForCompo(compo, id, pairedRouteDefinition) {
				return findAnimation(compo, id, pairedRouteDefinition);
			},
			getAniForRoute: function getAniForRoute(route, id, anchorRoute) {
				var pairedDef = anchorRoute.definition;
				var ani = this.getAniForCompo(route.value.compo, id, pairedDef);
				if (ani == null) {
					ani = this.getAniForCompo(this.vm, id, pairedDef);
				}
				return ani ? ani : Default;
			}
		});

		var Default = {
			attr: {},
			start: function start(cb) {
				cb();
			}
		};

		function findAnimation(owner, id, pairedRouteDefinition) {
			if (owner == null) {
				return null;
			}
			var compos = owner.components;
			if (compos == null) {
				return null;
			}
			var imax = compos.length,
			    i = -1,
			    default_ = null;
			while (++i < imax) {
				var compo = compos[i];
				var name = compo.compoName || compo.tagName;
				if (name === 'imports' || name === 'import') {
					var ani = findAnimation(compo, id, pairedRouteDefinition);
					if (ani) {
						return ani;
					}
				}
				if (name === 'Animation' && compo.attr.id === id) {
					var for_ = compo.attr.for;
					if (for_ == null && default_ == null) {
						default_ = compo;
					}
					if (for_ === pairedRouteDefinition) {
						return compo;
					}
				}
			}
			return default_;
		}
	})();
	//# sourceMappingURL=ViewChanger.es6.map
	// end:source class/ViewChanger.es6

	// source compo/ViewManager.es6
	'use strict';

	var ViewManagerCompo = mask.Compo({
		tagName: 'div',
		attr: {
			style: 'position: relative',
			class: 'v-manager'
		},

		meta: {
			attributes: {
				base: '',
				viewmap: '',
				routing: true,
				nested: true
			},
			serializeScope: true
		},

		serializeScope: function serializeScope() {
			return JSON.stringify(this.scope);
		},

		slots: {
			viewNavigate: function viewNavigate(sender, path, model, route) {
				if (sender === this) return;
				var current = this.route;
				var compo = current && current.value && current.value.compo;
				this.navigate(path, model, {
					defaultView: false,
					fromParent: true,
					params: route && route.current.params || null
				});
				return false;
			},
			viewActivation: function viewActivation(sender) {
				if (sender === this) return;
				var compo = this.route && this.route.value && this.route.value.compo;
				if (compo) {
					//compo.emitIn('viewActivation', this);
				}
				return false;
			},
			viewDeactivation: function viewDeactivation(sender) {
				if (sender === this) return;
				var compo = this.route && this.route.value && this.route.value.compo;
				if (compo) {
					compo.emitIn('viewDeactivation', this);
				}
				return false;
			},
			back: function back(sender) {
				var track = this.activityTracker.back();
				this.navigate(track.current.path);
			}
		},

		scope: {
			notificationMsg: '',
			notificationType: '',
			viewmap: null
		},

		viewmap: null,
		routes: null,
		route: null,
		next: null,

		activity: function activity(type) {
			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			this.emitIn.apply(this, ['views:activity', type].concat(args));
		},
		constructor: function constructor() {
			this.routes = new ruta.Collection();
		},
		onRenderStart: function onRenderStart(model, ctx) {
			var _this2 = this;

			ViewMap.ensure(this, model, ctx);
			ViewMap.createRoutes(this);

			var path = path_getCurrent(ctx);
			var route = ViewMap.getRouteByPath(this, path);
			var params = route && route.current && route.current.params;
			if (params) {
				if (ctx.params == null) {
					ctx.params = {};
				}
				mask.obj.extend(ctx.params, params);
			}

			this.attr.path = path;
			this.route = route;
			this.nodes = j().add(this.getCompo_('Notification')).add(this.getCompo_('Progress')).add(this.getCompo_('Animation'), false);

			if (route == null) {
				return;
			}
			var viewData = route.value;
			if (viewData.path == null) {
				this.nodes.add(viewData.getNodes() || j());
				return;
			}
			var resume = Compo.pause(this, ctx);
			this.loadView(route, model).done(function (route) {
				_this2.nodes.add(viewData.getNodes() || j());
				resume();
			}).fail(function () {
				return resume();
			});
		},
		onRenderStartClient: function onRenderStartClient(model, ctx) {
			ViewMap.ensure(this, model, ctx);
			ViewMap.createRoutes(this);
		},
		onRenderEndServer: function onRenderEndServer() {
			this.scope.viewmap = this.viewmap.toJSON();
		},
		onRenderEnd: function onRenderEnd(elements, model, ctx) {
			var _this3 = this;

			this.activityTracker = new ActivityTracker(this);
			this.viewChanger = new ViewChanger(this);
			this.ctx = ctx;

			if (this.xRouting) {
				ViewMap.bindRouter(this, model, ctx);
			}
			if (this.route == null && this.attr.path != null) {
				this.route = ViewMap.getRouteByPath(this, this.attr.path);
			}
			if (this.route == null) {
				return;
			}
			var viewData = this.route.value;
			var compo = this.find('View');
			if (compo != null) {
				compo.emitIn('viewActivation', this);
			}
			viewData.compo = compo;
			this.activityTracker.show(this.route, function () {
				return Compo.await(_this3);
			});
		},
		getCtx: function getCtx(route) {
			var ctx = mask.obj.extend(null, this.ctx);
			ctx.params = route.current.params;
			return ctx;
		},
		isNested: function isNested() {
			var owner = Compo.closest(this.parent, 'ViewManager');
			return owner != null;
		},
		navigate: function navigate(path, model, opts) {
			var _this4 = this;

			var route = ViewMap.getRouteByPathOrCurrentOrDefault(this, path, opts && opts.params);
			var dfr = new mask.class.Deferred();
			if (route == null) {
				return dfr.reject('View not found: ' + path);
			}
			var initial = route.value.compo == null;
			if (route === this.route) {
				if (initial === false) {
					route.value.compo.emitIn('viewNavigate', path, model, route);
				}
				if (opts && opts.fromParent === true && route.value.compo) {
					route.value.compo.emitIn('viewActivation', this);
				}
				return dfr.resolve(route);
			}
			return this.activityTracker.show(route, function () {
				return _this4.loadView(route, model).then(function () {
					return _this4.renderView(route, model);
				});
			}).done(function () {
				if (initial === false) {
					route.value.compo.emitIn('viewNavigate', path);
				}
				_this4.performShow(route, initial);
			});
		},
		hideCompo_: function hideCompo_(compo) {
			if (compo == null) return;
			compo.emitIn('viewDeactivation', this);
			return compo.hide_();
		},
		showCompo_: function showCompo_(compo, isInitial) {
			var _this5 = this;

			return compo.show_().then(function () {
				return compo.emitIn('viewActivation', _this5);
			});
		},
		emit: function emit(type) {
			var _Compo$pipe;

			for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				args[_key2 - 1] = arguments[_key2];
			}

			(_Compo$pipe = Compo.pipe('views')).emit.apply(_Compo$pipe, [type, this].concat(args));
		},
		loadView: function loadView(route, model) {
			return mask.class.Deferred.run(function (resolve, reject) {
				var viewData = route.value;
				if (viewData.viewNode != null) {
					resolve(route);
					return;
				}
				var path = viewData.path;
				mask.Module.createModule(new mask.Module.Endpoint(path, 'mask')).loadModule().fail(reject).done(function (module) {
					var nodes = module.exports.__nodes__;
					viewData.createViewNode(nodes);
					resolve(route);
				});
			});
		},
		renderView: function renderView(route, model) {
			var _this6 = this;

			return mask.class.Deferred.run(function (resolve, reject, dfr) {
				if (route.value.compo) {
					resolve(route);
					return;
				}
				var ctx = _this6.getCtx(route);
				mask.renderAsync(route.value.getNodes(), model || _this6.model, ctx, null, _this6).done(function (frag, compo) {
					var last = compo.components[compo.components.length - 1];
					var view = Compo.prototype.find.call(last, 'View');
					route.value.compo = view;
					resolve(route);
				});
			});
		},
		performShow: function performShow(route, isInitial) {
			var current = this.route;
			if (current === route) {
				return;
			}
			this.route = route;
			this.viewChanger.show(route, current, isInitial);

			if (current != null && current.value.compo != null) {
				if (current.value.compo.xRecycle === true) {
					this.activityTracker.clear(current);
				}
			}
		},
		notify: function notify(type, message) {
			if (arguments.length === 0) {
				type = message = '';
			}
			this.scope.notificationType = type;
			this.scope.notificationMsg = message;
			this.emitIn('formNotification', { type: type, message: message });
		},
		getCompo_: function getCompo_(name) {
			var shouldCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

			var set = j(this).children(name);
			if (shouldCreate === false) {
				return set;
			}
			return set.length === 0 ? j(name) : set;
		},
		throw_: function throw_(error) {
			this.nodes = mask.parse('\n\t\t\tdiv style=\'background: red; color: white; padding: 15px; font-weight: bold\' {\n\t\t\t\t"' + error.message + '"\n\t\t\t}\n\t\t');
		},
		errored_: function errored_(error) {
			this.activity('end');
			this.activity('error', error);
			this.notify('danger', error.message || String(error));
		}
	});

	// source Controls/exports.es6
	"use strict";

	var Template = "\n\t// source Notification.mask\n\tlet Notification as (div) {\n\t\t\n\t\tslot formNotification () {\n\t\t\tvar form = this.closest('a:form');\n\t\t\tif (!form.scope.notificationMsg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar el = this.$.get(0);\n\t\t\tif (el) {\n\t\t\t\tel.scrollIntoView(true);\n\t\t\t}\n\t\t}\n\t\t\n\t\t@if (template) {\n\t\t\t@template;\n\t\t}\n\t\t@else {\n\t\t\t+if (notificationMsg) {\n\t\t\t\t.alert.alert-~[bind: $scope.notificationType] > '~[bind: $scope.notificationMsg ]'\n\t\t\t}\n\t\t}\n\t}\n\t// end:source Notification.mask\n\t// source Progress.mask\n\tlet Progress {\n\t\tvar value = -1;\n\t\tvar progress = false;\n\t\n\t\tslot viewActivity (sender, type, percent) {\n\t\t\tif (type === 'start') {\n\t\t\t\tthis.scope.progress = true;\n\t\t\t}\n\t\t\tif (type === 'end') {\n\t\t\t\tthis.scope.progress = false;\n\t\t\t}\n\t\t\tif (type === 'progress' && typeof percent === 'number') {\n\t\t\t\tthis.scope.value = percent;\n\t\t\t}\n\t\t}\n\t\n\t\t.-a-views-progress style='display: ~[bind: $scope.progress ? \"block\" : \"none\" ]'{\n\t\n\t\t\tprogress value='~[bind: $scope.value == -1 ? null : $scope.value]' max=100;\n\t\n\t\t\tstyle scoped {\n\t\t\t\tprogress {\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\tmargin: auto;\n\t\t\t\t\twidth: 98%;\n\t\t\t\t\theight: 3px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// end:source Progress.mask\n";
	mask.define(ViewManagerCompo, Template);
	//# sourceMappingURL=exports.es6.map
	// end:source Controls/exports.es6
	// source View.es6
	'use strict';

	var ViewCompo;
	(function () {

		var view_NONE = 1,
		    view_DETACHED = 2,
		    view_ATTACHED = 3,
		    view_VISIBLE = 4,
		    view_HIDDEN = 5;

		ViewCompo = Compo({
			meta: {
				attributes: {
					'default': false,
					'display': {
						description: 'Hides view when not visible',
						default: false,
						type: 'boolean'
					},
					'detach': true,
					'recycle': false
				}
			},
			slots: {
				viewDeactivation: function viewDeactivation() {
					if (this.state === view_HIDDEN) {
						return false;
					}
					this.state = view_HIDDEN;
				}
			},
			tagName: 'div',
			attr: {
				class: 'v-view'
			},
			onRenderStart: function onRenderStart() {},

			state: view_NONE,
			hide_: function hide_() {
				var _this = this;

				return this.hide().then(function () {
					if (_this.xRecycle === true) {
						_this.remove();
						return;
					}
					if (_this.xDetach === true) {
						_this.state = view_DETACHED;
						var fn = _this.$.detach || _this.$.remove;
						fn.call(_this.$);
					}
				});
			},
			show_: function show_() {
				if (this.state <= view_ATTACHED) {
					this.parent.$.append(this.$);
				}
				if (this.state === view_NONE) {
					this.emitIn('domInsert');
					this.state = view_ATTACHED;
				}
				return this.show();
			},
			hide: function hide() {
				var isVisible = this.xDisplay ? view_VISIBLE : view_HIDDEN;
				if (isVisible === false) {
					this.$.hide();
				}
				return new mask.class.Deferred().resolve();
			},
			show: function show() {
				var isVisible = this.xDisplay ? view_VISIBLE : view_HIDDEN;
				if (isVisible === false) {
					this.$.show();
				}
				return new mask.class.Deferred().resolve();
			}
		});

		mask.define(ViewManagerCompo, 'View', ViewCompo);
	})();
	//# sourceMappingURL=View.es6.map
	// end:source View.es6
	//# sourceMappingURL=ViewManager.es6.map
	// end:source compo/ViewManager.es6
	mask.registerHandler('ViewManager', ViewManagerCompo);
});
//# sourceMappingURL=umd.es6.map
// end:source /src/umd.es6